{"meta":{"title":"周瑜的小家园","subtitle":"","description":"","author":"周瑜","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"OpenFeign学习记录","slug":"OpenFeign-md","date":"2021-03-16T08:48:18.000Z","updated":"2021-03-16T09:03:01.597Z","comments":true,"path":"2021/03/16/OpenFeign-md/","link":"","permalink":"http://yoursite.com/2021/03/16/OpenFeign-md/","excerpt":"","text":"Feign声明式服务调用1.什么是feign Feign是SpringCloud Netflix 组件中的一个轻量级RESTful的HTTP服务客户端，实现了负载均衡和Rest调用的开源框架，封装了Ribbon和RestTemplate，实现了WebService的面向接口编程，进一步降低了项目的耦合度。 Feign内置了Ribbon，用来做客户端负载均衡调用服务注册中心的服务。 Feign本身并不支持SpringMVC的注解，他有一套自己的注解，为了更方便的使用，Spring Cloud孵化了OpenFeign。 Feign是一种声明式、模板化的HTTP客户端（仅在Consumer中使用） Feign支持的注解和用法请参考官方文档 Feign的使用方式是：使用Feign的注解定义接口，调用这个接口，就可以调用注册中心的服务 2.Feign解决了什么问题 Feign旨在使编写JAVA HTTP 客户端变得更容易，Feign简化了Rest Template代码，实现了Ribbon负载均衡，是代码变得更加简洁，也少了客户端调用的代码，使用Feign实现负载均衡是首选方案。只需要你创建一个接口，然后在上面添加注解即可。 Feign是声明式服务调用组件，其核心就是：像调用本地方法一样调用远程方法，无感知远程HTTP请求。 它解决了让开发者调用远程接口就跟调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求，无需关注与远程的交互细节，更无需关注分布式环境开发。 它像Dubbo一样 ，Consumer直接调用Provider接口方法，而不需要通过常规的Http Client狗仔请求再解析返回数据。 3.Feign vs Open Feign OpenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequestMapping、@Pathvariable等等。 OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用服务。 4.Feign入门案例Feign的使用主要分为一下几个步骤： 服务消费者添加Feign依赖； 创建业务层接口，添加@FeignClient注解声明要调用的服务； 业务层抽象方法使用SpringMVC注解来配置服务地址及参数 启动类添加@EnableFeignClient注解激活Feign组件 5.Feign实例项目 先创建一个空项目 然后分别创建两个eureka注册中心 eureka-server 添加eureka依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; 123456789101112131415161718- 编写配置文件 - ```yml spring: application: name: eureka-server #应用名称 server: port: 8761 eureka: instance: hostname: eureka01 #主机名 prefer-ip-address: true instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125; #ip:port client: #设置服务注册中心地址，指向另一个注册中心 service-url: #注册中心对外暴露的注册地址 defaultZone: http://localhost:8762/eureka/ eureka-server02 同上，配置文件修改一下端口和注册地址 spring: application: name: eureka-server #应用名称 server: port: 8762 eureka: instance: hostname: eureka02 #主机名 prefer-ip-address: true instance-id: ${spring.cloud.client.ip-address}:${server.port} #ip:port client: #设置服务注册中心地址，指向另一个注册中心 service-url: #注册中心对外暴露的注册地址 defaultZone: http://localhost:8761/eureka/ 1234567891011121314151617181920212223- 在创建两个服务端并注册到注册中心去，待会供我们的消费者使用 - service-provider - 添加依赖 - ```xml &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; 编写配置文件 spring: application: name: service-provider server: port: 7070 eureka: instance: prefer-ip-address: true instance-id: ${spring.cloud.client.ip-address}:${server.port} client: service-url: defaultZone: http://localhost:8761/eureka/, http://localhost:8762/eureka/ #将其分别注册进两个注册中心中 123456789101112131415161718192021- 编写bean - ```java package com.feign.serviceprovider.bean; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; @Data @NoArgsConstructor @AllArgsConstructor public class Product implements Serializable &#123; private Integer id; private String productName; private Integer productNum; private Double productPrice; &#125; 编写service 接口 package com.feign.serviceprovider.service; import com.feign.serviceprovider.bean.Product; import java.util.List; public interface ProductService { List&lt;Product&gt; getPro(); } &lt;!--￼3--&gt; 编写控制器 package com.feign.serviceprovider.controller; import com.feign.serviceprovider.service.ProductService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class ProductController { @Autowired ProductService productService; @GetMapping(\"/getPro\") public Object getPro(){ return productService.getPro(); } } &lt;!--￼4--&gt; 编写配置文件 spring: application: name: service-provider server: port: 9090 eureka: client: service-url: defaultZone: http://localhost:8761/eureka/,http://localhost:8762/eureka/ register-with-eureka: false #是否将自己注册到注册中心，默认为true registry-fetch-interval-seconds: 10 #表示Eureka Client间隔多久去服务器拉取注册信息，默认为30秒 123456789101112131415161718192021222324- 编写bean - Order - ```java package com.feign.serviceconsumer.bean; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; import java.util.List; @Data @AllArgsConstructor @NoArgsConstructor public class Order implements Serializable &#123; private Integer id; private String orderNo; private String orderAddress; private Double totalPrice; private List&lt;Product&gt; productList; &#125; Product import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; @Data @NoArgsConstructor @AllArgsConstructor public class Product implements Serializable { private Integer id; private String productName; private Integer productNum; private Double productPrice; } &lt;!--￼6--&gt; Order 接口 package com.feign.serviceconsumer.service; import com.feign.serviceconsumer.bean.Order; public interface OrderService { Order selectOrderById(Integer id); } &lt;!--￼7--&gt; controller层 package com.feign.serviceconsumer.controller; import com.feign.serviceconsumer.bean.Order; import com.feign.serviceconsumer.service.OrderService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; @RestController public class OrderController { @Autowired private OrderService orderService; @GetMapping(\"/getOrder/{id}\") public Order getOrder(@PathVariable(\"id\") Integer id){ return orderService.selectOrderById(id); } } &lt;!--￼8--&gt; 效果图：分别为第一次访问和第二次访问，feign自带负载均衡配置项，会依次访问两个服务端 image-20210315224047507 image-20210315224119387 6.feign负载均衡的配置 feign负载均衡默认是轮询的，目前feign3.0.1好像配置没有，里面没有内置ribbonjar包 123SERVICE-PROVIDER: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule com.netflix.loadbalancer.RandomRule #配置规则 随机，几个提供者间随机访问 com.netflix.loadbalancer.RoundRobinRule #配置规则 轮询，轮流访问 com.netflix.loadbalancer.RetryRule #配置规则 重试，在一段时间内通过RoundRobinRule选择服务实例，一段时间内没有选择出服务则线程终止 com.netflix.loadbalancer.WeightedResponseTimeRule #配置规则 响应时间权重，根据平均响应时间来计算权重 com.netflix.loadbalancer.BestAvailableRule #配置规则 最空闲连接策略 7.feign传参 GET 使用@PathVariable注解或@RequestParam注解接收请求参数 实例 在服务提供者service-provider的接口添加一个根据id查询的方法 package com.feign.serviceprovider.service; import com.feign.serviceprovider.bean.Product; import java.util.List; public interface ProductService { List&lt;Product&gt; getPro(); Product getProById(Integer id); } &lt;!--￼10--&gt; 在控制器层映射这个方法 @GetMapping(\"/getProById/{id}\") public Object getProById(@PathVariable(\"id\") Integer id){ return productService.getProById(id); } &lt;!--￼11--&gt; 修改Order实现类，返回调用服务提供者的根据id查询方法 @Override public Order selectOrderById(Integer id) { return new Order(id,\"order-001\",\"中国\",2222.00, Arrays.asList(productService.getProById(5))); } &lt;!--￼12--&gt; 在impl实现这个接口 @Override public Product getProByIdPost(Integer id) { return new Product(id,\"洗衣机\",5,3999.00); } @Override public Map&lt;Object, Object&gt; createPro(Product product) { System.out.println(product); Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); if(product == null){ map.put(\"code\",400); map.put(\"msg\",\"添加失败\"); return map; } map.put(\"code\",200); map.put(\"msg\",\"添加成功\"); return map; } &lt;!--￼13--&gt; @PostMapping(\"/getProByIdPost\") public Object getProByIdPost(@RequestBody Integer id){ return productService.getProByIdPost(id); } @PostMapping(\"save\") //注意这里要加上@RequestBody注解，不然实现类那里获取不到product的值 public Map&lt;Object,Object&gt; save(@RequestBody Product product){ return productService.createPro(product); } &lt;!--￼14--&gt; @FeignClient(\"SERVICE-PROVIDER\") public interface ProductService { @GetMapping(\"/getPro\") List&lt;Product&gt; getPro(); @GetMapping(\"/getProById/{id}\") Product getProById(@PathVariable(\"id\") Integer id); @PostMapping(\"/getProByIdPost\") Product getProByIdPost(Integer id); @PostMapping(\"save\") Map&lt;Object,Object&gt; createPro(Product product); } &lt;!--￼15--&gt; 成功调用服务提供者的方法，效果图： image-20210316132939295 image-20210316133112713 8.Feign性能优化 Gzip压缩 介绍：gzip是一种数据格式，采用deflate算法压缩数据；gzip是一种流行的文件压缩算法，应用十分广泛，尤其是在Linux平台。 gzip能力：当gzip压缩一个纯文本文件时，效果是非常明显的，大约可以减少70%以上的文件大小。 gzip作用：网络数据经过压缩后实际上降低了网络传输的字节数，最明显的好处就是可以加快网页加载的速度。 实例：百度用的就是gzip压缩 image-20210316134006646 Accept-Encoding向服务端表示客户端支持的压缩格式，如果不发送该消息头，服务端默认是不会压缩的 服务端在收到请求后，如果发现请求头中含有Accept-Encoding字段，并且支持该类型压缩，就会对响应报文压缩之后返回给客户端，并且携带Content-Encoding：gzip消息头，表示响应报文是根据该格式进行压缩的。 客户端接收到请求后，先判断是否有Content-Encoding消息头，如果有，按照格式解压报文。否则按正常报文处理 image-20210316134157354 全局配置 –目前无效，原因不详 –添加这个mime-types: “application/xhtml+xml”就好了 12345678 server: port: 9090 compression: enabled: true #是否开启压缩 #mime-types：配置压缩支持的类型。默认支持\"text/html\", \"text/xml\", \"text/plain\", \"text/css\", \"text/javascript\",\"application/javascript\", \"application/json\", \"application/xml\" # mime-types: 局部配置 百度一下 HTTP连接池 将Feign的Http客户端工具修改为HttpClient 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt; &lt;version&gt;11.1&lt;/version&gt;&lt;/dependency&gt; 使用了HttpClient客户端之后，我们还可以通过Get请求传递对象参数。 服务提供者新增方法 接口 1Product savePro(Product product); impl 12345@Overridepublic Product savePro(Product product) &#123; System.out.println(product); return product;&#125; 控制器 1234@GetMapping(\"savePro\")public Product savePro(@RequestBody Product product)&#123;return product;&#125; 消费者远程调用 接口 12@GetMapping(\"/savePro\")Product savePro(Product product); 控制器 1234@GetMapping(\"/savePro\")public Product savePro(Product product)&#123; return product;&#125; 效果图： image-20210316150339188 状态查看 –过时 请求超时 –目前Feign失效，默认1秒超时都不报错 全局 123ribbon: ConnectTimeout: 2000 ReadTimeout: 2000 局部 image-20210316155310299","categories":[],"tags":[]},{"title":"apollo 学习记录","slug":"apollo-md","date":"2021-03-15T03:38:55.000Z","updated":"2021-03-15T04:39:42.125Z","comments":true,"path":"2021/03/15/apollo-md/","link":"","permalink":"http://yoursite.com/2021/03/15/apollo-md/","excerpt":"","text":"Apollo分布式配置中心1.Apollo快速开始 下载Quick Start安装包 创建ApolloPortalDB和apolloConfigDB数据库 配置数据库连接信息 123456789echoset url=\"localhost:3306\"set username=\"root\"set password=\"123456\"start \"configService\" java -Xms256m -Xmx256m -Dapollo_profile=github -Dspring.datasource.url=jdbc:mysql://%url%/ApolloConfigDB?characterEncoding=utf8 -Dspring.datasource.username=%username% -Dspring.datasource.password=%password% -Dlogging.file=.\\logs\\apollo-configservice.log -jar .\\apollo-configservice-1.3.0.jarstart \"adminService\" java -Xms256m -Xmx256m -Dapollo_profile=github -Dspring.datasource.url=jdbc:mysql://%url%/ApolloConfigDB?characterEncoding=utf8 -Dspring.datasource.username=%username% -Dspring.datasource.password=%password% -Dlogging.file=.\\logs\\apollo-adminservice.log -jar .\\apollo-adminservice-1.3.0.jarstart \"ApolloPortal\" java -Xms256m -Xmx256m -Dapollo_profile=github,auth -Ddev_meta=http://localhost:8080/ -Dserver.port=8070 -Dspring.datasource.url=jdbc:mysql://%url%/ApolloPortalDB?characterEncoding=utf8 -Dspring.datasource.username=%username% -Dspring.datasource.password=%password% -Dlogging.file=.\\logs\\apollo-portal.log -jar .\\apollo-portal-1.3.0.jar 启动Apollo配置中心，端口不能被占用 执行runApollo.bat脚本 image-20210311155701217 创建一个Apollo项目 image-20210311155734407 创建需要的配置 image-20210311155841873 创建完成后用Idea测试，创建一个spring boot项目 引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt; &lt;artifactId&gt;apollo-client&lt;/artifactId&gt; &lt;version&gt;1.8.0&lt;/version&gt; &lt;/dependency&gt; 指定配置项目的id 环境 和地址 1-Dapp.id&#x3D;apollo-quick -Denv&#x3D;DEV -Ddev_meta&#x3D;http:&#x2F;&#x2F;localhost:8080 测试类进行测试 1234567891011121314151617181920@Slf4j@SpringBootTestclass Project7ApplicationTests &#123; @Test void contextLoads() &#123; Config appConfig = ConfigService.getAppConfig(); //获取配置对象 //Apollo是热发布的，实时更新，使用方法测试 while (true)&#123; try &#123; Thread.sleep(1000); //获取配置信息，第一个参数：配置的key，第二个参数：默认值 String sms = appConfig.getProperty(\"sms\", null); log.info(\"sms: \"+sms); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 2.Apollo核心概念1.application(应用)​ 就是实际使用配置的应用，Apollo客户端在运行时需要知道当前应用是谁从而可以去获取对应的配置 关键字：appId 2.environment（环境）配置对应的环境，Apollo客户端在运行时需要知道当前应用处于哪个环境，从而可以去获取应用的配置 关键字：env 3.cluster（集群）一个应用下不同实例的分组，比如典型的可以按照数据中心分。把上海机房的应用实例分为一个集群，把北京机房的应用实例分为另一个集群。 关键字：cluster 4.namespace(命名空间)一个应用下不同配置的分组，可以简单的把namespace类比为文件，不同类型的配置放在不同的文件中，如数据库配置文件，RPC配置文件，应用自身的配置文件等。 关键字：namespace 他们的关系图：image-20210311164008302 3.Apollo项目管理1.基础设置 添加部门 Apollo主页 –&gt; 管理员工具 –&gt; 系统参数 image-20210311170948744 查询配置信息：organizations然后在返回的json数据中添加 image-20210311171256529 添加用户 Apollo主页 –&gt; 管理员工具 –&gt; 用户管理 删除项目 Apollo主页 –&gt; 管理员工具 –&gt; 删除应用，集群 2.添加Namespaceimage-20210311173549047 image-20210311173620947 快捷导入配置 复制配置放入文本中 image-20210311173807720 获取namespace的配置 1234567891011121314151617181920@Slf4j@SpringBootTestclass Project7ApplicationTests &#123; @Test void contextLoads() &#123;// Config appConfig = ConfigService.getAppConfig(); 获取默认namespace下的配置信息 //获取指定namespace下的配置信息 Config appConfig = ConfigService.getConfig(\"apollo-redis\"); while (true)&#123; try &#123; Thread.sleep(1000); String sms = appConfig.getProperty(\"spring.redis.host\", null); log.info(\"spring.redis.host: \"+sms); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 4.springboot集成Apollo1.使用@value注解获取 获取默认namespace的值 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt; &lt;artifactId&gt;apollo-client&lt;/artifactId&gt; &lt;version&gt;1.8.0&lt;/version&gt; &lt;/dependency&gt; 编写Apollo相关的配置 12app.id=apollo-quickapollo.meta=http://localhost:8080 使用controller进行测试 1234567891011@EnableApolloConfig //@RestControllerpublic class apolloController &#123; @Value(\"$&#123;mysql&#125;\") //获取key为mysql的配置 private String name; @GetMapping(\"/mysql\") public Object getapollo()&#123; return \"mysql\"+name; &#125;&#125; 获取指定namespace的值1234567891011121314@RestController@EnableApolloConfig(\"redis\") //指定namespace名称public class redisController &#123; @Value(\"$&#123;spring.redis.host&#125;\") private String redisHost; @Value(\"$&#123;spring.redis.client-type&#125;\") private String redisType; @GetMapping(\"/redis\") public Object getRedis()&#123; return \"redis连接地址： \"+redisHost+\"redis类型： \"+redisType; &#125;&#125; 2.使用bean注入的方式获取 bean 1234567@Component@ConfigurationProperties(\"spring.redis\") //添加之后自动识别此前缀下的配置@Datapublic class ApolloConfig &#123; private String host; //加上前缀对应配置中心的key private String client_type;&#125; controller 123456789101112@RestController@EnableApolloConfig(\"redis\")public class BeanController &#123; @Autowired ApolloConfig apolloConfig; @GetMapping(\"/redisBean\") public Object getRedisBean()&#123; return apolloConfig; &#125;&#125; bean注入不会自动刷新，使用@RefreshScope注解 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; 1234567891011121314151617181920212223242526- ##### 自动刷新配置类 ```java @Component public class RefreshConfig &#123; @Autowired ApolloConfig apolloConfig; @Autowired RefreshScope refreshScope; @ApolloConfigChangeListener(&#123;\"redis\"&#125;) public void onChange(ConfigChangeEvent configChangeEvent)&#123; boolean configChange = false; for(String cKey : configChangeEvent.changedKeys())&#123; if (cKey.startsWith(\"spring.redis\"))&#123; configChange = true; break; &#125; &#125; if (!configChange)&#123; return; &#125; refreshScope.refresh(\"apolloConfig\"); &#125; &#125; bean12345678@Component@ConfigurationProperties(\"spring.redis\")@Data@RefreshScopepublic class ApolloConfig &#123; private String host; private String client_type;&#125; 目前会报错 还没找到原因，记录一下1Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.http.converter.HttpMessageConversionException: Type definition error: [simple type, class org.springframework.context.expression.StandardBeanExpressionResolver]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class org.springframework.context.expression.StandardBeanExpressionResolver and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: com.project.project7.config.ApolloConfig$$EnhancerBySpringCGLIB$$7b737735[&quot;targetSource&quot;]-&gt;org.springframework.aop.target.SimpleBeanTargetSource[&quot;beanFactory&quot;]-&gt;org.springframework.beans.factory.support.DefaultListableBeanFactory[&quot;beanExpressionResolver&quot;])] with root cause 3.灰度发布 获取方式也是用@value，跟一一样 5.Apollo的高可用","categories":[],"tags":[]},{"title":"linux 学习记录","slug":"Linux-md","date":"2021-03-15T03:36:55.000Z","updated":"2021-03-15T04:39:33.691Z","comments":true,"path":"2021/03/15/Linux-md/","link":"","permalink":"http://yoursite.com/2021/03/15/Linux-md/","excerpt":"","text":"Linux学习记录一、Linux基础篇1.Linux介绍 Linux是一款操作系统，免费，开源，安全，高效，处理高并发非常强悍，现在很多的企业级项目都部署到Linux服务器上。 2.Linux的目录结构​ Linux的文件系统是采用层级式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下在创建其他的目录。 深刻理解Linux树状文件目录是非常重要的，在Linux世界中，一切皆文件 image-20210313133827488 目录结构的具体介绍 image-20210313133940934 image-20210313134026240 image-20210313134102561 Linux目录总结 Linux的目录中有且只有一个根目录/ Linux的各个目录存放的内容都是规划好的，不能乱放文件 Linux是以文件的形式管理我们的设备，因此Linux系统，一切皆为文件 Linux的各个文件目录下存放什么内容，必须要有一个认识 学习后，脑海中应该有一颗Linux目录树 3.Linux远程操作 我用Windows10安装Ubuntu桌面子系统每次连接都要重启xrdp服务 1sudo &#x2F;etc&#x2F;init.d&#x2F;xrdp restart 4.ubuntu设置中文 下载中文语音包 1sudo apt-get install language-pack-zh-han* 设置中文 1export LC_ALL=zh_CN.UTF-8 输入locale 将显示出来的内容备份 12345678CC.UTF-8en_US.utf8POSIXzh_CN.utf8zh_HK.utf8zh_SG.utf8zh_TW.utf8 二、Linux实操篇1.使用Xshell远程连接 使用Xshell远程连接,然后发现他说无法连接 12Connecting to 192.168.100.104:22...Could not connect to &#39;192.168.100.104&#39; (port 22): Connection failed. ping了一下网络是能ping通的 1ping 192.168.100.104 然后关闭防火墙说报错 image-20210313142208017 然后在终端查看ssh进程，输入ps -e|grep ssh，如果有安装openssh-client只会出现ssh -agent，不会出现sshd image-20210313142133227 要想开放本机SSH服务以便其他系统登陆访问，就必须安装openssh-server；在终端中输入sudo apt-get install openssh-server，然后输入自己的root密码就可以了； image-20210313142323225 然后启动ssh-server服务即可 image-20210313142538586 验证是否开启成功，出现sshd表示开启成功 image-20210313142626340 然后xshell连接又出现密码框为灰色的问题 image-20210313144601051 然后百度说服务器端设置问题，输入vi /etc/ssh/sshd_config修改sshd配置文件（要用root权限修改）将图中的属性改为yes(打开文件输入s进入编辑模式，按Esc退出编辑模式，在末尾输入：wq保存并退出) image-20210313150134134 然后在重新启动sshd服务 1sudo /etc/init.d/ssh restart 2.远程上传下载文件Xftp5 xftp5是一款基于Windows平台的功能强大的SFTP、FTP文件传输软件。使用了Xftp以后，Windows用户能安全的在UNIX/Linux和WindowsPC之间传输文件。 3.vi 和vim编辑器 vi和vim的三种常用模式 正常模式 在正常模式下我们可以使用快捷键。以vim打开一个档案就直接进入一般模式了（这是默认的模式）。在这个模式中，你可以使用【上下左右】按键来移动光标，你可以使用【删除字符】和【删除整行】来处理档案内容，也可以使用【复制、粘贴】来处理你的文件数据 编辑模式 在模式下，可以输入内容 按下i，s等字母后会进入编辑模式，一般来说按i即可 命令行模式 这个模式，可以使用相关命令，完成读取，存盘，替换，离开vim，显示行号等动作 :q是退出，:wq是保存并退出，:q!是不保存并退出，:wq！是保存并强制退出 vi 和 vim快捷键 的使用案例 拷贝当前行 yy，拷贝当前行向下的n行 nyy，并粘贴(p) 删除当前行 dd 删除当前行向下的n行 ndd 在文档中查找某个单词 【命令行下 /关键字，回车查找，输入n查找下一个 N查找上一个】 设置文件的行号 || 取消文件的行号 【命令行下 :set nu || :set nonu】 快捷到文档末行 G 首行 gg 撤销 u 类似于Ctrl+Z 导航到第N行 shift+g 第一步：显示行号:set nu 第二步：输入n 第三步：输入Shift+g 4.开机、重启、和用户登录注销 关机&amp;重启命令 shutdown shutdown -h now:表示立即关机 shutdown -h 1：表示一分钟后关机 shutdown -r now:立即重启 halt （直接使用，效果等价于关机） reboot(就是重启系统) syn ：把内存的数据同步到磁盘（我们关机或重启时，先执行，把内存写入磁盘，防止数据丢失） 用户登录与注销 登录时尽量少用root账号登录，root是最高权限，避免失误，可以利用普通用户登录，登陆后再用”su -用户名”命令来切换成系统管理员身份 在提示符下输入logout即可注销用户 5.用户管理1.说明 Linux系统就是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先像系统管理员申请一个账号，然后以这个账号的身份进入系统。 Linux的用户需要至少要属于一个组。 2.添加用户 添加用户 useradd –添加用户不用输入密码 注：在Ubuntu下不会创建用户目录，需要用useradd -m adduser –添加用户需要输入密码 在Ubuntu下也会创建用户目录 useradd -d 目录 新用户：–给新建的用户添加目录 注：在Ubuntu下也不会创建文件夹 useradd -g 用户组 用户名 ：–添加用户时指定用户组 passwd 用户名 ：给用户设置密码 3.删除用户 userdel 用户名 只删除用户 userdel -r 用户名 注：会同用户目录一起删除 4.查询用户信息 id 用户名：–查询用户 5.切换用户 su - 用户名：–切换用户 exit ：–返回到上一个用户 注意：从权限高的用户切换到权限低的用户，不需要输入密码，反之需要 6.用户组 –类似于角色，系统可以对又共性的多个用户统一管理 groupadd 组名 ：–添加组 groupdel 组名：–删除组 usermod -g 用户组 用户名：–修改用户的组 7.用户和组的相关文件 /etc/passwd文件 用户的配置文件，记录用户的各种信息 每行的含义：用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录shell /etc/shadow文件 口令的配置文件 每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志 /etc/group文件 组配置文件，记录所有的组信息 每行含义：组名：口令：组标识号：组内用户列表 8.实用指令（Ubuntu系统不一样） 运行级别说明，常用运行级别是3和5，要修改默认的运行级别可改文件/etc/inittab的id：5：initdefault这一行中的数字 image-20210314133707233 init[012356] :–切换到指定运行级别 面试题：找回root密码 image-20210314135422944 image-20210314135503877 9.帮助指令 当我们对某个指令不熟悉时，我们可以使用Linux提供的帮助指令来了解这个指令的使用方法。 man 命令或配置文件 ：– 获得帮助信息 help 命令 ： –获得shell内置命令的帮助信息 10.文件目录类的指令 pwd :–显示当前目录的绝对路径 ls ：–显示目录 ls -l ：–以列表的方式显示信息 ls -al：–显示所有的文件和目录 cd的几种用法 cd 绝对路径 ：–去到当前路径 cd&amp;cd~ ：–回到家目录 cd - 返回上一个工作目录 cd .. 返回上一级目录 mkdir指令用于创建目录 mkdir 要创建的目录（/home/aa） ：–创建一个目录 mkdir -p 要创建的目录（/home/aa/bb）：–创建多级目录 rmdir 不能删除非空目录 rmdir 要删除的目录：–删除一个空目录 rm -rf 要删除的目录 ：–可以删除非空目录 touch 文件名称 ：–创建空文件（可创建多个，用空格隔开） cp指令用法 cp 要拷贝的文件 粘贴的目录 ：–拷贝单个文件夹 cp -r 要拷贝的文件 粘贴的目录 ：–可以拷贝整个文件夹 \\cp 强制覆盖 rm删除指令用法 rm 要删除的文件 ：–删除单个文件 rm -r 要删除的文件：–可以删除整个文件夹 rm -f 要删除的文件：–强制删除不提示 不加-r也只能删文件 mv移动文件指令用法 mv 旧文件名 新文件名 ：–将文件重命名 mv 文件名 要移动的目录 ：–将文件移动到指定的目录下 cat指令用法（以只读的方式打开文件） cat 要查看的文件 : –查看文件 cat -n 要查看的文件：–查看文件并显示行号 cat -n 要查看的文件 |more ：–查看文件并分页 按空格翻页 more指令（以全屏幕的方式按页显示文本文件的内容） image-20210314172646169 less指令（跟more效果一样，比more功能强大，不是一次加载全部内容，而是根据显示需要加载内容，对于显示大文件具有较高的效率） image-20210314173341001 &gt;（输出重定向） 和 &gt;&gt;（追加）指令 ls -l &gt; 文件 ：–将前面的内容写入到后面的文件中（覆盖写） ls -l &gt;&gt; 文件 ：–将前面的内容追加到后面的文件中 cat 文件1 &gt; 文件2 ：–将文件1的内容覆盖到文件2中 echo 内容 &gt;&gt; 文件 将内容追加到文件中 echo 输出内容 ：输出内容到控制台 head指令 head用于显示文件开头部分的内容，默认显示前10行 head 文件 ：–查看头10行内容 head -5 文件 ： –查看前五行内容 tail指令的用法 tail 文件 ：–查看文件后10行 tail -5 文件 ：–查看文件后5行 tail -f 文件 ：–实时监控文件 有更新就会看到 ln指令（相当于Windows的快捷方式） ln -s 原文件或目录 软链接名 ： –给原文件创建一个软链接相当于快捷方式 rm -rf 软链接名 ：–删除软链接 注意 ：我们用软链接去到root目录后，用pwd查看，发现还是在软链接所在的目录image-20210314190654181 history指令用法 （查看历史执行过的指令） history ：–显示所有的历史指令 history 10 ：–显示最近的10个指令 ！n ：–执行编号为n的指令（注：是直接执行，不是查看） 11.时间日期类的指令 date时间指令用法 date ：–显示当前时间 date +%Y ：–显示当前年份 date +%m ：–显示当前月份 date +%d ：–显示当前是哪一天 date “+%Y-%m-%d %H:%M:%S” :–显示年月日时分秒 date -s 字符串时间 ：–设置系统时间 cal日历指令 cal ：–显示本月日历 cal 年份 ：–显示指定年份的日历 12.搜索查找类的指令 find指令用法 find 搜索范围（不加默认在当前文件夹下） -name 文件名 ：–查找指定文件名的文件 find 搜索范围 -user 用户名 ：–查找指定用户名的所有文件 find 搜索范围 -size （+/-/等于不写）文件大小（兆：M KB：k）：– 查找指定文件大小的文件 locate指令用法 介绍：locate数据库实现快速定位给定的文件，查询速度较快 由于locate指令基于数据库进行查询，所有第一次查询前，必须使用updatedb指令创建locate数据库 locate 文件名 ：–快速查找指定的文件 bug记录：当我执行updatedb指令时，弹出下图问题，说未找到命令’updatedb’，但可以与以下命令一起安装：安装第二个个指令就能用了 image-20210315102900499 grep指令和管道符号| 介绍：grep过滤查找，管道符，”|“：表示将前一个命令的处理结果输出传递给后面的命令处理 cat 文件名 | grep -n 查找的内容 :–打开指定文件名的文件由管道符|交给后面的过滤指令过滤出指定内容并显示行号，不加-n不显示，区分大小写 cat 文件名 | grep -ni 查找的内容 :–打开指定文件名的文件由管道符|交给后面的过滤指令过滤出指定内容并显示行号，不加-n不显示，不区分大小写 image-20210315104956167 12.压缩和解压缩指令 gzip/gunzip指令 注：使用gzip压缩文件后，不会保留原来的文件 gzip 文件 ：–压缩文件 gunzip 文件.gz : –解压缩文件 zip/unzip指令 zip -r（不加只能压缩单个文件） xxx.zip 要压缩的内容 ：–压缩文件和目录 unzip -d（不加默认解压到当前目录） 解压的目录 xxx.zip ：–解压缩文件 出现下图提示就是没安装zip安装一下就好了 image-20210315110508195 tar打包指令 打包后的文件是.tar.gz的文件 tar -zcvf xxx.tar.gz 需要打包的文件 ：–打包文件，可以是目录也可以是多个文件 tar -zxvf 需要解压的文件：–解压文件到当前目录 tar -zxvf 需要解压的文件 -C 解压后的目录 ：–解压文件到指定的目录 13.组管理和权限管理（P35）","categories":[],"tags":[]},{"title":"SpringBoot 知识汇总","slug":"Springboot2-md","date":"2021-03-07T10:25:55.000Z","updated":"2021-03-15T04:39:21.799Z","comments":true,"path":"2021/03/07/Springboot2-md/","link":"","permalink":"http://yoursite.com/2021/03/07/Springboot2-md/","excerpt":"","text":"一.容器功能1.底层注解@Configuration详解@Configuration：告诉springboot这是一个配置类 == 配置文件 ， 配置类本身也是组件 @Bean：给容器中添加组件。以方法名作为组件id，返回类型是组件类型，返回的值就是组件在容器中的实列 == proxyBeanMethods：代理bean的方法 实战作用 配置类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断 配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式 123456789101112131415161718192021/** * 1.proxyBeanMethods:代理bean的方法 * Full：(proxyBeanMethods = turn) 全模式 * Lite：(proxyBeanMethods = false) 轻量级模式 * 组件依赖 */@Configuration(proxyBeanMethods = true)public class Myconfig &#123; @Bean public Users users()&#123; Users user = new Users(\"张三\",20); //users组件依赖了pet组件 user.setPet(pet()); return user; &#125; @Bean public Pet pet() &#123; return new Pet(\"旺财\"); &#125;&#125; 12345678910111213141516171819202122232425@Autowired ApplicationContext ioc; //获取ioc容器 @Test void contextLoads() &#123; //查看容器中的组件 String[] names = ioc.getBeanDefinitionNames(); for(String name : names)&#123; System.out.println(name); &#125; //从容器中获取组件 Pet tom01 = ioc.getBean(\"pet\",Pet.class); Pet tom02 = ioc.getBean(\"pet\",Pet.class); System.out.println(\"组件：\"+(tom01 == tom02)); //com.project5.project5.config.Myconfig$$EnhancerBySpringCGLIB$$193ccc23@440eaa07 Myconfig myconfig = ioc.getBean(Myconfig.class); System.out.println(\"myconfig\"+myconfig); //如果@Configuration(proxyBeanMethods = true) 代理对象调用方法。Spring Boot总会检查这个组件是否存在容器中 //保持组件单实例 Users user = myconfig.users(); Users user1 = myconfig.users(); System.out.println(user == user1); Users user01 = ioc.getBean(\"users\",Users.class); Pet tom = ioc.getBean(\"pet\",Pet.class); System.out.println(\"用户的宠物\"+(user01.getPet() == tom)); &#125; 2.@Import注解1@Import(&#123;Users.class, DBHelper.class&#125;) 3.@Conditional@Conditional：条件装配，满足Conditional指定的条件，则进行组件注入 4.@ImportResource@ImportResource(“classpath:beans.xml”)导入spring的配置文件，使其生效 5.配置绑定（1）@Component + @ConfigurationProperties12345@Component //将组件加入到容器中，只有在容器中的组件，才能得到springBoot的强大支持@ConfigurationProperties(prefix = \"mycat\") //将配置文件中前置为mycat的配置加载到组件中public class Cat &#123; private String name; private Integer money; （2）@ConfigurationProperties + @EnableConfigurationProperties12@EnableConfigurationProperties(Cat.class) //开启Cat配置绑定功能，把Cat这个组件自动注册到容器中public class Myconfig &#123; 二.自动配置原理1.引导加载自动配置类(1)SpringBootApplication由下面几个注解组成1234567891011@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;) ​ (1.1).@SpringBootConfiguration ​ @Configuration : 代表当前是一个配置类 （1.2）@ComponentScan ​ 指定扫描哪些，spring注解； （1.3）@EnableAutoConfiguration123@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; ​ (1.3.1) @AutoConfigurationPackage 自动配置包？指定了默认的包规则 1234@Import(&#123;Registrar.class&#125;) //给容器中导入一个组件public @interface AutoConfigurationPackage &#123; //利用Registrar给容器中导入一系列组件 //将指定的一个包下的所有组件导进来？主程序所在的包下 （1.3.2）@Import({AutoConfigurationImportSelector.class}) ​ 1234561.利用this.getAutoConfigurationEntry(annotationMetadata);方法，给容器中批量导入一些组件2.调用List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);获取到所有需要导入到容器中的组件3.利用工厂加载Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader)得到所有组件4.从META-INF/spring.factories位置来加载一个文件。 默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件 spring-boot-autoconfigure-2.4.3RELEASE.jar里面也有META-INF/spring.factories 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134文件里写死了spring-boot一启动就要给容器中加载的所有配置类路径 spring-boot-autoconfigure-2.4.3RELEASE.jar/META-INF/spring.factories# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.neo4j.Neo4jAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\org.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\\org.springframework.boot.autoconfigure.r2dbc.R2dbcTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration image-20210224113220654 2.按需开启自动配置项 虽然我们130个场景的所有自动配置启动的时候默认全部加载。 按照条件装配规则（@Conditional），最终会按需加载。 3.修改默认配置SpringBoot默认会在底层配置好所有的组件。但是如果用户自己配置了以用户的优先。 123@Bean @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() &#123; 总结： SpringBoot先加载所有的自动配置类 xxxxAutoConfiguration 每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。 xxxxProperties里面拿 ，xxxxproperties和配置文件进行了绑定 生效的配置类会给容器中装配很多组件 只要容器中有这些组件，相当于这些功能有了 只要用户有自己配置的，就以用户的优先 定制化配置 用户直接自己@Bean替换底层的组件 用户去看这个组件是获取的配置文件什么值就去修改 xxxxAutoConfiguration —&gt;组件 —&gt;xxxxProperties里面拿值 —&gt;application.properties 4.最佳实践 引入场景依赖 https://docs.spring.io/spring-boot/docs/2.4.3/reference/html/using-spring-boot.html#using-boot-starter 查看自动配置了哪些 自己分析，引入场景对应的自动配置一般都生效了 配置文件中debug=true开启自动配置报告。Negative（不生效）\\Positive（生效） 是否需要修改 参照文档修改配置项 https://docs.spring.io/spring-boot/docs/2.4.3/reference/html/appendix-application-properties.html#common-application-properties 自己分析，xxxxproperties绑定了配置文件的哪些 自定义加入或者替换组件 @Bean、@Component。。。 自定义器 xxxxCustomizer …… 三、开发小技巧1.Lombok​ 简化JavaBean的开发,先导入依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 然后在Idea里下载Lombok插件就可以使用了 12345678@NoArgsConstructor //无参构造器@AllArgsConstructor //全参构造器@ToString //重写tostring方法@Data //get set方法public class Pet &#123; private String name;&#125;//Lombok还提供了@Slf4j日志注解 log.info(\"打印日志\") 2.dev-tools 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; Ctrl+F9 四、配置文件springboot使用一个全局的配置文件，配置文件名是固定的，有两种格式​ 1.application.properties​ 2.application.yml配置文件的作用：修改spring boot自动配置的默认值；spring boot在底层都给我们配置好的； yaml语法1.基本语法K:(空格)V : 表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只有是左对齐的一列数据，都是一个层级的；属性和值也是大小写敏感的； 2.值的写法字面量：普通的值（数字，字符串，布尔）k: v : 字面直接来写； ​ 字符串默认不用加上单引号或者双引号 “”：双引号； 不会转义字符串里面的特殊字符；特殊字符会作为本身想要表达的意思 name：”zhangsan \\n lisi”：输出zhangsan 换行 lisi ‘’:单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 name：”zhangsan \\n lisi”：输出zhangsan \\n lisi 对象、Map（属性和值）（键值对）：k: v ：在下一行来写对象的属性和值的关系；注意缩进；对象还是k:v的方式 123friends: lastName: zhangsan age: 20 ​ 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List,Set)用-值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3.配置文件注入application.yml: 123456789101112person: name: 张三 age: 18 isboy: true birth: 2017/09/09 map: k1: v1 list: - l1 dog: name: 小狗 age: 2 JavaBean： @configurationProperties:将配置文件中的每一个属性值，映射到这个实体类中 prefix=”person” ： 将配置文件中person下面的所以属性进行一一映射 1234567891011@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String name; private Integer age; private Boolean isboy; private Date birth; private Map&lt;String,Object&gt; map; private List&lt;Object&gt; list; private Dog dog; 配置文件处理器，以后编写配置就有提示 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; application.properties中文乱码问题 打开设置 进入 file encoding 更改Properties Files 的编码为UTF-8,并且勾上Transparent native-to-ascii conversation @ConfigurationProperties和@value的区别 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个值定 松散语法 支持 不支持 SpEL 不支持 支持 JSR303数据检验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值 如果说，我们只是在某个业务逻辑中获取配置文件中的某项值，使用@Value 如果我们专门写了一个JavaBean来和配置文件进行映射，我们就直接使用ConfigurationProperties; 3.配置文件数据检验@Validated 4.@PropertySource/ImportResource@PropertySource:加载指定的配置文件； 1@PropertySource(value=&#123;\"classpath:person.properties\"&#125;) @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； 12@ImportResource(locations = \"classpath:beans.xml\")导入spring配置文件使其生效 SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1.配置类======Spring配置文件 2.使用@Bean给容器中添加组件 123456789@Configurationpublic class helloConfig &#123; @Bean public HelloService helloService()&#123; System.out.println(\"添加组件\"); return new HelloService(); &#125;&#125; 5.配置文件占位符1.随机数 12$&#123;random.value&#125;,$&#123;random.int&#125;,$&#123;random.long&#125;$&#123;random.int(10)&#125;,$&#123;random.int[1024,65536]&#125; 2.占位符获取之前配置的值，如果没有是可以用：指定默认值 12345678#person.name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.isboy=falseperson.birth=2020/02/02person.map.k1=v1person.list=l1person.dog.name=$&#123;person.name:李四&#125;小狗person.dog.age=2 6.Profile1.多Profile文件 我们在主配置文件编写的时候，文件名可以是application-{Profile}.properties/yml 默认使用application.properties的配置 2.yml支持多文档块方式 123456789101112131415server: port: 8080spring: profiles: active: dev---server: port: 8081spring: profiles: dev---server: port: 8082spring: profiles: prod #指定属于哪个环境 3.激活指定profile 1spring.profiles.active=prod @profile image-20210306164059618 image-20210306164012999 @Profile也可以标在配置类上，整个类只有在指定的生产环境下才能生效 image-20210306164211980 命令行激活（可以修改配置文件任意值,以命令行优先）： 1java -jar project1-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod --person.name=hello 可以直接在测试的时候，配置传入命令行参数–spring.profiles.active=prod 虚拟机参数： -Dspring.profiles.active=prod 7.配置文件加载位置 spring boot启动时会扫描以下位置的application.properties或者application.yml文件作为spring boot的默认配置文件 -file（项目文件）:/config/ -file:/ -classpath(resource):/config/ -classpath:/ 优先级由高到低，高优先级的会覆盖低优先级的配置； springboot会从这四个位置全部加载成主配置文件；互补配置 我们还可以通过spring.config.location来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认的这些配置文件共同起作用形成互补配置；（springboot2.4.3实测没有互补） 8.外部配置加载顺序springboot也可以从以下位置加载配置；优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置 1.命令行参数 java -jar project4-0.0.1-SNAPSHOT.jar –server.port=8086 –server.servlet.context-path=/abc 多个配置用空格分开 –配置项=值 2.来自java：comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 由jar包外向jar包内进行寻找； 优先加载带profile的 6.jar包外部的application-{profiles}.properties或application.yml（带spring.profile）配置文件 7.jar包内部的application-{profiles}.properties或application.yml（带spring.profile）配置文件 8.jar包外部的application.properties或application.yml（不带spring.profile）配置文件 9.jar包内部的application.properties或application.yml（不带spring.profile）配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； [参考官方文档]( 五、web开发（源码以后再看）1、SpringMVC自动配置概览Spring Boot provides auto-configuration for Spring MVC that works well with most applications.(大多场景我们都无需自定义配置) The auto-configuration adds the following features on top of Spring’s defaults: Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 内容协商视图解析器和BeanName视图解析器 Support for serving static resources, including support for WebJars (covered later in this document)). 静态资源（包括webjars） Automatic registration of Converter, GenericConverter, and Formatter beans. 自动注册 Converter，GenericConverter，Formatter Support for HttpMessageConverters (covered later in this document). 支持 HttpMessageConverters （后来我们配合内容协商理解原理） Automatic registration of MessageCodesResolver (covered later in this document). 自动注册 MessageCodesResolver （国际化用） Static index.html support. 静态index.html 页支持 Custom Favicon support (covered later in this document). 自定义 Favicon Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). 自动使用 ConfigurableWebBindingInitializer ，（DataBinder负责将请求数据绑定到JavaBean上） If you want to keep those Spring Boot MVC customizations and make more MVC customizations (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. 不用@EnableWebMvc注解。使用 @Configuration + WebMvcConfigurer 自定义规则 If you want to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, and still keep the Spring Boot MVC customizations, you can declare a bean of type WebMvcRegistrations and use it to provide custom instances of those components. 声明 WebMvcRegistrations 改变默认底层组件 If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc, or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration as described in the Javadoc of @EnableWebMvc. 使用 @EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管SpringMVC 2.简单功能分析2.1静态资源访问静态资源目录只要将静态资源放在类路径下： called /static (or /public or /resources or /META-INF/resources 访问：当前项目根路径/+静态资源名 原理：静态映射/**。 请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面。 静态资源访问前缀默认无前缀 123spring: mvc: static-path-pattern: /res/** webjar自动映射 /webjars/** https://www.webjars.org/ 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 访问地址：http://localhost:8080/webjars/jquery/3.5.1/jquery.js 后面地址要按照依赖里面的包路径 2.2、欢迎页支持2.3、自定义 Favicon2.4、静态资源配置原理25集 3、请求参数处理1、rest使用与原理 @xxxMapping； Rest风格支持（使用*HTTP*请求方式动词来表示对资源的操作） 以前：**/getUser 获取用户 /deleteUser 删除用户 /editUser 修改用户 /saveUser 保存用户 现在： /user GET-**获取用户 DELETE-**删除用户 PUT-**修改用户 POST-**保存用户 核心Filter；HiddenHttpMethodFilter 用法： 表单method=post，隐藏域 _method=put 123456789101112131415161718192021222324252627282930313233&lt;h1&gt;测试rest风格&lt;/h1&gt;&gt;&lt;form action=\"/user\" method=\"get\" &gt; &lt;input type=\"submit\" value=\"GET\"&gt;&lt;/form&gt;&lt;form action=\"/user\" method=\"post\" &gt; &lt;input type=\"submit\" value=\"POST\"&gt;&lt;/form&gt;&lt;form action=\"/user\" method=\"post\" &gt; &lt;input name=\"_method\" type=\"hidden\" value=\"PUT\"&gt; &lt;input type=\"submit\" value=\"PUT\"&gt;&lt;/form&gt;&lt;form action=\"/user\" method=\"post\" &gt; &lt;input name=\"_method\" type=\"hidden\" value=\"DELETE\"&gt; &lt;input type=\"submit\" value=\"DELETE\"&gt;&lt;/form&gt; //controller: @RequestMapping(value = \"/user\",method = RequestMethod.GET) public Object get()&#123; return \"GET\"; &#125; @RequestMapping(value = \"/user\",method = RequestMethod.POST) public Object post()&#123; return \"POST\"; &#125; @RequestMapping(value = \"/user\",method = RequestMethod.PUT) public Object put()&#123; return \"PUT\"; &#125; @RequestMapping(value = \"/user\",method = RequestMethod.DELETE) public Object delete()&#123; return \"DELETE\"; &#125; - SpringBoot中手动开启 - ```yaml spring: mvc: hiddenmethod: filter: enabled: true 123456789101112131415161718192021222324252627282930313233343536373839 - - 扩展：如何把_method 这个名字换成我们自己喜欢的。REST原理：26集### 2.请求映射原理28集## 2、普通参数与基本注解### 1.1、注解：@PathVariable(路径变量)、@RequestHeader(获取请求头)、@ModelAttribute()、@RequestParam(获取请求参数)、@MatrixVariable(矩阵变量)31集，@CookieValue(获取cookie值)、@RequestBody(获取请求体[post])、@RequestAttribute(获取request域属性)### 1.2、Servlet API：WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId### 1.3、复杂参数：**Map**、**Model（map、model里面的数据会被放在request的请求域 request.setAttribute）、**Errors/BindingResult、**RedirectAttributes（ 重定向携带数据）**、**ServletResponse（response）**、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder### 3.thymeleaf### 4.拦截器```javapublic class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; HttpSession session = request.getSession(); if(session.getAttribute(\"user\") != null)&#123; return true; &#125; return false; &#125;123456@Configurationpublic class LoginConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/login.html\",\"/loginUser\"); &#125; 5.文件上传6.异常处理7.Web原生组件注入（servlet，Filter，Listener）六、数据访问1.整合druid数据源1.1自定义方式1.2使用官方starter方式2.整合Mybatis2.1、配置模式 导入mybatis-starter 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt; &lt;/dependency&gt; 创建全局配置文件和mapper映射文件 image-20210302171737923 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;/configuration&gt;#全局配置文件 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"org.mybatis.example.BlogMapper\"&gt; &lt;select id=\"selectBlog\" resultType=\"Blog\"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;#mapper映射文件 在yaml配置文件中配置mybatis规则 123mybatis: config-location: classpath:mybatis/mybatis-config.xml #mybatis全局配置文件位置 mapper-locations: classpath:mybatis/mapper/*.xml #mapper配置文件位置 编写mapper接口和service业务类 3、整合Mybatis-Plus 引入Mybatis-Plus依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;Latest Version&lt;/version&gt; &lt;/dependency&gt; 配置数据库相关的配置 123456#datasource的父级是springdatasource: url: jdbc:mysql://localhost:3306/book username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver 在 Spring Boot 启动类中添加 @MapperScan 注解，扫描 Mapper 文件夹： 1@MapperScan(\"com.project.project6.mapper\") 编写实体类，mapper接口，以及业务逻辑层 实体类 12345678910111213@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; @TableField(exist = false) //代表表中不存在的字段 private String username; @TableField(exist = false) private String password; private Long id; private String name; private Integer age; private String email;&#125; mapper接口 12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; //继承Mybatis-Plus提供的BaseMapper接口。 业务逻辑层 service12public interface UserService extends IService&lt;User&gt; &#123;&#125; //继承Mybatis-Plus提供的IService接口。 serviceImpl123@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService &#123;&#125; //继承Mybatis-Plus提供的ServiceImpl接口。 分页使用 导入分页插件 1234567891011121314@Configurationpublic class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125; @Bean public ConfigurationCustomizer configurationCustomizer() &#123; return configuration -&gt; configuration.setUseDeprecatedExecutor(false); &#125;&#125; 测试 12345@GetMapping(\"/user\") public Object getUser(@RequestParam(value = \"pn\",defaultValue = \"1\")Integer pn)&#123; Page&lt;User&gt; page = new Page&lt;User&gt;(pn,2); return userService.page(page); &#125; 4.整合Redis 导入依赖并编写配置文件 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; //redis依赖 &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; //jedis依赖 12345redis: host: 127.0.0.1 //redis地址 password: 123456 //密码 port: 6379 //端口号 client-type: jedis //工厂类型 注入StringRedisTemplate组件来操作redis 1234@Autowired StringRedisTemplate stringRedisTemplate;@Autowired RedisConnectionFactory redisConnectionFactory; //查看当前连接工厂 调用opsForValue方法来进行操作 1234567@Test void contextLoads() &#123; ValueOperations&lt;String, String&gt; operations = stringRedisTemplate.opsForValue(); operations.set(\"hello\",\"world\"); operations.get(\"hello\"); System.out.println(redisConnectionFactory.getClass()); //使用jedis连接工厂 &#125; 2.使用redis实现统计功能 编写一个拦截器，请求一次就统计一次 123456789101112@Componentpublic class RedisConfig implements HandlerInterceptor &#123; @Autowired StringRedisTemplate stringRedisTemplate; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String uri = request.getRequestURI(); ValueOperations&lt;String, String&gt; operations = stringRedisTemplate.opsForValue(); operations.increment(uri); //默认每次访问uri就会+1 return true; &#125;&#125; 1234567891011@Configurationpublic class LoginConfig implements WebMvcConfigurer &#123; @Autowired RedisConfig redisConfig; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()) .addPathPatterns(\"/**\").excludePathPatterns(\"/login.html\",\"/loginUser\"); registry.addInterceptor(redisConfig).addPathPatterns(\"/**\").excludePathPatterns(\"/login.html\",\"/loginUser\"); &#125;&#125; controller测试 1234567891011@Autowired StringRedisTemplate stringRedisTemplate; @GetMapping(\"main.html\") public String totle(Model model)&#123; ValueOperations&lt;String, String&gt; operations = stringRedisTemplate.opsForValue(); String cat = operations.get(\"/cat\"); String city = operations.get(\"/city\"); model.addAttribute(\"cat\",cat); model.addAttribute(\"city\",city); return \"index.html\"; &#125; 七、单元测试1、JUnit5 的变化Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库 作为最新版本的JUnit框架，JUnit5与之前版本的Junit框架有很大的不同。由三个不同子项目的几个不同模块组成。 JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage JUnit Platform: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。 JUnit Jupiter: JUnit Jupiter提供了JUnit5的新的编程模型，是JUnit5新特性的核心。内部 包含了一个测试引擎，用于在Junit Platform上运行。 JUnit Vintage: 由于JUint已经发展多年，为了照顾老的项目，JUnit Vintage提供了兼容JUnit4.x,Junit3.x的测试引擎。 image 注意： SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖。如果需要兼容junit4需要自行引入（不能使用junit4的功能 @Test） JUnit 5’s Vintage Engine Removed from spring-boot-starter-test,如果需要继续兼容junit4需要自行引入vintage 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; **** image.png 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 现在版本： 123456789@SpringBootTestclass Boot05WebAdminApplicationTests &#123; @Test void contextLoads() &#123; &#125;&#125; 以前： @SpringBootTest + @RunWith(SpringTest.class) SpringBoot整合Junit以后。 编写测试方法：@Test标注（注意需要使用junit5版本的注解） Junit类具有Spring的功能，@Autowired、比如 @Transactional 标注测试方法，测试完成后自动回滚 2、JUnit5常用注解 JUnit5的注解与JUnit4的注解有所变化 https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations @Test :表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试 @ParameterizedTest :表示方法是参数化测试，下方会有详细介绍 @RepeatedTest :表示方法可重复执行，下方会有详细介绍 @DisplayName :为测试类或者测试方法设置展示名称 @BeforeEach :表示在每个单元测试之前执行 @AfterEach :表示在每个单元测试之后执行 @BeforeAll :表示在所有单元测试之前执行 @AfterAll :表示在所有单元测试之后执行 @Tag :表示单元测试类别，类似于JUnit4中的@Categories @Disabled :表示测试类或测试方法不执行，类似于JUnit4中的@Ignore @Timeout :表示测试方法运行如果超过了指定时间将会返回错误 @ExtendWith :为测试类或测试方法提供扩展类引用 12345678910import org.junit.jupiter.api.Test; //注意这里使用的是jupiter的Test注解！！public class TestDemo &#123; @Test @DisplayName(\"第一次测试\") public void firstTest() &#123; System.out.println(\"hello world\"); &#125; 3、断言（assertions） 断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法。JUnit 5 内置的断言可以分成如下几个类别： 检查业务逻辑返回的数据是否合理。 所有的测试运行结束以后，会有一个详细的测试报告； 1、简单断言 用来对单个值进行简单的验证。如： 方法 说明 assertEquals 判断两个对象或两个原始类型是否相等 assertNotEquals 判断两个对象或两个原始类型是否不相等 assertSame 判断两个对象引用是否指向同一个对象 assertNotSame 判断两个对象引用是否指向不同的对象 assertTrue 判断给定的布尔值是否为 true assertFalse 判断给定的布尔值是否为 false assertNull 判断给定的对象引用是否为 null assertNotNull 判断给定的对象引用是否不为 null 12345678910111213141516@Test@DisplayName(\"simple assertion\")public void simple() &#123; assertEquals(3, 1 + 2, \"simple math\"); assertNotEquals(3, 1 + 1); assertNotSame(new Object(), new Object()); Object obj = new Object(); assertSame(obj, obj); assertFalse(1 &gt; 2); assertTrue(1 &lt; 2); assertNull(null); assertNotNull(new Object());&#125; 2、数组断言 通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等 12345@Test@DisplayName(\"array assertion\")public void array() &#123; assertArrayEquals(new int[]&#123;1, 2&#125;, new int[] &#123;1, 2&#125;);&#125; 3、组合断言 assertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言 12345678@Test@DisplayName(\"assert all\")public void all() &#123; assertAll(\"Math\", () -&gt; assertEquals(2, 1 + 1), () -&gt; assertTrue(1 &gt; 0) );&#125; 4、异常断言 在JUnit4时期，想要测试方法的异常情况时，需要用@Rule注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式Assertions.assertThrows() ,配合函数式编程就可以进行使用。 12345678@Test@DisplayName(\"异常测试\")public void exceptionTest() &#123; ArithmeticException exception = Assertions.assertThrows( //扔出断言异常 ArithmeticException.class, () -&gt; System.out.println(1 % 0));&#125; 5、超时断言 Junit5还提供了Assertions.assertTimeout() 为测试方法设置了超时时间 123456@Test@DisplayName(\"超时测试\")public void timeoutTest() &#123; //如果测试方法时间超过1s将会异常 Assertions.assertTimeout(Duration.ofMillis(1000), () -&gt; Thread.sleep(500));&#125; 6、快速失败 通过 fail 方法直接使得测试失败 12345@Test@DisplayName(\"fail\")public void shouldFail() &#123; fail(\"This should fail\");&#125; 4、前置条件（assumptions）JUnit 5 中的前置条件（assumptions【假设】）类似于断言，不同之处在于不满足的断言会使得测试方法失败，而不满足的前置条件只会使得测试方法的执行终止。前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。 1234567891011121314151617181920@DisplayName(\"前置条件\")public class AssumptionsTest &#123; private final String environment = \"DEV\"; @Test @DisplayName(\"simple\") public void simpleAssume() &#123; assumeTrue(Objects.equals(this.environment, \"DEV\")); assumeFalse(() -&gt; Objects.equals(this.environment, \"PROD\")); &#125; @Test @DisplayName(\"assume then do\") public void assumeThenDo() &#123; assumingThat( Objects.equals(this.environment, \"DEV\"), () -&gt; System.out.println(\"In DEV\") ); &#125;&#125; assumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。 5、嵌套测试JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@DisplayName(\"A stack\")class TestingAStackDemo &#123; Stack&lt;Object&gt; stack; @Test @DisplayName(\"is instantiated with new Stack()\") void isInstantiatedWithNew() &#123; new Stack&lt;&gt;(); &#125; @Nested @DisplayName(\"when new\") class WhenNew &#123; @BeforeEach void createNewStack() &#123; stack = new Stack&lt;&gt;(); &#125; @Test @DisplayName(\"is empty\") void isEmpty() &#123; assertTrue(stack.isEmpty()); &#125; @Test @DisplayName(\"throws EmptyStackException when popped\") void throwsExceptionWhenPopped() &#123; assertThrows(EmptyStackException.class, stack::pop); &#125; @Test @DisplayName(\"throws EmptyStackException when peeked\") void throwsExceptionWhenPeeked() &#123; assertThrows(EmptyStackException.class, stack::peek); &#125; @Nested @DisplayName(\"after pushing an element\") class AfterPushing &#123; String anElement = \"an element\"; @BeforeEach void pushAnElement() &#123; stack.push(anElement); &#125; @Test @DisplayName(\"it is no longer empty\") void isNotEmpty() &#123; assertFalse(stack.isEmpty()); &#125; @Test @DisplayName(\"returns the element when popped and is empty\") void returnElementWhenPopped() &#123; assertEquals(anElement, stack.pop()); assertTrue(stack.isEmpty()); &#125; @Test @DisplayName(\"returns the element when peeked but remains not empty\") void returnElementWhenPeeked() &#123; assertEquals(anElement, stack.peek()); assertFalse(stack.isEmpty()); &#125; &#125; &#125;&#125; 6、参数化测试参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。 利用@ValueSource等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。 **** @ValueSource: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型 @NullSource: 表示为参数化测试提供一个null的入参 @EnumSource: 表示为参数化测试提供一个枚举入参 @CsvFileSource：表示读取指定CSV文件内容作为参数化测试入参 @MethodSource：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流) 当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现ArgumentsProvider接口，任何外部文件都可以作为它的入参。 1234567891011121314151617181920@ParameterizedTest@ValueSource(strings = &#123;\"one\", \"two\", \"three\"&#125;)@DisplayName(\"参数化测试1\")public void parameterizedTest1(String string) &#123; System.out.println(string); Assertions.assertTrue(StringUtils.isNotBlank(string));&#125;@ParameterizedTest@MethodSource(\"method\") //指定方法名@DisplayName(\"方法来源参数\")public void testWithExplicitLocalMethodSource(String name) &#123; System.out.println(name); Assertions.assertNotNull(name);&#125;static Stream&lt;String&gt; method() &#123; return Stream.of(\"apple\", \"banana\");&#125; 7、迁移指南在进行迁移的时候需要注意如下的变化： 注解在 org.junit.jupiter.api 包中，断言在 org.junit.jupiter.api.Assertions 类中，前置条件在 org.junit.jupiter.api.Assumptions 类中。 把@Before 和@After 替换成@BeforeEach 和@AfterEach。 把@BeforeClass 和@AfterClass 替换成@BeforeAll 和@AfterAll。 把@Ignore 替换成@Disabled。 把@Category 替换成@Tag。 把@RunWith、@Rule 和@ClassRule 替换成@ExtendWith。 八、指标监控1、SpringBoot Actuator1、简介未来每一个微服务在云上部署以后，我们都需要对其进行监控、追踪、审计、控制等。SpringBoot就抽取了Actuator场景，使得我们每个微服务快速引用即可获得生产级别的应用监控、审计等功能。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; image.png 2、1.x与2.x的不同image.png 3、如何使用 引入场景 访问 http://localhost:8080/actuator/** 暴露所有监控信息为HTTP 123456management: endpoints: enabled-by-default: true #暴露所有端点信息 web: exposure: include: '*' #以web方式暴露 测试 http://localhost:8080/actuator/beans http://localhost:8080/actuator/configprops http://localhost:8080/actuator/metrics http://localhost:8080/actuator/metrics/jvm.gc.pause http://localhost:8080/actuator/endpointName/detailPath。。。。。。 4、可视化https://github.com/codecentric/spring-boot-admin 编写一个服务器项目，专门用来监控客户端 然后导入依赖 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;/dependency&gt; #可视化工具依赖，需搭配web依赖使用 在主程序上编写@EnableAdminServer 123456789@EnableAdminServer@SpringBootApplicationpublic class ProjectadminserviceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProjectadminserviceApplication.class, args); &#125;&#125; 端口号不能与客户端一致 在客户端引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;/dependency&gt; 在编写配置文件和服务器项目对应 123456789spring boot: admin: client: url: http://localhost:8081 #对应服务器端项目的端口 instance: prefer-ip: true #使用IP注册进来，不然注册进去的会是电脑名字 application: name: project6 #表明当前项目名 实例化页面 image-20210306161026928 一个六边形代表一个项目，12m表示运行了12分钟 image-20210306161052856 2、Actuator Endpoint1、最常使用的端点 ID 描述 auditevents 暴露当前应用程序的审核事件信息。需要一个AuditEventRepository组件。 beans 显示应用程序中所有Spring Bean的完整列表。 caches 暴露可用的缓存。 conditions 显示自动配置的所有条件信息，包括匹配或不匹配的原因。 configprops 显示所有@ConfigurationProperties。 env 暴露Spring的属性ConfigurableEnvironment flyway 显示已应用的所有Flyway数据库迁移。 需要一个或多个Flyway组件。 health 显示应用程序运行状况信息。 httptrace 显示HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应）。需要一个HttpTraceRepository组件。 info 显示应用程序信息。 integrationgraph 显示Spring integrationgraph 。需要依赖spring-integration-core。 loggers 显示和修改应用程序中日志的配置。 liquibase 显示已应用的所有Liquibase数据库迁移。需要一个或多个Liquibase组件。 metrics 显示当前应用程序的“指标”信息。 mappings 显示所有@RequestMapping路径列表。 scheduledtasks 显示应用程序中的计划任务。 sessions 允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。 shutdown 使应用程序正常关闭。默认禁用。 startup 显示由ApplicationStartup收集的启动步骤数据。需要使用SpringApplication进行配置BufferingApplicationStartup。 threaddump 执行线程转储。 如果您的应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点： ID 描述 heapdump 返回hprof堆转储文件。 jolokia 通过HTTP暴露JMX bean（需要引入Jolokia，不适用于WebFlux）。需要引入依赖jolokia-core。 logfile 返回日志文件的内容（如果已设置logging.file.name或logging.file.path属性）。支持使用HTTPRange标头来检索部分日志文件的内容。 prometheus 以Prometheus服务器可以抓取的格式公开指标。需要依赖micrometer-registry-prometheus。 最常用的Endpoint Health：监控状况 Metrics：运行时指标 Loggers：日志记录 2、Health Endpoint健康检查端点，我们一般用于在云平台，平台会定时的检查应用的健康状况，我们就需要Health Endpoint可以为平台返回当前应用的一系列组件健康状况的集合。 重要的几点： health endpoint返回的结果，应该是一系列健康检查后的一个汇总报告 很多的健康检查默认已经自动配置好了，比如：数据库、redis等 可以很容易的添加自定义的健康检查机制 123endpoint: health: show-details: always //开启详细的健康检查报告 image.png 3、Metrics Endpoint提供详细的、层级的、空间指标信息，这些信息可以被pull（主动推送）或者push（被动获取）方式得到； 通过Metrics对接多种监控系统 简化核心Metrics开发 添加自定义Metrics或者扩展已有Metrics image.png 4、管理Endpoints1、开启与禁用Endpoints 默认所有的Endpoint除过shutdown都是开启的。 需要开启或者禁用某个Endpoint。配置模式为 management.endpoint.****.enabled = true 1234management: endpoint: beans: enabled: true 或者禁用所有的Endpoint然后手动开启指定的Endpoint 12345678management: endpoints: enabled-by-default: false endpoint: beans: enabled: true health: enabled: true 2、暴露Endpoints支持的暴露方式 HTTP：默认只暴露health和info Endpoint JMX：默认暴露所有Endpoint 除过health和info，剩下的Endpoint都应该进行保护访问。如果引入SpringSecurity，则会默认配置安全访问规则 ID JMX Web auditevents Yes No beans Yes No caches Yes No conditions Yes No configprops Yes No env Yes No flyway Yes No health Yes Yes heapdump N/A No httptrace Yes No info Yes Yes integrationgraph Yes No jolokia N/A No logfile N/A No loggers Yes No liquibase Yes No metrics Yes No mappings Yes No prometheus N/A No scheduledtasks Yes No sessions Yes No shutdown Yes No startup Yes No threaddump Yes No 3.定制化Endpoints1.定制health信息1234567891011121314151617181920212223@Componentpublic class MyHealthIndicator extends AbstractHealthIndicator &#123; @Autowired StringRedisTemplate stringRedisTemplate; /** * 真实的检查方法 * @param builder * @throws Exception */ @Override protected void doHealthCheck(Health.Builder builder) throws Exception &#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); if(stringRedisTemplate!=null)&#123; builder.status(Status.UP); //健康 map.put(\"msg\",\"redis导入成功\"); &#125;else &#123; builder.status(Status.DOWN); //不健康 map.put(\"error\",\"redis导入失败\"); &#125; builder.withDetail(\"code\",\"100\"); builder.withDetails(map); &#125;&#125; image-20210305163341673 2.定制info yaml配置文件方式 12345info: appName: Project6 hello: world mavenProjectName: @project.artifactId@ #使用@@可以获取maven的pom文件值 mavenVersoin: @project.version@ image-20210305164109087 配置类方式 12345678@Componentpublic class AppInfoInfoContributor implements InfoContributor &#123; @Override public void contribute(Info.Builder builder) &#123; builder.withDetail(\"redis实例\",\"redis实例化成功\") .withDetail(\"Redis工厂类型\",\"jedis\"); &#125;&#125; image-20210305165010088 3.定制Metrics信息123456789101112131415161718@Servicepublic class CityServiceImpl implements CityService &#123; @Autowired CityMapper cityMapper; Counter counter; public CityServiceImpl(MeterRegistry meterRegistry)&#123; counter = meterRegistry.counter(\"CityServiceImpl.getCity.count\"); &#125; @Override public City getCity() &#123; counter.increment(); return cityMapper.getCity(); &#125;&#125; image-20210305172444444 image-20210305172528503 4.定制Endpoint123456789101112131415@Component@Endpoint(id = \"myService\")public class MyServiceEndPoint &#123; @Autowired CityService cityService; @ReadOperation public Object getCity()&#123; return cityService.getCity(); &#125; @WriteOperation public void stopCity()&#123; System.out.println(\"停止访问\"); &#125;&#125; image-20210305174312947 九、自定义Starter 创建一个空工程 image-20210307151543012 在工厂中创建两个模块 上面是maven模块来编写场景启动器，给别人引用 /下面是springboot模块负责编写自动配置相关的东西。 image-20210307151637497 在场景启动器中引入自动配置的依赖 12345678910&lt;groupId&gt;com.project&lt;/groupId&gt; &lt;artifactId&gt;project-hello-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.project&lt;/groupId&gt; &lt;artifactId&gt;project-hello-spring-boot-starter-autoconfigure&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 删除自动配置里面没用的东西 pom.xml文件里面只留下spring-boot-starter即可 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 删掉项目里没有的类和配置文件（蓝色背景的都删除） image-20210307152926353 编写一个自动配置方法 service包下的PostService类 12345678910111213/** * 默认不放在容器中 */public class PostService &#123; @Autowired PostProperties postProperties; public String introDuce()&#123; return postProperties.getName()+\"是一个\"+postProperties.getPosition(); &#125;&#125; bean包下的PostProperties类 12345@ConfigurationProperties(\"project.post\")public class PostProperties &#123; private String name; private String position;//省略get，set方法 auto包下的PostServiceAutoConfiguration类 123456789101112@Configuration@ConditionalOnMissingBean(PostService.class) //条件装配，你没有这个组件就自动注入@EnableConfigurationProperties(PostProperties.class) //默认将PostProperties放在容器中public class PostServiceAutoConfiguration &#123; @Bean public PostService postService()&#123; PostService postService = new PostService(); return postService; &#125;&#125; 编写META-INF/spring.factories中EnableAutoConfiguration 的值，使得项目启动加载指定的自动配置类** image-20210307165820513 123# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\com.project.auto.PostServiceAutoConfiguration 将模块安装到maven目录中先安装自动装配模块 image-20210307165949877 在新项目中引入自定义的Starter 12345&lt;dependency&gt; &lt;groupId&gt;com.project&lt;/groupId&gt; &lt;artifactId&gt;project-hello-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 引入成功就可以使用了 1234project: post: name: 张三 position: 经理 1234567@Autowired PostService postService;@GetMapping(\"/introDuce\") public String getIntroDuce()&#123; String s = postService.introDuce(); return s; &#125; 效果 image-20210307170517495 十、SpringBoot原理（以后再看）","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2020-07-05T07:53:55.000Z","updated":"2020-07-05T07:57:02.832Z","comments":true,"path":"2020/07/05/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2020/07/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"第一章内容 第二章内容 参考文献www.baidu.com","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-07-05T07:46:57.970Z","updated":"2020-07-05T07:46:57.970Z","comments":true,"path":"2020/07/05/hello-world/","link":"","permalink":"http://yoursite.com/2020/07/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}