{"meta":{"title":"周瑜的小家园","subtitle":"","description":"","author":"周瑜","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":":java面试.md","slug":"java面试-md","date":"2021-04-06T10:59:06.000Z","updated":"2021-04-06T10:59:39.135Z","comments":true,"path":"2021/04/06/java面试-md/","link":"","permalink":"http://yoursite.com/2021/04/06/java%E9%9D%A2%E8%AF%95-md/","excerpt":"","text":"1Java基础.Java语言的特点：简单易学 面向对象 可以跨平台 可靠性 安全性 支持多线程 支持网络编程并且很方便 编译与解释并存 JVMJava虚拟机是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果 Java程序从源代码到运行一般有以下三步JDK先将.java的源文件编译成JVM虚拟机可识别的.class字节码文件，然后我们的JVM在将.class字节码文件转成我们的计算机可识别的二进制文件 JDK和JREJDK是功能齐全的Java SDK 它拥有JRE所拥有的一切，它能够创建和编译程序 JRE是Java运行时的环境，他是运行已编译Java程序所需的所有内容的集合，但是他不能用于创建新程序 Java和C++的区别 都是面向对象的语言，都支持封装继承和多态 Java不提供指针来直接访问内存，程序内存更加安全 Java的类是单继承的，C++支持多重继承，虽然Java的类不可以多继承，但是接口可以多继承 Java有自动内存管理垃圾回收机制，不需要程序员手动释放无用内存 在C语言中，字符串或字符数组最后都会有一个额外的字符‘\\0’来表示结束，但是Java语言中没有结束符这个概念 泛型用来定义规范 ==和equals的区别 ==它的作用是判断两个对象的地址是否相等，就算判断两个对象是不是同一个对象 对基本数据类型比较的是值 对引用类型比较的是内存地址 equals 他的作用也是判断两个对象是否相等，他不能用于比较基本类型的变量数据 重载和重写 重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理 重写就算子类对父类方法的重写改造，外部样子都不能改变，但是内部的逻辑可以随意编写 方法的四种类型 无参数无返回值的方法 有参数无返回值的方法 有返回值无参数的方法 有返回值有参数的方法 面向过程和面向对象的区别 面向过程性能比面向对象高 面向对象易维护，易复用，易扩展 构造器不能被重写 但是可以被重载构造方法有哪些特性 名字与类命相同 没有返回值，但不能用void声明构造函数 生成类的对象时自动执行，无需调用 String StringBuffer StringBuilder String 是final修饰的，不可变，每次操作都会产生新的String对象 StringBuffer 和 StringBulider读都是在原对象上操作的 String Buffer方法都是用synchronized修饰的，stringBuffer是线程安全的，StringBulilder是线程不安全的 性能 ：StringBulider&gt;StringBuffer&gt;string 经常需要改变字符串内容用StringBuffer和StringBulider，优先使用StringBulider，多线程使用共享变量是用StringBuffer 重载和重写的区别 重载是发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，方法返回值和访问修饰符可以不同，发生在编译时 重写是发生在父子类中，方法名，参数列表必须相同，方法里面的业务逻辑可以不同，返回值范围小于等于父类，抛出异常范围小于等于父类，访问修饰符范围大于等于父类，如果父类方法访问修饰符为private则子类不能重写该方法 接口和抽象类的区别： 抽象类中可以写普通的方法，而接口中只能写抽象方法 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型 抽象类只能继承一个 但是接口可以实现多个 list和set的区别： list是有序的，按对象进入的顺序保存对象，可重复，允许有多个null元素对象，可以使用迭代器取出所有元素，在逐一遍历，还可以使用get获取指定下标的元素 set是无序的，不可重复，最多允许有一个null元素对象，取元素时只能用迭代器接口获取所有元素，在逐一遍历 ArrayList和Linked List的区别ArrayList基于动态数组，他的内存存储是连续的，适合下标访问，因为数组长度固定，超出长度时需要新建数组然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动，使用尾插法并指定初始容量可极大提升性能，甚至超过linkedList。 LinkedList基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询：需要逐一遍历，遍历LinkedList必须使用迭代器不能使用for循环，因为每次for循环体内通过get(i)取得某一元素时都要对Linkedlist重新遍历，性能消耗极大， HashMap和HashTable的区别HashMap方法没有synchronized修饰，是线程非安全的，HashTable是线程安全的； HashMap允许key和value为null，而HashTable不允许 如何实现一个IOC容器 配置文件中指定需要扫描的路径 从配置文件中获取需要扫描的包路径，然后将当前路径下所有以.class结尾的文件添加到一个set集合中进行存储 遍历这个集合，获取在类上有指定注解的类，并将其交给IOC容器，定义一个安全的Map用来存储这些对象 遍历这个IOC容器获取到每一个类的实例，判断里面是否有依赖其他类的实例，然后将依赖递归注入 采用字节码的好处Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题,同时又保留了解释型语言可移植的特点，所有Java程序在运行时比较高效，而且由于字节码并不专一对一种特定的机器，因此Java程序无须重新编译便可在多种不同的计算机上运行 Java中的异常体系Java所有的异常都来自父类Throwable Throwable下有两个子类Exception和error error市程序无法处理的错误，一旦出现这个错误，则程序将被迫停止运行 exception不会导致程序停止，又分为两个部分RunTimeException运行时异常和CheckedException检查异常 线程的生命周期，线程有哪些状态线程的生命周期和状态分为五种状态：创建、就绪、运行、阻塞和死亡状态 新建状态：新创建了一个对象 就绪状态：线程对象创建后，其他线程就调用该对象的start方法，该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权 运行状态：就绪状态的线程获取了CPU，执行程序代码 阻塞状态：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行，直到线程进入就绪状态，才有机会转到运行状态 死亡状态：线程执行完了或者异常退出了run方法，该线程结束生命周期 并发的三大特性 原子性 可见性 有序性 为什么用线程池 降低资源消耗，提高线程利用率，降低创建和销毁线程的消耗 提高响应速度，任务来了，直接有线程可用可执行，而不是先创建线程在执行 提高线程的可管理性，线程是稀缺资源，使用线程池也可以统一分配调优监控 2.spring框架spring是什么spring是一个轻量级的开源的J2EE框架，他是一个容器框架，中间层框架，可以起到一个连接的作用，比如它可以把spring MVC 和Mybatis整合在一起使用，可以让我们的企业开发更快、更简洁，它的特性有ioc和aop，ioc可以达到解耦合的目的 谈谈你对AOP的理解就算在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。 ioc的理解ioc即控制反转，他不是技术而是一种设计思想，就是将你设计好的对象交给ioc容器控制，然后由ioc帮我们查找和注入依赖对象，对象只要被动的接受依赖就行了 bean的自动装配 byName-根据bean的属性名称进行自动装配 byType-根据bean类型进行自动装配 @Autowired注解自动装配 SpringBoot、SpringMVC、Spring的区别spring是一个IOC容器，用来管理bean，使用依赖注入实现控制反转，可以很方便的整合各种框架 springmvc是spring对web框架的一个解决方案，提供了一个总的前端控制器servlet用来接受请求，然后将handle结果使用视图解析技术生成视图展现给前端 springboot是spring提供的一个快速开发工具包，让程序员能更方便、更快速的开发spring+springmvc应用，简化了配置，整合了一系列的解决方案，很多框架都可以开箱即用 SpringMVC的工作流程 用户发送请求到前端控制器dispatcherServlet dispatcherServlet收到请求调用HandlerMapping处理映射器 处理映射器根据请求url映射到具体的处理器controller controller执行完成后返回一个modelandview 待解析器将modelandview解析后返回给dispatchServlet 最后dispatchServlet将数据响应给用户 springBoot自动配置原理如何理解SpringBoot中的Starter使用spring+springMVC项目，如果要使用mybatis等框架，需要到xml中定义mybatis需要的bean spring boot中的starter就是定义一个starter的jar包，写一个@Configuration配置类，将这些bean定义在里面，然后在starter包的META-INF/spring.factories中写入该配置类，springboot会按照约定来加载该配置类 开发人员只需要将相应的starter包依赖进应用，进行相应的属性配置（使用默认配置时，不需要配置），就可以直接进行代码开发，使用对应的功能了，比如，mybatis-spring-boot-starter，spring-boot-starter-redis 为什么要使用嵌入式服务器节省了下载安装tomcat，应用也不需要再打war包，然后放到webapp目录下在运行 只需要一个安装了Java的虚拟机，就可以直接在上面部署应用程序了 springboot已经内置了tomcat.jar，运行main方法时会去启动tomcat，并利用tomcat的spi机制加载springmvc 3.Mybatis框架及数据库mybatis的优缺点优点： 基于sql语句编程，相当灵活 sql写在xml里，解除sql与程序代码的耦合，便于统一管理 提供xml标签，支持编写动态sql语句，并可重用 消除了jdbc大量冗余的代码，不需要手动开关连接 与spring能很好的集成 提供映射标签，支持对象与数据库的orm字段关系映射 缺点 编写sql语句时工作量很大，尤其是多字段，关联表多时 sql语句依赖于数据库，导致数据库移植性差，不能更换数据库 二级缓存机制不佳 #{}和${}的区别#是预编译处理，是占位符，$是字符串替换，是拼接符 mybatis在处理#时，会将sql里的#{}替换为？号，而处理$时，就会直接把${}替换为变量的值 使用#可以有效的防止sql注入，提高系统安全性 索引的基本原理索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。 索引的原理：就算把无序的数据变成有序的查询 步骤： 把创建了索引的列的内容进行排序 对排序结果生成倒排表 在倒排表内容上拼上数据地址链 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据 索引设计的原则查询更快，占用空间更小","categories":[],"tags":[]},{"title":"java基础复习篇","slug":"java-md","date":"2021-04-01T09:20:04.000Z","updated":"2021-04-01T09:25:54.292Z","comments":true,"path":"2021/04/01/java-md/","link":"","permalink":"http://yoursite.com/2021/04/01/java-md/","excerpt":"","text":"Java基础复习篇1.Java的特性和优势 简单性 面向对象 可移植性 高性能 分布式 动态性 多线程 安全性 健壮性 2.JDK、JRE、JVM3.IDEA优化4.Java基础语法4.1.注释 // 单行注释 /* */ 多行注释 /** */ 文档注释 4.2.数据类型 强类型语言 ：要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用 弱类型语言：跟强类型相反，比较随意 Java的数据类型分为两大类 基本类型 基本类型包括数值类型和boolean类型 数值类型又包括整数类型、浮点类型和字符类型 整数类型又包括以下几个 byte –占1个字节 范围（-128~127） short –占2个字节 范围（-32768~32767） int –占4个字节 范围（-2147483648~2147483647） long –占8个字节 范围（-9223372036854775808~9223372036854775807） 浮点类型包括 float –占4个字节 double –占8个字节 字符类型有char –占2个字节 而boolean类型只有true和false两个，各占一个字节 引用类型 类 接口 数组 最好避免使用浮点数进行比较，因为浮点数的精度会丢失，如果有这个场景，使用BigDecimal工具类来比较 所有的字符本质还是数字(97 = a,65 = A) 12345678910111213public class Project &#123; public static void main(String[] args) &#123; //字符类型 char a = &#x27;a&#x27;; char b = &#x27;张&#x27;; System.out.println(a); System.out.println(&quot;a转为int：&quot;+(int)a); System.out.println(b); System.out.println(&quot;张转为int：&quot;+(int)b); &#125;&#125; 布尔值知识扩展 1234boolean flag = true;if(flag==true)&#123;&#125; //新手if(flag)&#123;&#125; //老手//less is More！ 代码要精简易读 4.3.类型转换 强制转换 (类型)变量名 高–低 123456789public class project1 &#123; public static void main(String[] args) &#123; int i = 150; byte b = (byte) i; //内存溢出 System.out.println(i); System.out.println(b); &#125;&#125; ps：我们可以看到byte b打印的值为-106这是为什么呢？ 答：我们从底层源码可以看到byte最大值为127，我们的int i 为150，超出了byte的最大内存，造成内存溢出，byte值就会重新循环 Byte的底层源码： 1234567891011/** * A constant holding the minimum value a &#123;@code byte&#125; can * have, -2&lt;sup&gt;7&lt;/sup&gt;. */public static final byte MIN_VALUE = -128;/** * A constant holding the maximum value a &#123;@code byte&#125; can * have, 2&lt;sup&gt;7&lt;/sup&gt;-1. */public static final byte MAX_VALUE = 127; 自动转换 低–高 12345678910public class project1 &#123; public static void main(String[] args) &#123; int i = 150; byte b = (byte) i; //我们可以看到int i转为double类型不需要加(类型)变量名也不会报错，这就是低到高的自动转换 double d = i; System.out.println(i); System.out.println(b); &#125;&#125; 注意点： 不能对布尔值进行转换 不能把对象类型转换为不相干的类型 在把高容量转换到低容量的时候，强制转换 转换的时候可能存在内存溢出，或者精度问题 12System.out.println((int)27.96); //27System.out.println((int)56.48f); //56 ps：我们的double类型和浮点类型转成int并不会四舍五入，而会丢失精度，直接舍弃小数点后面的值 char 跟 int 之间的转换 1234char c = 97;int x = c+1;System.out.println(x);System.out.println((char)x); ps：我们可以看到char转换成int是可以做运算的，但是当我们把运算后的x值强转为char的时候x的值就变成了b，这是因为在char字符中97对应的a，加一之后就会变成b，字符的本质就是数字，字符和数字的对应也是有顺序的。 操作比较大的数的时候，注意溢出问题 12345678910111213public class project2 &#123; public static void main(String[] args) &#123; //jdk7的新特性，数字之间可以用下划线分割 int money = 10_0000_0000; int years = 30; int total = money*years; //-64771072,计算的时候超出了int的最大内存，导致内存溢出 long total1 = money*years; //-64771072，计算后默认是int类型，在转换之前就已经溢出了 long total2 = money*(long)years; //30000000000，先将一个值转换，计算后会将值转换为long类型 System.out.println(total); System.out.println(total1); System.out.println(total2); &#125;&#125; 4.4.变量和常量变量：就是可以变化的值 12345678910111213141516171819202122public class Project3 &#123; static double money = 2500; //类变量 使用static修饰 //实例变量，属于对象，想调用这个变量，需要先实例对象 //布尔值 默认是false //除了基本数据类型，其他的类型默认值都是null String name; //如果不进行初始化，默认值是null int age; //默认值是0 public static void main(String[] args) &#123; int i = 1; //局部变量，只在当前&#123;&#125;里面有效，而且必须声明和初始化值 System.out.println(i); //实例变量 Project3 project3 = new Project3(); System.out.println(project3.age); System.out.println(project3.name); //类变量 System.out.println(money); &#125; public void add()&#123;// System.out.println(i); //由于这个i是局部变量，只在声明他的&#123;&#125;里面有效，所有在其他方法中取不到 &#125;&#125; 变量的命名规范： 所有变量，方法，类名：都要求见名知意 类成员变量：首字母小写和驼峰原则：monthSalary，除了第一个单词以外，后面的单词首字母大写 局部变量：首字母小写和驼峰原则 类名：首字母大写和驼峰原则：Man，GoodMan 方法名：首字母小写和驼峰原则：run(),runRun() 常量：初始化后不能再改变值！不会动的值，常量名一般使用大写字符和下划线：MAX_VALUE 1234567891011public class Project4 &#123; //常量：使用final修饰，被final修饰过的值就不能再修改 //static也是修饰符，修饰符不分先后 final static double PI = 3.14; static final String NAME = &quot;zhangsan&quot;; public static void main(String[] args) &#123; System.out.println(PI); System.out.println(NAME); &#125;&#125; ps：常量不能被修改，初始化之后值就给定死了 4.5.运算符 算术运算符：+，-，*，/，%，++，– 赋值运算符：= 关系运算符：&gt;，&lt;，&gt;=，&lt;=，==，!=，instanceof 逻辑运算符：&amp;&amp;，||，! 位运算符：&amp;，|，^，~，&gt;&gt;，&lt;&lt;，&gt;&gt;&gt;(了解) 条件运算符：?，： 扩展赋值运算符：+=，-=，*=，/= 一元运算符： 12345678910111213public class Project5 &#123; public static void main(String[] args) &#123; // ++ -- 自增，自减，一元运算符 int a = 2; int b = a++; //执行完这行代码后，先给b赋值，再自增，相当于在它下面添加了一行 int a=a+1; int c = ++a; //执行完这行代码后，先自增，再给c赋值，相当于在它上面添加了一行 int a=a+1; System.out.println(a); System.out.println(b); System.out.println(c); &#125;&#125; 短路运算： &amp;&amp;：如果前面一个为假就不会再往后面执行 123456789public class Project6 &#123; public static void main(String[] args) &#123; int a = 4; boolean b = (a&lt;4) &amp;&amp; (a++&lt;4); System.out.println(a); System.out.println(b); &#125;&#125; ps:我们可以看到a打印的还是4，如果往&amp;&amp;后面去执行了a++就会是5 三元运算符： 1234567public class Project7 &#123; public static void main(String[] args) &#123; //三元运算符：x ? y : z 如果x为true就是y 如果x为false就是z int score = 80; //成绩 System.out.println(score&lt;60 ? &quot;不及格&quot; : &quot;及格&quot;); &#125;&#125; 4.5.JavaDoc生成文档5.Java流程控制5.1.Scanner的使用5.2.顺序结构 Java的基本结构就是顺序结构，除非特别指明，否则按照顺序一句一句执行。 顺序结构是最简单的算法结构，他是任何一个算法都离不开的一种基本算法结构 5.3.选择结构 if单选择结构 if双选择结构 if多选择结构 嵌套的if结构 switch多选择结构 从JavaSE 7开始 switch就支持字符串类型了 case穿透 ，为了防止case穿透，尽量在每个case后面都加上break； 拓展：反编译 java — class（字节码文件） —反编译（IDEA） ps：哈希通过特定算法，给每个对象一个唯一的值 5.4.循环结构while循环： 只要布尔表达式为true，循环就会一直执行下去 我们大部分情况是会让循环停止下来的，我们需要一个让表达式失效的方式来结束循环 少部分情况需要循环一直执行，比如服务器的请求响应监听等。 循环条件一直为true就会造成无限循环【死循环】，我们正常的业务编程中应该尽量避免死循环。会影响程序性能或者造成程序卡死崩溃！ 实例：计算1+2+3+……+100=？ 12345678910111213public class Project8 &#123; public static void main(String[] args) &#123; int i = 1; int sum = 0; while (i&lt;=100)&#123; sum+=i; i++; &#125; System.out.println(sum); &#125;&#125; do while循环： ​ 和while循环的区别: while是先判断后执行，do while是先执行后判断 do while 总是保证循环体至少会被执行一次！这是他们的主要差别 for循环： for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构 实例1：计算0到100之间的奇数和偶数和 123456789101112131415public class Project9 &#123; public static void main(String[] args) &#123; int oddSum = 0; int evenSum = 0; for (int i = 0; i &lt;=100; i++) &#123; if(i%2!=0)&#123; evenSum+=i; &#125;else&#123; oddSum+=i; &#125; &#125; System.out.println(&quot;奇数和：&quot;+evenSum); System.out.println(&quot;偶数和：&quot;+oddSum); &#125;&#125; 结果： 实例2：用for循环输出1-1000之间能被5整除的数，并且每行输出3个 123456789101112131415161718package demo2;public class Demo1 &#123; public static void main(String[] args) &#123; int l = 0; for (int i = 1; i &lt;= 1000; i++) &#123; if (i % 5 == 0) &#123; System.out.print(i + &quot;\\t&quot;); l++; &#125; if (l == 3) &#123; System.out.println(); l=0; &#125; &#125; &#125;&#125; 实例3：打印九九乘法表 123456789101112package demo2;public class Demo2 &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt;=9; i++) &#123; for (int j = 1; j &lt;=i; j++) &#123; System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+(i*j)+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 增强for循环： Java5引入了一种主要用于数组或集合的增强型for循环 实例： 12345678910package demo2;public class Demo3 &#123; public static void main(String[] args) &#123; int[] a = &#123;1,2,3,4,5&#125;; for (int i : a) &#123; System.out.println(i); &#125; &#125;&#125; break continue goto关键字（了解）： break在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。（break也可以在switch语句中使用） continue语句用在循环句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定 总结：实例：打印三角形 12345678910111213141516package demo2;public class Demo4 &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt;5; i++) &#123; for (int j = 5; j &gt;=i; j--) &#123; System.out.print(&quot; &quot;); &#125; for (int x = 1; x &lt;=(i*2+1); x++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 6.Java方法何为方法： Java方法是语句的集合，他们在一起执行一个功能 方法就是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他地方被引用 设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合，我们设计方法的时候，最好保持方法的原子性，就是一个方法只实现1个功能，这样利于我们后期的扩展。 方法的定义： Java的方法类似于其它语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法: 方法包含一个方法头和一个方法体。下面是一个方法的所有部分: 修饰符:修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。 返回值类型︰方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType是关键字void。 方法名:是方法的实际名称。方法名和参数表共同构成方法签名。 参数类型:参数像是一气占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。 形式参数:在方法被调用时用于接收外界输入的数据。 实参:调用方法时实际传给方法的数据。 方法体:方法体包含具体的语句，定义该方法的功能。 语法： 1234修饰符 返回值类型 方法名 (参数类型 参数名)&#123; 方法体 return 返回值;&#125; 方法的重载： 重载就是在一个类中，有相同的函数名称，但形参不同的函数 方法的重载规则： 方法名称必须相同 参数列表不许不同（个数不同，类型不同，参数排列顺序不同） 方法的返回类型可以相同也可以不同 仅仅返回类型不同不足以成为方法的重载 实现理论：方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，已选择对应的方法，如果匹配失败，则编译器报错。 命令行传参： 可变参数： JDK1.5开始，Java支持传递同类型的可变参数给一个方法 在方法声明中，在指定参数类型后面加一个省略号（…） 一个方法中只能定义一个可变参数，他必须是方法的最后一个参数。任何普通的参数必须在它之前声明 12345678910111213package demo2;public class Demo5 &#123; public static void main(String[] args) &#123; Demo5 demo5 = new Demo5(); demo5.add(1,2,3); &#125; public void add(int ... a)&#123; for (int i : a) &#123; System.out.println(i); &#125; &#125;&#125; ps：可变参数的本质上就是数组 递归： 递归就是A方法调用A方法，就是自己调自己 递归结构包括两个部分 递归头：什么时候不调用自身方法，如果没有头，将陷入死循环，就是结束递归的方法 递归体：什么时候需要调用自身方法 实例：阶乘 123456789101112131415161718package demo2;public class Demo6 &#123; public static void main(String[] args) &#123; Demo6 demo6 = new Demo6(); System.out.println(demo6.f(5)); &#125; public int f(int num)&#123; if(num == 1)&#123; return 1; &#125; if(num&gt;1)&#123; num = num*f(num -1); &#125; return num; &#125;&#125; ps：不要用递归做大的运算，不然很容易就内存溢出了 实例：编写一个计算器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package demo2;import java.util.Scanner;public class Demo7 &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); boolean flag = true; while (flag)&#123; System.out.println(&quot;请输入第一个数：&quot;); double num1 = scanner.nextDouble(); System.out.println(&quot;请输入运算符：&quot;); String n = scanner.next(); System.out.println(&quot;请输入第二个数：&quot;); double num2 = scanner.nextDouble(); Demo7 demo7 = new Demo7(); double result = 0; switch (n)&#123; case &quot;+&quot;: result = demo7.add(num1,num2); System.out.println(result); break; case &quot;-&quot;: result = demo7.minus(num1,num2); System.out.println(result); break; case &quot;*&quot;: result = demo7.times(num1,num2); System.out.println(result); break; case &quot;/&quot;: result = demo7.into(num1,num2); System.out.println(result); break; &#125; System.out.println(&quot;y/n：继续/退出&quot;); String y = scanner.next(); if (y.equals(&quot;n&quot;))&#123; flag = false; &#125; &#125; &#125; //加法 public double add(double num1,double num2)&#123; return num1+num2; &#125; //减法 public double minus(double num1,double num2)&#123; return num1-num2; &#125; //乘法 public double times(double num1,double num2)&#123; return num1*num2; &#125; //除法 public double into(double num1,double num2)&#123; return num1/num2; &#125;&#125; 7.数组数组的定义： 数组是相同类型数据的有序集合 数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成 其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问他们，数组的下标是从0开始的 数组声明创建的几种方式： 12345678910111213141516171819202122package demo2;public class Demo8 &#123; public static void main(String[] args) &#123; int[] a = new int[5]; //创建一个长度为5的数组 String[] b = &#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;赵六&quot;&#125;; //直接创建数组并赋值 //给数组赋值，数组的下标是从0开始的 a[0] = 1; a[1] = 2; a[2] = 3; a[3] = 4; a[4] = 5; //使用增强for循环遍历数组 for (int i : a) &#123; System.out.println(i); &#125; for (String s : b) &#123; System.out.println(s); &#125; &#125;&#125; 数组的四个特点： 数组的长度是确定的，数组一旦被创建，它的大小就是不可改变的。 数组的元素必须是相同类型，不允许出现混合类型 数组中的元素可以是任何数据类型，包括基本类型和引用类型 数组变量属引用类型，数组也可以看出是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中的 总结： 数组是相同数据类型（数据类型可以为任意类型）的有序集合 数组也是对象。数组元素相当于对象的成员变量 数组长度是确定的，不可变的。如果越界，则报：ArrayIndexOutoBounds 实例： 计算所有元素的和 和 查找最大的元素 12345678910111213int maxNum = 0; int sum = 0; for (int i = 0; i &lt; a.length; i++) &#123; sum+=a[i]; //计算所有元素的和 //查找最大的元素 if(a[i]&gt;maxNum)&#123; maxNum=a[i]; &#125; &#125; System.out.println(sum); System.out.println(maxNum); &#125; 数组入参 123456789101112131415package demo2;public class Demo9 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,2,3,4,5&#125;; Demo9 demo9 = new Demo9(); demo9.test(array); &#125; public void test(int[] array)&#123; for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]); &#125; &#125;&#125; 反转数组 12345public void test1(int[] arrays)&#123; for (int i = arrays.length-1; i&gt;=0; i--) &#123; System.out.println(arrays[i]); &#125;&#125; 多维数组： 多维数组可以看出是数组的数组，比如二维数组就是一个特殊的一维数组，其每个元素都是一个一维数组。 二维数组的两种创建方式 1234567891011121314151617package demo3;public class Demo1 &#123; public static void main(String[] args) &#123; int[][] array = new int[3][5]; array[0][1] = 1; array[0][4] = 5; System.out.println(array[0][4]); System.out.println(&quot;=========================&quot;); int[][] array1 = &#123;&#123;1,2,3,4,5&#125;,&#123;6,7,8,9,10&#125;,&#123;11,12,13,14,15&#125;&#125;; for (int i = 0; i &lt; array1.length; i++) &#123; for (int j = 0; j &lt; array1[i].length; j++) &#123; System.out.println(array1[i][j]); &#125; &#125; &#125;&#125; Array类的常用方法：（详情查看jdk帮助文档） 1234567891011121314package demo3;import java.util.Arrays;public class Demo2 &#123; public static void main(String[] args) &#123; int[] a = &#123;5,4,9,1,4,3,6,7&#125;; //打印数组 System.out.println(Arrays.toString(a)); //排序数组 ，升序 Arrays.sort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 冒泡排序法： 12345678910111213141516171819202122232425package demo3;import java.util.Arrays;public class Demo3 &#123; public static void main(String[] args) &#123; int[] a = &#123;5,8,2,3,6,7,9,1,3&#125;; Demo3 demo3 = new Demo3(); demo3.sort(a); System.out.println(Arrays.toString(a)); &#125; public int[] sort(int[] array)&#123; for (int i = 0; i &lt; array.length-1; i++) &#123; for (int j = 0; j &lt; array.length-i-1; j++) &#123; if(array[j+1]&gt;array[j])&#123; int temp; temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; &#125; &#125; &#125; return array; &#125;&#125; ps：排序后的结果 稀疏数组： 8.面向对象编程面向过程思想： 步骤清晰简单，面对过程适合处理一些较为简单的问题，面向过程是具体的 面向对象思想： 物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。 面向对象适合处理复杂的问题，适合处理需要多人协作的问题。 总结：对于描述复杂的事物，为了从宏观上把握，从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理 什么是面向对象： 面向对象编程的本质就是：以类的方式组织代码，以对象的方式封装数据 三大特性：封装，继承，多态 从认识论角度考虑是先有对象后有类。对象，是具体的事物，类是抽象的，是对对象的抽象 从代码运行角度考虑是先有类后有对象。类是对象的模板 构造方法： 和类命相同 没有返回值 作用： new 的本质是在调用构造器 初始化对象的值 注意：定义有参构造之后，如果想使用无参构造，显示的定义一个无参构造 创建对象内存分析： 图片引用狂神说Java 封装： 该露的露，该藏得藏，我们程序设计要追求“高内聚，低耦合”。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉，低耦合：仅暴露少量的方法给外部使用 封装（数据的隐藏）：通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏 属性私有，提供一些可操作属性的get/set方法，set方法中还能做一些判断 封装的好处： 提高程序的安全性，保护数据 隐藏代码的实现细节 统一接口 可维护性 继承： Java中只有单继承，没有多继承 继承是类和类之间的一种关系，除此之外，类和类之间的关系还有依赖、组合、聚合等。 继承关系的两个类，一个为子类，一个为父类。子类继承父类，使用关键字extends来表示，子类继承父类，就会拥有父类的全部方法，子类可以调用父类的方法 所有的类，都默认直接或间接继承Object类 super注意点： super调用父类的构造方法，必须在构造方法的第一个 super必须只能出现在子类的方法或构造方法中 super和this不能同上调用方法 vs this 代表的对象不同 this ： 本身调用者这个对象 super ： 代表父类对象的应用 前提 this： 没有继承也可以使用 super：只能在继承条件才可以使用 构造方法 ： this（）：本类的构造 super（）：父类的构造 方法重写： 需要有继承关系，子类重写父类的方法 方法名必须相同，参数列表也必须相同 修饰符：范围可以扩大，但不能缩小：public&gt;Protected&gt;Default&gt;private 抛出的异常：范围可以缩小，但不能扩大 重写，子类的方法和父类必须一致，方法体不同 为什么需要重写： 父类的功能，子类不一定需要，或者不一定满足！ 多态： 即同一方法可以根据发送对象的不同而采用多种不同的行为方式 多态存在的条件 有继承关系 子类重写父类方法 父类引用指向子类对象 注意： 多态是方法的多态，属性没有多态性 要有继承关系才能类型转换 static方法：属于类，它不属于实例，不能重写，也就没有多态 final修饰的方法不能被修改，所有无法重写，所有也没有多态 private方法修饰的方法也不能重写，没有多态 static关键字详解： 静态变量和静态方法都可以直接调用 静态代码块：类加载的时候就会执行，只执行一次 123456789101112131415161718192021222324package demo3;public class Demo4 &#123; //2 &#123; System.out.println(&quot;匿名代码块&quot;); &#125; //类加载的时候就会执行，只会执行一次 //1 static &#123; System.out.println(&quot;静态代码块&quot;); &#125; //3 public Demo4()&#123; System.out.println(&quot;构造方法&quot;); &#125; public static void main(String[] args) &#123; Demo4 demo4 = new Demo4(); System.out.println(&quot;=====================&quot;); Demo4 demo41 = new Demo4(); &#125;&#125;![image-20210401155655719](image-20210401155655719.png) ps：执行顺序：静态&gt;匿名&gt;构造 但是static只会执行一次 静态导入包 12345678910package demo3;import static java.lang.Math.random;import static java.lang.Math.PI;public class Demo5 &#123; public static void main(String[] args) &#123; System.out.println(random()); System.out.println(PI); &#125;&#125; 抽象类： 类添加abstract关键字，就变成了抽象类 方法加abstract关键字，就变成了抽象方法 抽象方法只有方法名字 没有方法的实现，让继承抽象类的类去帮我们实现 123456package demo3;//抽象类public abstract class Demo6 &#123; //抽象方法，继承抽象类的必须重写这个方法，我们不需要写具体实现，交给继承的类去帮我们实现 public abstract void add();&#125; 1234567891011121314package demo3;//继承抽象类public class Demo7 extends Demo6&#123; //重写抽象方法，并添加具体实现 @Override public void add() &#123; System.out.println(&quot;继承抽象类的抽象方法&quot;); &#125; public static void main(String[] args) &#123; Demo7 demo7 = new Demo7(); demo7.add(); &#125;&#125; 总结： 不能new这个抽象类，只能靠子类去实现它 抽象类中可以写普通的方法 抽象方法必须在抽象类中 接口： 接口可以定义一些方法，让不同的类去实现 接口不能被实例化，接口中没有构造方法 使用implements可以实现多个接口，实现接口必须要重写接口中的方法 内部类： 异常机制： 五个关键字： try：监控异常 catch：捕获异常 finally：处理善后工作，总会执行 throw：主动抛出异常，一般在方法中使用 throws：主动抛出异常，一般在方法上使用","categories":[],"tags":[]},{"title":"Spring Security学习记录（二）进阶篇","slug":"Security2-md","date":"2021-03-29T07:55:09.000Z","updated":"2021-03-29T08:25:20.329Z","comments":true,"path":"2021/03/29/Security2-md/","link":"","permalink":"http://yoursite.com/2021/03/29/Security2-md/","excerpt":"","text":"Spring Security学习记录（二）进阶篇1.Oauth2认证 简介第三方认证技术方案最主要是解决认证协议的通用标准问题，因为要实现跨系统认证，各系统之间一定要遵循一定的接口协议。 OAUTH协议为用户资源提供了一个安全的，开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、Javascript、Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如Open API，很多大公司如FGoogle，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。 Oauth协议目前发展到2.0版本，1.0版本过于复杂，2.0版本已得到广泛应用。 Oauth2认证流程 常用术语 客户凭证（client Credentials）：客户端的clientld和密码用于认证客户 令牌（tokens）：授权服务器在接收到客户请求后，颁发的访问令牌 作用域(scopes)：客户请求访问令牌时，由资源拥有者额外指定的细分权限（permission） 令牌类型 授权码：仅用于授权码授权类型，用于交换获取访问令牌和刷新令牌 访问令牌：用于代表一个用户或服务直接去访问受保护的资源 刷新令牌：用于去授权服务器获取一个刷新访问令牌 BearerToken：不管谁拿到Token都可以访问资源，类似现金 Proof of Possession（PoP） Token：可以检验client是否对Token有明确的拥有权 特点 优点 更安全，客户端不接触用户密码，服务器端更容易集中保护 广泛传播并被持续采用 短寿命和封装的Token 资源服务器和授权服务器解耦 集中式授权，简化客户端 HTTP/JSON友好，易于请求和传递token 考虑多种客户端架构场景 客户可以具有不同的信任级别 缺点 协议框架太宽泛，造成各种实现的兼容性和互操作行差 不是一个认证协议，本身并不能告诉你任何用户信息 2.Spring Security Oauth2 授权服务器 Authorize Endpoint：授权端点，进行授权 Token Endpoint：令牌端点，经过授权拿到对应的Token Introspection Endpoint：校验端点，检验Token的合法性 Revocation Endpoint：撤销端点，撤销授权 Spring Security Oauth2架构 流程： 用户访问，此时没有Token。Oauth2Rest Template会报错，这个报错信息会被Oauth2ClientContextFilter捕获并重新定向到认证服务器 认证服务器通过Authorization Endpoint进行授权，并通过AuthorizationServerTokenServices生成授权码并返回给客户端 客户端拿到授权码去认证服务器通过Token Endpoint调用AuthorizationServerTokenServices生成Token并返回给客户端 客户端拿到Token去资源服务器访问资源，一般会通过Oauth2AuthenticationManager调用ResourceServerTokenServices进行校验。校验通过可以获取资源。 3.Springsecurity Oauth2实例3.1授权码模式 引入相关依赖 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; //定义spring-cloud的版本 &lt;spring-cloud.version&gt;Greenwich.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; //spring-cloud整合oauth2 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; //spring-cloud整合security &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; //引入spring-cloud &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; //类型 &lt;type&gt;pom&lt;/type&gt; //引入的时候生效 &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 定义User实体并实现security底层的UserDetails接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class User implements UserDetails &#123; private String username; private String password; private List&lt;GrantedAuthority&gt; authorities; public User(String username, String password, List&lt;GrantedAuthority&gt; authorities) &#123; this.username = username; this.password = password; this.authorities = authorities; &#125; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return authorities; &#125; @Override public String getPassword() &#123; return password; &#125; @Override public String getUsername() &#123; return username; &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; 编写UserService来处理用户认证 12345678910111213@Servicepublic class UserService implements UserDetailsService &#123; @Autowired private PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //密码是定死的，无论输入什么用户，密码对上直接认证成功，没从数据库查 String password = passwordEncoder.encode(&quot;123456&quot;); //将用户返回，给定admin权限 return new User(username,password, AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin&quot;)); &#125;&#125; 编写SecurityConfig配置类用来处理放行和拦截等配置 1234567891011121314151617181920212223@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() //放行 /oauth/**：放行授权服务器的所有操作 .antMatchers(&quot;/oauth/**&quot;,&quot;/login/**&quot;,&quot;/logout/**&quot;) .permitAll() //除了放行的请求都需要认证 .anyRequest().authenticated() .and() //放行所有的表单请求 .formLogin().permitAll() .and() //关闭csrf防护 .csrf().disable(); &#125; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125; 配置授权服务器 1234567891011121314151617181920212223242526@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123; @Autowired private PasswordEncoder passwordEncoder; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; //为了方便直接将客户端的信息储存到内存里了 //实际开发中需要客户端来请求授权服务器 clients.inMemory() //客户端ID .withClient(&quot;client&quot;) //密钥 .secret(passwordEncoder.encode(&quot;112233&quot;)) //重定向地址 .redirectUris(&quot;http://www.baidu.com&quot;) //授权范围 .scopes(&quot;all&quot;) /** * 授权类型 * authorization_code : 授权码模式 */ .authorizedGrantTypes(&quot;authorization_code&quot;); &#125;&#125; 配置资源服务器 123456789101112@Configuration@EnableResourceServerpublic class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123; @Override public void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest().authenticated() .and() .requestMatchers() .antMatchers(&quot;/user/**&quot;); &#125; 编写controller控制器来返回资源 12345678910@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; //资源控制器返回的资源，想获取资源需要有对应的令牌 @RequestMapping(&quot;/getCurrentUser&quot;) public Object getCurrentUser(Authentication authentication)&#123; return authentication.getPrincipal(); &#125;&#125; 测试 获取授权码 1http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;authorize?response_type&#x3D;code&amp;client_id&#x3D;client&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;www.baidu.com&amp;scope&#x3D;all 输入上面的url来到了security自带的登录页面 登录成功后来到授权页面 Deny：不允许，Approve：允许 授权后来到我们设定的重定向页面，后面是授权码 根据授权码获取令牌（POST请求） 去到图下位置，用户名和密码是之前配置的授权服务器的客户端id和密钥 在去到Body里面选中x-www.form-urlencoded grant_type:授权类型，填写authorization_code，表示授权码模式 code：授权码，就是刚刚获取的授权码，注意：授权码只能使用一次就无效了，需要重新申请 client_id：客户端标识 redirect_uri：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致 scope：授权范围 发送请求之后得到令牌 access_token ：令牌 token_type: 令牌类型 scope：令牌范围 获取令牌之后就可以去访问资源了 访问的资源地址就是我们资源服务器的资源地址 拿到刚刚得到的token放在下图位置 访问到的资源信息 我们把令牌改一下，然后就会报错，说我们的令牌是一个非法令牌，令牌不对是获取不了资源的 3.2.密码模式 密码模式比授权码模式简单很多，我们在授权码模式的基础上稍作调整就好了 在SecurityConfig配置类新注册一个AuthenticationManager 1234@Bean public AuthenticationManager authenticationManager() throws Exception &#123; return super.authenticationManager(); &#125; 授权服务器里面新增一个实现方法 123456/** * 授权类型 * authorization_code : 授权码模式 * password : 密码模式 */ .authorizedGrantTypes(&quot;authorization_code&quot;,&quot;password&quot;); 测试 还是在下图位置输入我们的客户端id和密钥 然后在body中输入授权类型、授权范围、用户名和密码 grant_type:授权类型，填写password，表示密码模式 scope：授权范围 username ： 自己定义的用户名 password ： 密码 发送请求之后获得令牌 使用刚刚得到的令牌去获取资源，步骤跟授权码模式一样 3.3将token存储到redis中 引入redis相关依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; 编写redis相关的配置 1234spring.redis.port=6379spring.redis.host=127.0.0.1spring.redis.password=123456 编写RedisConfig配置类 1234567891011@Configurationpublic class RedisConfig &#123; @Autowired private RedisConnectionFactory redisConnectionFactory; @Bean public TokenStore redisTokenStore()&#123; return new RedisTokenStore(redisConnectionFactory); &#125;&#125; 在授权服务器中将Token令牌保存到Redis中 123456789101112 @Autowired//用Qualifier指定，不然找不到 @Qualifier(&quot;redisTokenStore&quot;) private TokenStore tokenStore; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; endpoints.authenticationManager(authenticationManager) .userDetailsService(userService) //将Token令牌保存到redis中 .tokenStore(tokenStore); &#125; 测试，还是使用密码模式发送请求，请求后可以看到redis将Token令牌存起来了 4.JWT 常见的认证机制（详情百度） HTTP Basic Auth Cookie Auth OAuth Token Auth 什么是JWT JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），他定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。 官网：https://jwt.io/ 标准：https://tools.ietf.org/html/rfc7519 JWT令牌的优点： jwt基于json，非常方便解析。 可以在令牌中自定义丰富的内容，易扩展。 通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高 资源服务使用JWT可不依赖认证服务即可完成授权。 缺点： JWT令牌较长，占存储空间比较大。 JWT组成 一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名 头部（Header） 头部用于描述关于该JWT的最基本的信息，例如其类型（即JWT）以及签名所使用的算法（如HMAC SHA256或RSA）等，这也可以被表示成一个JSON对象。 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; typ:是类型 alg：签名的算法，这里使用的是HS256算法 负载（Payload） 第二部分是负载，就是存放有效信息的地方。这些有效信息包含三个部分 标准中注册的声明（建议但不强制使用） iss：jwt的签发者 sub：jwt所面向的用户 aud：接受jwt的一方 exp：jwt的过期时间，这个过期时间必须要大于签发时间 nbf：定义在什么时间之前，该jwt都是不可用的 iat：jwt的签发时间 jti：jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击 公共的声明 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可以解密。 私有的声明 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息 这个指的就是自定义的claim。比如下面那个举例中的name都属于自定的claim。这些claim跟JWT标准规定的claim区别在于：JWT规定的claim，JWT的接收方在拿到JWT之后，都知道怎么对这些标准的claim进行验证（还不知道是否能够验证）而private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行。 12345&#123; &quot;sub&quot;: &quot;1234567890&quot; &quot;name&quot;: &quot;John Doe&quot; &quot;iat&quot;: 1516239022&#125; 其中sub是标准的声明，name是自定义的声明（公共或私有的） 签证、签名（signature） jwt的第三部分是一个签证信息，这个签证信息有三部分组成 header（base64后的） payload（base64后的） secret（盐，一定要保密） 注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所有，他就是你服务器端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret，那就意味着客户端是可以自我签发jwt了。 5.JJWT 什么是JJWT JJWT是一个提供到端的JWT创建和验证的Java库，永远免费和开源（Apache License，版本2.0）JJWT很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。 快速入门 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; 编写测试类 123456789101112131415161718192021@SpringBootTestpublic class JjwtDemoApplicationTests &#123; @Test public void contextLoads() &#123; JwtBuilder jwtBuilder = Jwts.builder() //唯一ID&#123;“id”：“888”&#125; .setId(&quot;888&quot;) //接受的用户&#123;“sub”：“Rose”&#125; .setSubject(&quot;Rose&quot;) //签发时间&#123;“iat”：“时间”&#125; .setIssuedAt(new Date()) //签名算法，及密钥 .signWith(SignatureAlgorithm.HS256,&quot;abcd&quot;); //签发token String token = jwtBuilder.compact(); System.out.println(token); &#125;&#125; 测试结果 在官网解析令牌 - 也可以自己编写代码解析 123456System.out.println(&quot;=======================&quot;); String[] split = token.split(&quot;\\\\.&quot;); System.out.println(Base64Codec.BASE64.decodeToString(split[0])); System.out.println(Base64Codec.BASE64.decodeToString(split[1])); //这个会乱码，为了安全考虑 System.out.println(Base64Codec.BASE64.decodeToString(split[2])); - 解析效果 解析token 1234567891011121314@Test public void testParseToken()&#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.&quot; + &quot;eyJqdGkiOiI4ODgiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNjE2NzUwNTk1fQ.&quot; + &quot;rWfl8Fxzz0Lgh0qr-nchqiRpv89jRA_SXmuWLsxL-zk&quot;; //解析token，获取Claims，jwt中荷载申明的对象 Claims claims = (Claims) Jwts.parser() .setSigningKey(&quot;abcd&quot;) .parse(token) .getBody(); System.out.println(&quot;id=&quot;+claims.getId()); System.out.println(&quot;sub=&quot;+claims.getSubject()); System.out.println(&quot;iat=&quot;+claims.getIssuedAt()); &#125; 效果： token过期校验 123456789101112131415161718192021222324252627282930313233343536373839@Test public void contextLoadsExp() &#123; long data = System.currentTimeMillis(); long exp = data+60*1000; JwtBuilder jwtBuilder = Jwts.builder() //唯一ID&#123;“id”：“888”&#125; .setId(&quot;666&quot;) //接受的用户&#123;“sub”：“Rose”&#125; .setSubject(&quot;Rose&quot;) //签发时间&#123;“iat”：“时间”&#125; .setIssuedAt(new Date()) //设置失效时间 .setExpiration(new Date(exp)) //签名算法，及密钥 .signWith(SignatureAlgorithm.HS256,&quot;abcd&quot;); //签发token String token = jwtBuilder.compact(); System.out.println(token); System.out.println(&quot;=======================&quot;); String[] split = token.split(&quot;\\\\.&quot;); System.out.println(Base64Codec.BASE64.decodeToString(split[0])); System.out.println(Base64Codec.BASE64.decodeToString(split[1])); //这个会乱码，为了安全考虑 System.out.println(Base64Codec.BASE64.decodeToString(split[2])); &#125; @Test public void testParseTokenExp()&#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.&quot; + &quot;eyJqdGkiOiI2NjYiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNjE2OTgwODU1LCJleHAiOjE2MTY5ODA5MTV9.&quot; + &quot;n9j9sft8JhaZc_qLBroiQHP5-TZQwzu409nIRMEdtAQ&quot;; Claims claims = (Claims) Jwts.parser() .setSigningKey(&quot;abcd&quot;) .parse(token) .getBody(); System.out.println(&quot;id=&quot;+claims.getId()); System.out.println(&quot;sub=&quot;+claims.getSubject()); System.out.println(&quot;iat=&quot;+claims.getIssuedAt()); &#125; 当我们测试发现多了一个失效时间 然后过一分钟解析token的时候，报错说token已经失效（前面一个时间是失效时间，第二个时间是我们解析他的时间） 自定义Claims 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 @Test public void contextLoadsEnhancer() &#123; long data = System.currentTimeMillis(); long exp = data+60*1000; JwtBuilder jwtBuilder = Jwts.builder() //唯一ID&#123;“id”：“888”&#125; .setId(&quot;666&quot;) //接受的用户&#123;“sub”：“Rose”&#125; .setSubject(&quot;Rose&quot;) //签发时间&#123;“iat”：“时间”&#125; .setIssuedAt(new Date()) //设置失效时间// .setExpiration(new Date(exp)) //自定义claim .claim(&quot;name&quot;,&quot;张三&quot;) .claim(&quot;logo&quot;,&quot;xxx.jpg&quot;) //以map的方式自定义Claim// .addClaims(Map); //签名算法，及密钥 .signWith(SignatureAlgorithm.HS256,&quot;abcd&quot;); //签发token String token = jwtBuilder.compact(); System.out.println(token); System.out.println(&quot;=======================&quot;); String[] split = token.split(&quot;\\\\.&quot;); System.out.println(Base64Codec.BASE64.decodeToString(split[0])); System.out.println(Base64Codec.BASE64.decodeToString(split[1])); //这个会乱码，为了安全考虑 System.out.println(Base64Codec.BASE64.decodeToString(split[2])); &#125; @Test public void testParseTokenEnhancer()&#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.&quot; + &quot;eyJqdGkiOiI2NjYiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNjE2OTgwODU1LCJleHAiOjE2MTY5ODA5MTV9.&quot; + &quot;n9j9sft8JhaZc_qLBroiQHP5-TZQwzu409nIRMEdtAQ&quot;; Claims claims = (Claims) Jwts.parser() .setSigningKey(&quot;abcd&quot;) .parse(token) .getBody(); System.out.println(&quot;id=&quot;+claims.getId()); System.out.println(&quot;sub=&quot;+claims.getSubject()); System.out.println(&quot;iat=&quot;+claims.getIssuedAt()); System.out.println(&quot;name=&quot;+claims.get(&quot;name&quot;)); System.out.println(&quot;logo=&quot;+claims.get(&quot;logo&quot;)); &#125; 自定义claim测试 自定义claim解析 6.SpringSecurityOauth2集成JWT 基于SpringSecurityOauth2实例的基础上新增一个JwtTokenStoreConfig配置类 12345678910111213141516@Configurationpublic class JwtTokenStoreConfig &#123; @Bean public TokenStore jwtTokenStore()&#123; return new JwtTokenStore(jwtAccessTokenConverter()); &#125; @Bean public JwtAccessTokenConverter jwtAccessTokenConverter()&#123; JwtAccessTokenConverter jwtAccessTokenConverter = new JwtAccessTokenConverter(); //设置jwt密钥 jwtAccessTokenConverter.setSigningKey(&quot;test-key&quot;); return jwtAccessTokenConverter; &#125;&#125; 在授权服务器将其转化成JwtToken 1234567891011121314@Autowired @Qualifier(&quot;jwtTokenStore&quot;) TokenStore tokenStore; @Autowired JwtAccessTokenConverter jwtAccessTokenConverter; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; endpoints.authenticationManager(authenticationManager) .userDetailsService(userService) //accessToken 转成JWTToken .tokenStore(tokenStore) .accessTokenConverter(jwtAccessTokenConverter); &#125; 测试结果 这串Token相比之前的token长了很多 6.1.扩展jwt中的存储内容 编写一个JwtTokenEnhancerConfig编写自定义的存储内容 12345678910@Configurationpublic class JwtTokenEnhancerConfig implements TokenEnhancer &#123; @Override public OAuth2AccessToken enhance(OAuth2AccessToken oAuth2AccessToken, OAuth2Authentication oAuth2Authentication) &#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //添加自定义的存储内容 map.put(&quot;hello&quot;,&quot;wolrd&quot;); ((DefaultOAuth2AccessToken)oAuth2AccessToken).setAdditionalInformation(map); return oAuth2AccessToken; &#125; 在授权服务器中将自定义的存储内容添加到JwtToken中 123456789101112131415161718192021@AutowiredJwtAccessTokenConverter jwtAccessTokenConverter;@AutowiredJwtTokenEnhancerConfig jwtTokenEnhancerConfig; @Overridepublic void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; //设置jwt增强内容 TokenEnhancerChain chain = new TokenEnhancerChain(); List&lt;TokenEnhancer&gt; delegates = new ArrayList&lt;&gt;(); delegates.add(jwtTokenEnhancerConfig); delegates.add(jwtAccessTokenConverter); chain.setTokenEnhancers(delegates); endpoints.authenticationManager(authenticationManager) .userDetailsService(userService) //accessToken 转成JWTToken .tokenStore(tokenStore) .accessTokenConverter(jwtAccessTokenConverter) .tokenEnhancer(chain) ;&#125; 测试结果 6.2.解析Jwt令牌 直接在controller里面解析 12345678910111213141516@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/getCurrentUser&quot;) public Object getCurrentUser(Authentication authentication, HttpServletRequest request)&#123; //获取请求头为Authorization的值 String header = request.getHeader(&quot;Authorization&quot;); //截取令牌 String token = header.substring(header.lastIndexOf(&quot;bearer&quot;)+7); return Jwts.parser() .setSigningKey(&quot;test-key&quot;.getBytes(StandardCharsets.UTF_8)) .parseClaimsJws(token) .getBody(); &#125; 测试结果 先获取JwtToken 在根据令牌获取解析的JwtToken数据 注意这个不要填写之前需要，现在不用了 然后把刚刚拿到的JwtToken放入请求的头部信息中 解析后的数据，可以看到我们解析的数据和官网是一样的 ) 6.3.设置JwtToken过期时间和刷新令牌 在授权服务器中设置JwtToken失效时间 12345//授权范围 .scopes(&quot;all&quot;) //设置失效时间 .accessTokenValiditySeconds(60) 一分钟后提示令牌失效，失效原因：令牌已过期 设置刷新令牌 由于令牌失效又要从头走一遍获取令牌的流程比较复杂，我们可以使用刷新令牌 在授权服务器中设置刷新令牌 1234567/** * 授权类型 * authorization_code : 授权码模式 * password : 密码模式 * refresh_token : 刷新令牌 */ .authorizedGrantTypes(&quot;authorization_code&quot;,&quot;password&quot;,&quot;refresh_token&quot;); 设置刷新令牌的有效时间 12//刷新令牌失效时间 .refreshTokenValiditySeconds(66666) 我们可以看到访问时多了一个刷新令牌 一分钟过后令牌过期 使用刷新令牌去获取新的令牌 使用刷新令牌后重新得到的令牌又有一分钟的有效时间 7.SpringSecurityOauth2集成SSO（单点登录） 创建一个客户端sso-demo 导入依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 编写配置文件 123456789101112#不能跟服务端一样server.port=8081#因为我们可能会有很多个客户端，防止Cookie冲突，冲突会导致验证不通过server.servlet.session.cookie.name=OAUTH2CLIENT01#授权服务器地址oauth2-server-rul: http://localhost:8080#与授权服务器对应的地址security.oauth2.client.client-id=clientsecurity.oauth2.client.client-secret=112233security.oauth2.client.user-authorization-uri=$&#123;oauth2-server-rul&#125;/oauth/authorizesecurity.oauth2.client.access-token-uri=$&#123;oauth2-server-rul&#125;/oauth/tokensecurity.oauth2.resource.jwt.key-uri=$&#123;oauth2-server-rul&#125;/oauth/token_key 在启动类添加开启sso的注解 12345678910@SpringBootApplication//开启单点登录@EnableOAuth2Ssopublic class SsoDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SsoDemoApplication.class, args); &#125;&#125; 编写controller测试 12345678@RestController@RequestMapping(&quot;/user&quot;)public class SsoController &#123; @RequestMapping(&quot;/getCurrentUser&quot;) public Object getCurrentUser(Authentication authentication)&#123; return authentication; &#125;&#125; 服务端还是跟之前一样，只要添加以下代码 在授权服务器里重写一个方法 12345@Override public void configure(AuthorizationServerSecurityConfigurer security) throws Exception &#123; //获取密钥必须要身份验证，单点登录必须要配置 security.tokenKeyAccess(&quot;isAuthenticated()&quot;); &#125; 更改授权后的重定向地址 123 .redirectUris(&quot;http://localhost:8081/login&quot;) //自动授权.autoApprove(true) 测试效果 当我们访问http://localhost:8081/user/getCurrentUser就会跳转到服务端的登录地址 当我们登录后会跳转到授权页面，开启自动授权的话就直接授权，跳过此页面 授权后我们来到客户端的（http://localhost:8081/user/getCurrentUser）getCurrentUser方法里","categories":[],"tags":[]},{"title":"Spring Security学习记录基础版(一)","slug":"security-md","date":"2021-03-23T07:54:48.000Z","updated":"2021-03-23T07:59:48.795Z","comments":true,"path":"2021/03/23/security-md/","link":"","permalink":"http://yoursite.com/2021/03/23/security-md/","excerpt":"","text":"Spring Security学习记录基础版(一)1.概要 Spring Security的核心功能 用户认证：就是系统认为用户是否登录 用户授权：就是系统判断用户是否有权限去做某些事情 2.Hello Security 创建一个SpringBoot工程 引入相关依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 编写controller测试 123456789@RestController@RequestMapping(&quot;quick&quot;)public class QuickController &#123; @GetMapping(&quot;/hello&quot;) public Object hello()&#123; return &quot;hello security&quot;; &#125;&#125; 测试结果：security启动默认会有一个登录页，security默认得用户名是：user 密码每次执行会在控制台打印，登录成功后显示测试结果 3.SpringSecurity基本原理 SpringSecurity本质是一个过滤器链，由很多过滤器组成 FilterSecurityInterceptor：是一个方法级的权限过滤器，基本位于过滤链的最底部 ExceptionTranslationFilter：是个异常过滤器，用来处理在认证授权过程中的异常 UsernamePasswordAuthenticationFilter：对／login的POST请求做拦截，校验表单中用户名，密码 SpringSecurity两个重要的接口 UserDetailsService接口:查询数据库用户名和密码的过程 创建类继承UsernamePasswordAuthenticationFilter,重写三个方法 创建类实现UserDetailService,编写查询数据过程,返回User对象,这个User对象是Security提供的对象 PasswordEncoder接口:数据加密接口,用于返回User对象里面密码加密 4.security设置用户和密码 通过配置文件设置(了解) 1234567spring: security: user: name: admin password: 123456 roles: root 通过配置类设置(了解) 12345678910111213141516171819@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired PasswordEncoder passwordEncoder; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //将密码加密 String password = passwordEncoder.encode(&quot;123456&quot;); auth.inMemoryAuthentication().withUser(&quot;test&quot;) .password(password).roles(&quot;test&quot;); &#125; //不加这一步会报@PreAuthorizeConsider defining a bean of type &#x27;org.springframework.security.crypto.password.PasswordEncoder&#x27; in your configuration. @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125; 自定义实现类设置 第一步 创建配置类,设置使用哪个userDetailsService实现类 1234567891011121314@Configurationpublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private UserDetailsService userDetailsService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder()); &#125; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125; 第二步 编写实现类,返回User对象,User对象有用户名密码和操作权限 123456789@Servicepublic class MyUserDetailsService implements UserDetailsService &#123; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123; List&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role&quot;); return new User(&quot;test&quot;,new BCryptPasswordEncoder().encode(&quot;123&quot;),auths); &#125;&#125; 5.查询数据库完成用户认证 引入相关依赖 1234567891011121314151617181920212223&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 创建数据库 12345678910CREATE DATABASE testUSE testCREATE TABLE users( id INT(10) PRIMARY KEY AUTO_INCREMENT, uname VARCHAR(30) NOT NULL, upassword VARCHAR(80) NOT NULL)INSERT INTO users VALUES (DEFAULT,&#x27;admin&#x27;,&#x27;123456&#x27;);INSERT INTO users VALUES (DEFAULT,&#x27;test&#x27;,&#x27;123&#x27;);INSERT INTO users VALUES (DEFAULT,&#x27;root&#x27;,&#x27;123456&#x27;) 配置数据库相关信息 123456spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8 username: root password: 123456 创建users表对应实体类 123456789@Data@AllArgsConstructor@NoArgsConstructorpublic class Users &#123; private long id; private String uname; private String upassword;&#125; 整合mybatisPlus,创建接口,继承mp的接口 123public interface UserMapper extends BaseMapper&lt;Users&gt; &#123;&#125; 在MyUserDetailsService调用mapper里面的方法查询数据库进行用户认证 1234567891011121314151617181920@Servicepublic class MyUserDetailsService implements UserDetailsService &#123; @Autowired UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //mybatisplus提供的条件构造器 QueryWrapper&lt;Users&gt; wrapper = new QueryWrapper(); //下面这句话等同于where uname=? wrapper.eq(&quot;uname&quot;,username); //因为用户名不能重复，使用selectOne得到某一条数据 Users user = userMapper.selectOne(wrapper); if(user == null)&#123; throw new UsernameNotFoundException(&quot;用户不存在&quot;); &#125; List&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role&quot;); //查询数据库得到的user对象的用户名和密码返回给security提供的User对象里面 return new User(user.getUname(),new BCryptPasswordEncoder().encode(user.getUpassword()),auths); &#125;&#125; 在启动类上添加@MapperScan注解 12345678@SpringBootApplication@MapperScan(&quot;com.project.securityquickstart.mapper&quot;)public class SecurityQuickStartApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SecurityQuickStartApplication.class, args); &#125;&#125; 启动测试 12345678@RestController@RequestMapping(&quot;quick&quot;)public class QuickController &#123; @GetMapping(&quot;/hello&quot;) public Object hello()&#123; return &quot;hello security&quot;; &#125;&#125; 测试成功,三个账号都可以进行登录,但是启动时出现如下警告: This primary key of “id” is primitive !不建议如此请使用包装类 in Class: “com.project.securityquickstart.bean.Users” 6.自定义登录页 配置类编写相关的配置 123456789101112@Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() //自定义自己的登录页面 .loginPage(&quot;/login.html&quot;) //登录页面设置 .loginProcessingUrl(&quot;/quick/login&quot;) //登录页访问路径 .defaultSuccessUrl(&quot;/quick/index&quot;).permitAll() //登录成功后跳转的地址 .and().authorizeRequests() //配置不用认证就能访问的页面 .antMatchers(&quot;/&quot;,&quot;/quick/login&quot;,&quot;/quick/hello&quot;).permitAll() .anyRequest().authenticated() .and().csrf().disable(); //关闭csrf防护 &#125; 创建登录的页面 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;security自定义登录页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/quick/login&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;Login&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 编写controller测试 123456789101112@RestController@RequestMapping(&quot;quick&quot;)public class QuickController &#123; @GetMapping(&quot;/hello&quot;) public Object hello()&#123; return &quot;hello security&quot;; &#125; @GetMapping(&quot;/index&quot;) public Object login()&#123; return &quot;hello index&quot;; &#125;&#125; 效果图 当我输入http://localhost:8080/quick/index的时候会自动跳转登录页 登录成功后会跳转到配置类里配置的/quick/index的controller 7.基于权限进行访问控制 如果当前的主体具有指定权限,则返回true,否则返回false 没有访问权限 403 hasAuthority和hasAnyAuthority方法的使用实例 在配置类编写基于权限进行访问控制的相关配置 12345678910111213141516 @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() //自定义自己的登录页面 .loginPage(&quot;/login.html&quot;) //登录页面设置 .loginProcessingUrl(&quot;/quick/login&quot;) //登录页访问路径 .defaultSuccessUrl(&quot;/quick/index&quot;).permitAll() //登录成功后跳转的地址 .and().authorizeRequests() //配置访问权限为admins的才能访问/quick/index,只能配置单个// .antMatchers(&quot;/quick/index&quot;).hasAuthority(&quot;admins&quot;) //配置访问权限为admins和role的都能访问/quick/index，可配置多个 .antMatchers(&quot;/quick/index&quot;).hasAnyAuthority(&quot;admins,role&quot;) //配置不用认证就能访问的页面 .antMatchers(&quot;/&quot;,&quot;/quick/login&quot;,&quot;/quick/hello&quot;).permitAll() .anyRequest().authenticated() .and().csrf().disable(); //关闭csrf防护 &#125; 在MyUserDetailsService里配置用户的访问权限 1List&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role&quot;); 8.基于角色进行访问控制 如果当前主题具有指定角色,则返回true hasRole和hasAnyRole使用实例 在配置类编写基于角色进行访问控制的相关配置 1234 //配置角色为root的才能访问/quick/index，只能配置单个角色// .antMatchers(&quot;/quick/index&quot;).hasRole(&quot;root&quot;) //配置角色为root和admin中的一个的就能访问/quick/index，可配置多个角色 .antMatchers(&quot;quick/index&quot;).hasAnyRole(&quot;root,admin&quot;) 在MyUserDetailsService里配置用户的角色 1List&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role,ROLE_root,ROLE_admin&quot;); 注意:security底层的hasRole和hasAnyRole方法会给你加上”ROLE_”的前缀,在配置用户角色的时候要记得加上 9.自定义403页面 在配置类中编写 1http.exceptionHandling().accessDeniedPage(&quot;/unauth.html&quot;); 编写unauth.html页面,效果图: 10.注解的使用10.1@Secured –用户具有某个角色，可以访问方法 在启动类或配置类开启注解 1234567@EnableGlobalMethodSecurity(securedEnabled = true)public class SecurityQuickStartApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SecurityQuickStartApplication.class, args); &#125;&#125; 在controller添加@Secured能够访问的角色 12345@GetMapping(&quot;/getUpd&quot;) @Secured(&quot;ROLE_root&quot;) public Object upd()&#123; return &quot;hello,update&quot;; &#125; 在MyUserDetailsService查看有没有配置能访问的角色并测试 1List&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role,admins,ROLE_root&quot;); 10.2@PreAuthorize –在进入方法之前进行权限和角色验证 在启动类或配置类开启注解 1@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true) 在在controller添加@PreAuthorize能够访问的角色和权限 12345 @GetMapping(&quot;/getUpd&quot;)@PreAuthorize(&quot;hasAuthority(&#x27;role&#x27;)&quot;) public Object upd()&#123; return &quot;hello,update&quot;; &#125; 在MyUserDetailsService查看有没有配置能访问的角色并测试 这个注解里面可以写hasRole、hasAnyRole、hasAuthority和hasAnyAuthority 10.3@PostAuthorize –在方法执行之后进行权限和角色验证 在启动类或配置类开启注解 –同上 在controller添加@PreAuthorize能够访问的角色和权限 123456789 @GetMapping(&quot;/getUpd&quot;)// @Secured(&quot;ROLE_root&quot;)// @PreAuthorize(&quot;hasAuthority(&#x27;role&#x27;)&quot;) @PostAuthorize(&quot;hasAuthority(&#x27;role&#x27;)&quot;) public Object upd()&#123; System.out.println(&quot;update执行中&quot;); return &quot;hello,update&quot;; &#125;&#125; 在MyUserDetailsService查看有没有配置能访问的角色并测试，测试发现虽然没权限访问，但是里面的方法还是打印了 这个注解里面可以写hasRole、hasAnyRole、hasAuthority和hasAnyAuthority 10.4@PostFilter –方法返回的数据进行过滤 在controller注解中添加@PostFilter 需要过滤的数据,可以搭配上面的注解一起使用 123456789@GetMapping(&quot;/getAll&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;role&#x27;)&quot;) @PostFilter(&quot;filterObject.uname == &#x27;admin1&#x27;&quot;) public List&lt;Users&gt; getAll()&#123; List&lt;Users&gt; list = new ArrayList&lt;Users&gt;(); list.add(new Users(0,&quot;admin1&quot;,&quot;123&quot;)); list.add(new Users(0,&quot;admin2&quot;,&quot;123&quot;)); return list; &#125; 测试结果，只返回指定过滤的值 10.5@PreFilter –方法传入的数据进行过滤 暂时还不知道怎么用，出现如下错误 1Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.IllegalArgumentException: Filter target must be a collection, array, map or stream type, but was Users(uname&#x3D;admin1, upassword&#x3D;123456)] with root cause 11.用户注销 在登录页添加一个退出的超链接 1&lt;a href=&quot;/logout&quot;&gt;注销&lt;/a&gt; 在配置类中添加退出映射地址 1http.logout().logoutUrl(&quot;/logout&quot;).logoutSuccessUrl(&quot;/quick/exit&quot;).permitAll(); 测试类测试 1234@GetMapping(&quot;/exit&quot;) public Object exit()&#123; return &quot;注销成功。。。。&quot;; &#125; 测试结果注销是能注销，但是在访问其他方法不需要登录验证了 12.自动登录 创建保存用户token的数据库 1234567CREATE TABLE persistent_logins( username VARCHAR(64) NOT NULL, series VARCHAR(64) NOT NULL, token VARCHAR(64) NOT NULL, last_used TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY(series))ENGINE = INNODB DEFAULT CHARSET=utf8; 配置类，注入数据源，配置操作数据库对象 12345678@Autowired private DataSource dataSource; @Bean public PersistentTokenRepository persistentTokenRepository()&#123; JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl(); jdbcTokenRepository.setDataSource(dataSource); return jdbcTokenRepository; &#125; 配置类中配置自动登录 123.and().rememberMe().tokenRepository(persistentTokenRepository()) //配置自动登录的有效时间 .tokenValiditySeconds(120) .userDetailsService(userDetailsService) 在登录页面添加复选框 12/*name必须叫remember-me，因为security内部封装了只识别这个名字的方法*/&lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; title=&quot;自动登录&quot;&gt; 自动登录 13.csrf防护 默认开启的，了解就行","categories":[],"tags":[]},{"title":"OpenFeign学习记录","slug":"OpenFeign-md","date":"2021-03-16T08:48:18.000Z","updated":"2021-03-23T05:07:06.550Z","comments":true,"path":"2021/03/16/OpenFeign-md/","link":"","permalink":"http://yoursite.com/2021/03/16/OpenFeign-md/","excerpt":"","text":"Feign声明式服务调用1.什么是feign Feign是SpringCloud Netflix 组件中的一个轻量级RESTful的HTTP服务客户端，实现了负载均衡和Rest调用的开源框架，封装了Ribbon和RestTemplate，实现了WebService的面向接口编程，进一步降低了项目的耦合度。 Feign内置了Ribbon，用来做客户端负载均衡调用服务注册中心的服务。 Feign本身并不支持SpringMVC的注解，他有一套自己的注解，为了更方便的使用，Spring Cloud孵化了OpenFeign。 Feign是一种声明式、模板化的HTTP客户端（仅在Consumer中使用） Feign支持的注解和用法请参考官方文档 Feign的使用方式是：使用Feign的注解定义接口，调用这个接口，就可以调用注册中心的服务 2.Feign解决了什么问题 Feign旨在使编写JAVA HTTP 客户端变得更容易，Feign简化了Rest Template代码，实现了Ribbon负载均衡，是代码变得更加简洁，也少了客户端调用的代码，使用Feign实现负载均衡是首选方案。只需要你创建一个接口，然后在上面添加注解即可。 Feign是声明式服务调用组件，其核心就是：像调用本地方法一样调用远程方法，无感知远程HTTP请求。 它解决了让开发者调用远程接口就跟调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求，无需关注与远程的交互细节，更无需关注分布式环境开发。 它像Dubbo一样 ，Consumer直接调用Provider接口方法，而不需要通过常规的Http Client狗仔请求再解析返回数据。 3.Feign vs Open Feign OpenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequestMapping、@Pathvariable等等。 OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用服务。 4.Feign入门案例Feign的使用主要分为一下几个步骤： 服务消费者添加Feign依赖； 创建业务层接口，添加@FeignClient注解声明要调用的服务； 业务层抽象方法使用SpringMVC注解来配置服务地址及参数 启动类添加@EnableFeignClient注解激活Feign组件 5.Feign实例项目 先创建一个空项目 然后分别创建两个eureka注册中心 eureka-server 添加eureka依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; 编写配置文件 1234567891011121314spring: application: name: eureka-server #应用名称server: port: 8761eureka: instance: hostname: eureka01 #主机名 prefer-ip-address: true instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125; #ip:port client: #设置服务注册中心地址，指向另一个注册中心 service-url: #注册中心对外暴露的注册地址 defaultZone: http://localhost:8762/eureka/ eureka-server02 同上，配置文件修改一下端口和注册地址 1234567891011121314spring: application: name: eureka-server #应用名称server: port: 8762eureka: instance: hostname: eureka02 #主机名 prefer-ip-address: true instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125; #ip:port client: #设置服务注册中心地址，指向另一个注册中心 service-url: #注册中心对外暴露的注册地址 defaultZone: http://localhost:8761/eureka/ 在创建两个服务端并注册到注册中心去，待会供我们的消费者使用 service-provider 添加依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt; 编写配置文件 12345678910111213 spring: application: name: service-provider server: port: 7070 eureka: instance: prefer-ip-address: true instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125; client: service-url: defaultZone: http://localhost:8761/eureka/,http://localhost:8762/eureka/ #将其分别注册进两个注册中心中 编写bean 1234567891011121314151617package com.feign.serviceprovider.bean;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;@Data@NoArgsConstructor@AllArgsConstructorpublic class Product implements Serializable &#123; private Integer id; private String productName; private Integer productNum; private Double productPrice;&#125; 编写service 接口 123456789package com.feign.serviceprovider.service;import com.feign.serviceprovider.bean.Product;import java.util.List;public interface ProductService &#123; List&lt;Product&gt; getPro();&#125; impl 12345678910111213141516171819package com.feign.serviceprovider.service.impl;import com.feign.serviceprovider.bean.Product;import com.feign.serviceprovider.service.ProductService;import org.springframework.stereotype.Service;import java.util.Arrays;import java.util.List;@Servicepublic class ProductServiceImpl implements ProductService &#123; @Override public List&lt;Product&gt; getPro() &#123; return Arrays.asList(new Product(1,&quot;华为手机-7070&quot;,2,5000.00), new Product(2,&quot;苹果手机&quot;,3,6900.00), new Product(3,&quot;一加手机&quot;,2,4999.99) ); &#125;&#125; 编写控制器 12345678910111213141516package com.feign.serviceprovider.controller;import com.feign.serviceprovider.service.ProductService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class ProductController &#123; @Autowired ProductService productService;@GetMapping(&quot;/getPro&quot;) public Object getPro()&#123; return productService.getPro(); &#125;&#125; service-provider02 同上除了配置文件端口和实现类输出的信息 最后创建我们的消费者远程调用服务端 service-consumer 添加依赖 12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt; 编写配置文件 1234567891011spring: application: name: service-providerserver: port: 9090eureka: client: service-url: defaultZone: http://localhost:8761/eureka/,http://localhost:8762/eureka/ register-with-eureka: false #是否将自己注册到注册中心，默认为true registry-fetch-interval-seconds: 10 #表示Eureka Client间隔多久去服务器拉取注册信息，默认为30秒 编写bean Order 123456789101112131415161718package com.feign.serviceconsumer.bean;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.util.List;@Data@AllArgsConstructor@NoArgsConstructorpublic class Order implements Serializable &#123; private Integer id; private String orderNo; private String orderAddress; private Double totalPrice; private List&lt;Product&gt; productList;&#125; Product 12345678910111213141516import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;@Data@NoArgsConstructor@AllArgsConstructorpublic class Product implements Serializable &#123; private Integer id; private String productName; private Integer productNum; private Double productPrice;&#125; service层 Product 接口 12345678910111213package com.feign.serviceconsumer.service;import com.feign.serviceconsumer.bean.Product;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import java.util.List;@FeignClient(&quot;SERVICE-PROVIDER&quot;) //绑定在注册中心名为SERVICE-PROVIDER的服务端public interface ProductService &#123; @GetMapping(&quot;/getPro&quot;) List&lt;Product&gt; getPro();&#125; Order 接口 12345678package com.feign.serviceconsumer.service;import com.feign.serviceconsumer.bean.Order;public interface OrderService &#123; Order selectOrderById(Integer id);&#125; impl 123456789101112131415161718package com.feign.serviceconsumer.service.impl;import com.feign.serviceconsumer.bean.Order;import com.feign.serviceconsumer.service.OrderService;import com.feign.serviceconsumer.service.ProductService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class OrderServiceImpl implements OrderService &#123; @Autowired ProductService productService; @Override public Order selectOrderById(Integer id) &#123; return new Order(id,&quot;order-001&quot;,&quot;中国&quot;,2222.00,productService.getPro()); &#125;&#125; controller层 12345678910111213141516171819package com.feign.serviceconsumer.controller;import com.feign.serviceconsumer.bean.Order;import com.feign.serviceconsumer.service.OrderService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class OrderController &#123; @Autowired private OrderService orderService; @GetMapping(&quot;/getOrder/&#123;id&#125;&quot;) public Order getOrder(@PathVariable(&quot;id&quot;) Integer id)&#123; return orderService.selectOrderById(id); &#125;&#125; springboot启动类 123456789101112131415package com.feign.serviceconsumer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableFeignClients //告诉框架扫描所有通过注解@FeignClient定义的feign客户端public class ServiceConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceConsumerApplication.class, args); &#125;&#125; 效果图：分别为第一次访问和第二次访问，feign自带负载均衡配置项，会依次访问两个服务端 6.feign负载均衡的配置 feign负载均衡默认是轮询的，目前feign3.0.1好像配置没有，里面没有内置ribbonjar包 123SERVICE-PROVIDER: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule com.netflix.loadbalancer.RandomRule #配置规则 随机，几个提供者间随机访问 com.netflix.loadbalancer.RoundRobinRule #配置规则 轮询，轮流访问 com.netflix.loadbalancer.RetryRule #配置规则 重试，在一段时间内通过RoundRobinRule选择服务实例，一段时间内没有选择出服务则线程终止 com.netflix.loadbalancer.WeightedResponseTimeRule #配置规则 响应时间权重，根据平均响应时间来计算权重 com.netflix.loadbalancer.BestAvailableRule #配置规则 最空闲连接策略 7.feign传参 GET 使用@PathVariable注解或@RequestParam注解接收请求参数 实例 在服务提供者service-provider的接口添加一个根据id查询的方法 12345678910package com.feign.serviceprovider.service;import com.feign.serviceprovider.bean.Product;import java.util.List;public interface ProductService &#123; List&lt;Product&gt; getPro(); Product getProById(Integer id);&#125; 在impl实现这个接口 1234@Overridepublic Product getProById(Integer id) &#123; return new Product(id,&quot;冰箱&quot;,2,3000.00);&#125; 在控制器层映射这个方法 1234@GetMapping(&quot;/getProById/&#123;id&#125;&quot;)public Object getProById(@PathVariable(&quot;id&quot;) Integer id)&#123; return productService.getProById(id);&#125; 在消费者端的接口类调用这个方法 12345678import java.util.List;@FeignClient(&quot;SERVICE-PROVIDER&quot;)public interface ProductService &#123; @GetMapping(&quot;/getPro&quot;) List&lt;Product&gt; getPro(); @GetMapping(&quot;/getProById/&#123;id&#125;&quot;) Product getProById(@PathVariable(&quot;id&quot;) Integer id);&#125; 修改Order实现类，返回调用服务提供者的根据id查询方法 12345 @Override public Order selectOrderById(Integer id) &#123; return new Order(id,&quot;order-001&quot;,&quot;中国&quot;,2222.00, Arrays.asList(productService.getProById(5))); &#125; 成功调用服务提供者的根据id查询方法，效果图 post请求 使用@RequestBody注解接受请求参数 实例 在服务提供者service-provider的接口添加两个方法 123Product getProByIdPost(Integer id);Map&lt;Object,Object&gt; createPro(Product product); 在impl实现这个接口 123456789101112131415161718@Overridepublic Product getProByIdPost(Integer id) &#123; return new Product(id,&quot;洗衣机&quot;,5,3999.00);&#125;@Overridepublic Map&lt;Object, Object&gt; createPro(Product product) &#123; System.out.println(product); Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); if(product == null)&#123; map.put(&quot;code&quot;,400); map.put(&quot;msg&quot;,&quot;添加失败&quot;); return map; &#125; map.put(&quot;code&quot;,200); map.put(&quot;msg&quot;,&quot;添加成功&quot;); return map;&#125; 在控制器层映射这个方法 123456789 @PostMapping(&quot;/getProByIdPost&quot;) public Object getProByIdPost(@RequestBody Integer id)&#123; return productService.getProByIdPost(id); &#125; @PostMapping(&quot;save&quot;)//注意这里要加上@RequestBody注解，不然实现类那里获取不到product的值 public Map&lt;Object,Object&gt; save(@RequestBody Product product)&#123; return productService.createPro(product); &#125; 在消费者端的接口类调用这个方法 1234567891011@FeignClient(&quot;SERVICE-PROVIDER&quot;)public interface ProductService &#123; @GetMapping(&quot;/getPro&quot;) List&lt;Product&gt; getPro(); @GetMapping(&quot;/getProById/&#123;id&#125;&quot;) Product getProById(@PathVariable(&quot;id&quot;) Integer id); @PostMapping(&quot;/getProByIdPost&quot;) Product getProByIdPost(Integer id); @PostMapping(&quot;save&quot;) Map&lt;Object,Object&gt; createPro(Product product);&#125; 控制器层映射这两个方法 123456789@PostMapping(value = &quot;/getProPost&quot;,produces=&#123;&quot;application/json;charset=UTF-8&quot;&#125;)public Product getProPost(Integer id)&#123; return productService.getProByIdPost(id);&#125;@PostMapping(&quot;/save&quot;)public Map&lt;Object,Object&gt; save(Product product)&#123; System.out.println(product); return productService.createPro(product);&#125; 成功调用服务提供者的方法，效果图： 8.Feign性能优化 Gzip压缩 介绍：gzip是一种数据格式，采用deflate算法压缩数据；gzip是一种流行的文件压缩算法，应用十分广泛，尤其是在Linux平台。 gzip能力：当gzip压缩一个纯文本文件时，效果是非常明显的，大约可以减少70%以上的文件大小。 gzip作用：网络数据经过压缩后实际上降低了网络传输的字节数，最明显的好处就是可以加快网页加载的速度。 实例：百度用的就是gzip压缩 Accept-Encoding向服务端表示客户端支持的压缩格式，如果不发送该消息头，服务端默认是不会压缩的 服务端在收到请求后，如果发现请求头中含有Accept-Encoding字段，并且支持该类型压缩，就会对响应报文压缩之后返回给客户端，并且携带Content-Encoding：gzip消息头，表示响应报文是根据该格式进行压缩的。 客户端接收到请求后，先判断是否有Content-Encoding消息头，如果有，按照格式解压报文。否则按正常报文处理 全局配置 –目前无效，原因不详 –添加这个mime-types: “application/xhtml+xml”就好了 12345678 server: port: 9090 compression: enabled: true #是否开启压缩 #mime-types：配置压缩支持的类型。默认支持&quot;text/html&quot;, &quot;text/xml&quot;, &quot;text/plain&quot;, &quot;text/css&quot;, &quot;text/javascript&quot;,&quot;application/javascript&quot;, &quot;application/json&quot;, &quot;application/xml&quot; # mime-types: 局部配置 百度一下 HTTP连接池 将Feign的Http客户端工具修改为HttpClient 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt; &lt;version&gt;11.1&lt;/version&gt;&lt;/dependency&gt; 使用了HttpClient客户端之后，我们还可以通过Get请求传递对象参数。 服务提供者新增方法 接口 1Product savePro(Product product); impl 12345@Overridepublic Product savePro(Product product) &#123; System.out.println(product); return product;&#125; 控制器 1234@GetMapping(&quot;savePro&quot;)public Product savePro(@RequestBody Product product)&#123;return product;&#125; 消费者远程调用 接口 12@GetMapping(&quot;/savePro&quot;)Product savePro(Product product); 控制器 1234@GetMapping(&quot;/savePro&quot;)public Product savePro(Product product)&#123; return product;&#125; 效果图： 状态查看 –过时 请求超时 –目前Feign失效，默认1秒超时都不报错 全局 123ribbon: ConnectTimeout: 2000 ReadTimeout: 2000 局部","categories":[],"tags":[]},{"title":"apollo 学习记录","slug":"apollo-md","date":"2021-03-15T03:38:55.000Z","updated":"2021-03-23T05:13:21.468Z","comments":true,"path":"2021/03/15/apollo-md/","link":"","permalink":"http://yoursite.com/2021/03/15/apollo-md/","excerpt":"","text":"Apollo分布式配置中心1.Apollo快速开始 下载Quick Start安装包 创建ApolloPortalDB和apolloConfigDB数据库 配置数据库连接信息 123456789echoset url=&quot;localhost:3306&quot;set username=&quot;root&quot;set password=&quot;123456&quot;start &quot;configService&quot; java -Xms256m -Xmx256m -Dapollo_profile=github -Dspring.datasource.url=jdbc:mysql://%url%/ApolloConfigDB?characterEncoding=utf8 -Dspring.datasource.username=%username% -Dspring.datasource.password=%password% -Dlogging.file=.\\logs\\apollo-configservice.log -jar .\\apollo-configservice-1.3.0.jarstart &quot;adminService&quot; java -Xms256m -Xmx256m -Dapollo_profile=github -Dspring.datasource.url=jdbc:mysql://%url%/ApolloConfigDB?characterEncoding=utf8 -Dspring.datasource.username=%username% -Dspring.datasource.password=%password% -Dlogging.file=.\\logs\\apollo-adminservice.log -jar .\\apollo-adminservice-1.3.0.jarstart &quot;ApolloPortal&quot; java -Xms256m -Xmx256m -Dapollo_profile=github,auth -Ddev_meta=http://localhost:8080/ -Dserver.port=8070 -Dspring.datasource.url=jdbc:mysql://%url%/ApolloPortalDB?characterEncoding=utf8 -Dspring.datasource.username=%username% -Dspring.datasource.password=%password% -Dlogging.file=.\\logs\\apollo-portal.log -jar .\\apollo-portal-1.3.0.jar 启动Apollo配置中心，端口不能被占用 执行runApollo.bat脚本 创建一个Apollo项目 创建需要的配置 创建完成后用Idea测试，创建一个spring boot项目 引入依赖 123456&lt;dependency&gt; &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt; &lt;artifactId&gt;apollo-client&lt;/artifactId&gt; &lt;version&gt;1.8.0&lt;/version&gt; &lt;/dependency&gt; 指定配置项目的id 环境 和地址 1-Dapp.id&#x3D;apollo-quick -Denv&#x3D;DEV -Ddev_meta&#x3D;http:&#x2F;&#x2F;localhost:8080 测试类进行测试 1234567891011121314151617181920@Slf4j@SpringBootTestclass Project7ApplicationTests &#123; @Test void contextLoads() &#123; Config appConfig = ConfigService.getAppConfig(); //获取配置对象 //Apollo是热发布的，实时更新，使用方法测试 while (true)&#123; try &#123; Thread.sleep(1000); //获取配置信息，第一个参数：配置的key，第二个参数：默认值 String sms = appConfig.getProperty(&quot;sms&quot;, null); log.info(&quot;sms: &quot;+sms); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 2.Apollo核心概念1.application(应用)​ 就是实际使用配置的应用，Apollo客户端在运行时需要知道当前应用是谁从而可以去获取对应的配置 关键字：appId 2.environment（环境）配置对应的环境，Apollo客户端在运行时需要知道当前应用处于哪个环境，从而可以去获取应用的配置 关键字：env 3.cluster（集群）一个应用下不同实例的分组，比如典型的可以按照数据中心分。把上海机房的应用实例分为一个集群，把北京机房的应用实例分为另一个集群。 关键字：cluster 4.namespace(命名空间)一个应用下不同配置的分组，可以简单的把namespace类比为文件，不同类型的配置放在不同的文件中，如数据库配置文件，RPC配置文件，应用自身的配置文件等。 关键字：namespace 他们的关系图： 3.Apollo项目管理1.基础设置 添加部门 Apollo主页 –&gt; 管理员工具 –&gt; 系统参数 查询配置信息：organizations然后在返回的json数据中添加 添加用户 Apollo主页 –&gt; 管理员工具 –&gt; 用户管理 删除项目 Apollo主页 –&gt; 管理员工具 –&gt; 删除应用，集群 2.添加Namespace 快捷导入配置 复制配置放入文本中 获取namespace的配置 1234567891011121314151617181920@Slf4j@SpringBootTestclass Project7ApplicationTests &#123; @Test void contextLoads() &#123;// Config appConfig = ConfigService.getAppConfig(); 获取默认namespace下的配置信息 //获取指定namespace下的配置信息 Config appConfig = ConfigService.getConfig(&quot;apollo-redis&quot;); while (true)&#123; try &#123; Thread.sleep(1000); String sms = appConfig.getProperty(&quot;spring.redis.host&quot;, null); log.info(&quot;spring.redis.host: &quot;+sms); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 4.springboot集成Apollo1.使用@value注解获取 获取默认namespace的值 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt; &lt;artifactId&gt;apollo-client&lt;/artifactId&gt; &lt;version&gt;1.8.0&lt;/version&gt; &lt;/dependency&gt; 编写Apollo相关的配置 12app.id=apollo-quickapollo.meta=http://localhost:8080 使用controller进行测试 123456789101112@EnableApolloConfig //@RestControllerpublic class apolloController &#123; @Value(&quot;$&#123;mysql&#125;&quot;) //获取key为mysql的配置 private String name; @GetMapping(&quot;/mysql&quot;) public Object getapollo()&#123; return &quot;mysql&quot;+name; &#125;&#125; 获取指定namespace的值1234567891011121314@RestController@EnableApolloConfig(&quot;redis&quot;) //指定namespace名称public class redisController &#123; @Value(&quot;$&#123;spring.redis.host&#125;&quot;) private String redisHost; @Value(&quot;$&#123;spring.redis.client-type&#125;&quot;) private String redisType; @GetMapping(&quot;/redis&quot;) public Object getRedis()&#123; return &quot;redis连接地址： &quot;+redisHost+&quot;redis类型： &quot;+redisType; &#125;&#125; 2.使用bean注入的方式获取 bean 12345678@Component@ConfigurationProperties(&quot;spring.redis&quot;) //添加之后自动识别此前缀下的配置@Datapublic class ApolloConfig &#123; private String host; //加上前缀对应配置中心的key private String client_type;&#125; controller 123456789101112@RestController@EnableApolloConfig(&quot;redis&quot;)public class BeanController &#123; @Autowired ApolloConfig apolloConfig; @GetMapping(&quot;/redisBean&quot;) public Object getRedisBean()&#123; return apolloConfig; &#125;&#125; bean注入不会自动刷新，使用@RefreshScope注解12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; 自动刷新配置类1234567891011121314151617181920212223@Componentpublic class RefreshConfig &#123; @Autowired ApolloConfig apolloConfig; @Autowired RefreshScope refreshScope; @ApolloConfigChangeListener(&#123;&quot;redis&quot;&#125;) public void onChange(ConfigChangeEvent configChangeEvent)&#123; boolean configChange = false; for(String cKey : configChangeEvent.changedKeys())&#123; if (cKey.startsWith(&quot;spring.redis&quot;))&#123; configChange = true; break; &#125; &#125; if (!configChange)&#123; return; &#125; refreshScope.refresh(&quot;apolloConfig&quot;); &#125;&#125; bean12345678@Component@ConfigurationProperties(&quot;spring.redis&quot;)@Data@RefreshScopepublic class ApolloConfig &#123; private String host; private String client_type;&#125; 目前会报错 还没找到原因，记录一下12Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.http.converter.HttpMessageConversionException: Type definition error: [simple type, class org.springframework.context.expression.StandardBeanExpressionResolver]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class org.springframework.context.expression.StandardBeanExpressionResolver and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: com.project.project7.config.ApolloConfig$$EnhancerBySpringCGLIB$$7b737735[&quot;targetSource&quot;]-&gt;org.springframework.aop.target.SimpleBeanTargetSource[&quot;beanFactory&quot;]-&gt;org.springframework.beans.factory.support.DefaultListableBeanFactory[&quot;beanExpressionResolver&quot;])] with root cause 3.灰度发布 获取方式也是用@value，跟一一样 5.Apollo的高可用","categories":[],"tags":[]},{"title":"linux 学习记录","slug":"Linux-md","date":"2021-03-15T03:36:55.000Z","updated":"2021-03-15T04:39:33.691Z","comments":true,"path":"2021/03/15/Linux-md/","link":"","permalink":"http://yoursite.com/2021/03/15/Linux-md/","excerpt":"","text":"Linux学习记录一、Linux基础篇1.Linux介绍 Linux是一款操作系统，免费，开源，安全，高效，处理高并发非常强悍，现在很多的企业级项目都部署到Linux服务器上。 2.Linux的目录结构​ Linux的文件系统是采用层级式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下在创建其他的目录。 深刻理解Linux树状文件目录是非常重要的，在Linux世界中，一切皆文件 目录结构的具体介绍 Linux目录总结 Linux的目录中有且只有一个根目录/ Linux的各个目录存放的内容都是规划好的，不能乱放文件 Linux是以文件的形式管理我们的设备，因此Linux系统，一切皆为文件 Linux的各个文件目录下存放什么内容，必须要有一个认识 学习后，脑海中应该有一颗Linux目录树 3.Linux远程操作 我用Windows10安装Ubuntu桌面子系统每次连接都要重启xrdp服务 1sudo &#x2F;etc&#x2F;init.d&#x2F;xrdp restart 4.ubuntu设置中文 下载中文语音包 1sudo apt-get install language-pack-zh-han* 设置中文 1export LC_ALL=zh_CN.UTF-8 输入locale 将显示出来的内容备份 12345678CC.UTF-8en_US.utf8POSIXzh_CN.utf8zh_HK.utf8zh_SG.utf8zh_TW.utf8 二、Linux实操篇1.使用Xshell远程连接 使用Xshell远程连接,然后发现他说无法连接 12Connecting to 192.168.100.104:22...Could not connect to &#39;192.168.100.104&#39; (port 22): Connection failed. ping了一下网络是能ping通的 1ping 192.168.100.104 然后关闭防火墙说报错 然后在终端查看ssh进程，输入ps -e|grep ssh，如果有安装openssh-client只会出现ssh -agent，不会出现sshd 要想开放本机SSH服务以便其他系统登陆访问，就必须安装openssh-server；在终端中输入sudo apt-get install openssh-server，然后输入自己的root密码就可以了； 然后启动ssh-server服务即可 验证是否开启成功，出现sshd表示开启成功 然后xshell连接又出现密码框为灰色的问题 然后百度说服务器端设置问题，输入vi /etc/ssh/sshd_config修改sshd配置文件（要用root权限修改）将图中的属性改为yes(打开文件输入s进入编辑模式，按Esc退出编辑模式，在末尾输入：wq保存并退出) 然后在重新启动sshd服务 1sudo /etc/init.d/ssh restart 2.远程上传下载文件Xftp5 xftp5是一款基于Windows平台的功能强大的SFTP、FTP文件传输软件。使用了Xftp以后，Windows用户能安全的在UNIX/Linux和WindowsPC之间传输文件。 3.vi 和vim编辑器 vi和vim的三种常用模式 正常模式 在正常模式下我们可以使用快捷键。以vim打开一个档案就直接进入一般模式了（这是默认的模式）。在这个模式中，你可以使用【上下左右】按键来移动光标，你可以使用【删除字符】和【删除整行】来处理档案内容，也可以使用【复制、粘贴】来处理你的文件数据 编辑模式 在模式下，可以输入内容 按下i，s等字母后会进入编辑模式，一般来说按i即可 命令行模式 这个模式，可以使用相关命令，完成读取，存盘，替换，离开vim，显示行号等动作 :q是退出，:wq是保存并退出，:q!是不保存并退出，:wq！是保存并强制退出 vi 和 vim快捷键 的使用案例 拷贝当前行 yy，拷贝当前行向下的n行 nyy，并粘贴(p) 删除当前行 dd 删除当前行向下的n行 ndd 在文档中查找某个单词 【命令行下 /关键字，回车查找，输入n查找下一个 N查找上一个】 设置文件的行号 || 取消文件的行号 【命令行下 :set nu || :set nonu】 快捷到文档末行 G 首行 gg 撤销 u 类似于Ctrl+Z 导航到第N行 shift+g 第一步：显示行号:set nu 第二步：输入n 第三步：输入Shift+g 4.开机、重启、和用户登录注销 关机&amp;重启命令 shutdown shutdown -h now:表示立即关机 shutdown -h 1：表示一分钟后关机 shutdown -r now:立即重启 halt （直接使用，效果等价于关机） reboot(就是重启系统) syn ：把内存的数据同步到磁盘（我们关机或重启时，先执行，把内存写入磁盘，防止数据丢失） 用户登录与注销 登录时尽量少用root账号登录，root是最高权限，避免失误，可以利用普通用户登录，登陆后再用”su -用户名”命令来切换成系统管理员身份 在提示符下输入logout即可注销用户 5.用户管理1.说明 Linux系统就是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先像系统管理员申请一个账号，然后以这个账号的身份进入系统。 Linux的用户需要至少要属于一个组。 2.添加用户 添加用户 useradd –添加用户不用输入密码 注：在Ubuntu下不会创建用户目录，需要用useradd -m adduser –添加用户需要输入密码 在Ubuntu下也会创建用户目录 useradd -d 目录 新用户：–给新建的用户添加目录 注：在Ubuntu下也不会创建文件夹 useradd -g 用户组 用户名 ：–添加用户时指定用户组 passwd 用户名 ：给用户设置密码 3.删除用户 userdel 用户名 只删除用户 userdel -r 用户名 注：会同用户目录一起删除 4.查询用户信息 id 用户名：–查询用户 5.切换用户 su - 用户名：–切换用户 exit ：–返回到上一个用户 注意：从权限高的用户切换到权限低的用户，不需要输入密码，反之需要 6.用户组 –类似于角色，系统可以对又共性的多个用户统一管理 groupadd 组名 ：–添加组 groupdel 组名：–删除组 usermod -g 用户组 用户名：–修改用户的组 7.用户和组的相关文件 /etc/passwd文件 用户的配置文件，记录用户的各种信息 每行的含义：用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录shell /etc/shadow文件 口令的配置文件 每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志 /etc/group文件 组配置文件，记录所有的组信息 每行含义：组名：口令：组标识号：组内用户列表 8.实用指令（Ubuntu系统不一样） 运行级别说明，常用运行级别是3和5，要修改默认的运行级别可改文件/etc/inittab的id：5：initdefault这一行中的数字 init[012356] :–切换到指定运行级别 面试题：找回root密码 9.帮助指令 当我们对某个指令不熟悉时，我们可以使用Linux提供的帮助指令来了解这个指令的使用方法。 man 命令或配置文件 ：– 获得帮助信息 help 命令 ： –获得shell内置命令的帮助信息 10.文件目录类的指令 pwd :–显示当前目录的绝对路径 ls ：–显示目录 ls -l ：–以列表的方式显示信息 ls -al：–显示所有的文件和目录 cd的几种用法 cd 绝对路径 ：–去到当前路径 cd&amp;cd~ ：–回到家目录 cd - 返回上一个工作目录 cd .. 返回上一级目录 mkdir指令用于创建目录 mkdir 要创建的目录（/home/aa） ：–创建一个目录 mkdir -p 要创建的目录（/home/aa/bb）：–创建多级目录 rmdir 不能删除非空目录 rmdir 要删除的目录：–删除一个空目录 rm -rf 要删除的目录 ：–可以删除非空目录 touch 文件名称 ：–创建空文件（可创建多个，用空格隔开） cp指令用法 cp 要拷贝的文件 粘贴的目录 ：–拷贝单个文件夹 cp -r 要拷贝的文件 粘贴的目录 ：–可以拷贝整个文件夹 \\cp 强制覆盖 rm删除指令用法 rm 要删除的文件 ：–删除单个文件 rm -r 要删除的文件：–可以删除整个文件夹 rm -f 要删除的文件：–强制删除不提示 不加-r也只能删文件 mv移动文件指令用法 mv 旧文件名 新文件名 ：–将文件重命名 mv 文件名 要移动的目录 ：–将文件移动到指定的目录下 cat指令用法（以只读的方式打开文件） cat 要查看的文件 : –查看文件 cat -n 要查看的文件：–查看文件并显示行号 cat -n 要查看的文件 |more ：–查看文件并分页 按空格翻页 more指令（以全屏幕的方式按页显示文本文件的内容） less指令（跟more效果一样，比more功能强大，不是一次加载全部内容，而是根据显示需要加载内容，对于显示大文件具有较高的效率） &gt;（输出重定向） 和 &gt;&gt;（追加）指令 ls -l &gt; 文件 ：–将前面的内容写入到后面的文件中（覆盖写） ls -l &gt;&gt; 文件 ：–将前面的内容追加到后面的文件中 cat 文件1 &gt; 文件2 ：–将文件1的内容覆盖到文件2中 echo 内容 &gt;&gt; 文件 将内容追加到文件中 echo 输出内容 ：输出内容到控制台 head指令 head用于显示文件开头部分的内容，默认显示前10行 head 文件 ：–查看头10行内容 head -5 文件 ： –查看前五行内容 tail指令的用法 tail 文件 ：–查看文件后10行 tail -5 文件 ：–查看文件后5行 tail -f 文件 ：–实时监控文件 有更新就会看到 ln指令（相当于Windows的快捷方式） ln -s 原文件或目录 软链接名 ： –给原文件创建一个软链接相当于快捷方式 rm -rf 软链接名 ：–删除软链接 注意 ：我们用软链接去到root目录后，用pwd查看，发现还是在软链接所在的目录 history指令用法 （查看历史执行过的指令） history ：–显示所有的历史指令 history 10 ：–显示最近的10个指令 ！n ：–执行编号为n的指令（注：是直接执行，不是查看） 11.时间日期类的指令 date时间指令用法 date ：–显示当前时间 date +%Y ：–显示当前年份 date +%m ：–显示当前月份 date +%d ：–显示当前是哪一天 date “+%Y-%m-%d %H:%M:%S” :–显示年月日时分秒 date -s 字符串时间 ：–设置系统时间 cal日历指令 cal ：–显示本月日历 cal 年份 ：–显示指定年份的日历 12.搜索查找类的指令 find指令用法 find 搜索范围（不加默认在当前文件夹下） -name 文件名 ：–查找指定文件名的文件 find 搜索范围 -user 用户名 ：–查找指定用户名的所有文件 find 搜索范围 -size （+/-/等于不写）文件大小（兆：M KB：k）：– 查找指定文件大小的文件 locate指令用法 介绍：locate数据库实现快速定位给定的文件，查询速度较快 由于locate指令基于数据库进行查询，所有第一次查询前，必须使用updatedb指令创建locate数据库 locate 文件名 ：–快速查找指定的文件 bug记录：当我执行updatedb指令时，弹出下图问题，说未找到命令’updatedb’，但可以与以下命令一起安装：安装第二个个指令就能用了 grep指令和管道符号| 介绍：grep过滤查找，管道符，”|“：表示将前一个命令的处理结果输出传递给后面的命令处理 cat 文件名 | grep -n 查找的内容 :–打开指定文件名的文件由管道符|交给后面的过滤指令过滤出指定内容并显示行号，不加-n不显示，区分大小写 cat 文件名 | grep -ni 查找的内容 :–打开指定文件名的文件由管道符|交给后面的过滤指令过滤出指定内容并显示行号，不加-n不显示，不区分大小写 12.压缩和解压缩指令 gzip/gunzip指令 注：使用gzip压缩文件后，不会保留原来的文件 gzip 文件 ：–压缩文件 gunzip 文件.gz : –解压缩文件 zip/unzip指令 zip -r（不加只能压缩单个文件） xxx.zip 要压缩的内容 ：–压缩文件和目录 unzip -d（不加默认解压到当前目录） 解压的目录 xxx.zip ：–解压缩文件 出现下图提示就是没安装zip安装一下就好了 tar打包指令 打包后的文件是.tar.gz的文件 tar -zcvf xxx.tar.gz 需要打包的文件 ：–打包文件，可以是目录也可以是多个文件 tar -zxvf 需要解压的文件：–解压文件到当前目录 tar -zxvf 需要解压的文件 -C 解压后的目录 ：–解压文件到指定的目录 13.组管理和权限管理（P35）","categories":[],"tags":[]},{"title":"SpringBoot 知识汇总","slug":"Springboot2-md","date":"2021-03-07T10:25:55.000Z","updated":"2021-03-23T05:15:27.454Z","comments":true,"path":"2021/03/07/Springboot2-md/","link":"","permalink":"http://yoursite.com/2021/03/07/Springboot2-md/","excerpt":"","text":"一.容器功能1.底层注解@Configuration详解@Configuration：告诉springboot这是一个配置类 == 配置文件 ， 配置类本身也是组件 @Bean：给容器中添加组件。以方法名作为组件id，返回类型是组件类型，返回的值就是组件在容器中的实列 == proxyBeanMethods：代理bean的方法 实战作用 配置类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断 配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式 12345678910111213141516171819202122/** * 1.proxyBeanMethods:代理bean的方法 * Full：(proxyBeanMethods = turn) 全模式 * Lite：(proxyBeanMethods = false) 轻量级模式 * 组件依赖 */@Configuration(proxyBeanMethods = true)public class Myconfig &#123; @Bean public Users users()&#123; Users user = new Users(&quot;张三&quot;,20); //users组件依赖了pet组件 user.setPet(pet()); return user; &#125; @Bean public Pet pet() &#123; return new Pet(&quot;旺财&quot;); &#125;&#125; 12345678910111213141516171819202122232425@Autowired ApplicationContext ioc; //获取ioc容器 @Test void contextLoads() &#123; //查看容器中的组件 String[] names = ioc.getBeanDefinitionNames(); for(String name : names)&#123; System.out.println(name); &#125; //从容器中获取组件 Pet tom01 = ioc.getBean(&quot;pet&quot;,Pet.class); Pet tom02 = ioc.getBean(&quot;pet&quot;,Pet.class); System.out.println(&quot;组件：&quot;+(tom01 == tom02)); //com.project5.project5.config.Myconfig$$EnhancerBySpringCGLIB$$193ccc23@440eaa07 Myconfig myconfig = ioc.getBean(Myconfig.class); System.out.println(&quot;myconfig&quot;+myconfig); //如果@Configuration(proxyBeanMethods = true) 代理对象调用方法。Spring Boot总会检查这个组件是否存在容器中 //保持组件单实例 Users user = myconfig.users(); Users user1 = myconfig.users(); System.out.println(user == user1); Users user01 = ioc.getBean(&quot;users&quot;,Users.class); Pet tom = ioc.getBean(&quot;pet&quot;,Pet.class); System.out.println(&quot;用户的宠物&quot;+(user01.getPet() == tom)); &#125; 2.@Import注解1@Import(&#123;Users.class, DBHelper.class&#125;) 3.@Conditional@Conditional：条件装配，满足Conditional指定的条件，则进行组件注入 4.@ImportResource@ImportResource(“classpath:beans.xml”)导入spring的配置文件，使其生效 5.配置绑定（1）@Component + @ConfigurationProperties12345@Component //将组件加入到容器中，只有在容器中的组件，才能得到springBoot的强大支持@ConfigurationProperties(prefix = &quot;mycat&quot;) //将配置文件中前置为mycat的配置加载到组件中public class Cat &#123; private String name; private Integer money; （2）@ConfigurationProperties + @EnableConfigurationProperties12@EnableConfigurationProperties(Cat.class) //开启Cat配置绑定功能，把Cat这个组件自动注册到容器中public class Myconfig &#123; 二.自动配置原理1.引导加载自动配置类(1)SpringBootApplication由下面几个注解组成1234567891011@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;) ​ (1.1).@SpringBootConfiguration ​ @Configuration : 代表当前是一个配置类 （1.2）@ComponentScan ​ 指定扫描哪些，spring注解； （1.3）@EnableAutoConfiguration123@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; ​ (1.3.1) @AutoConfigurationPackage 自动配置包？指定了默认的包规则 1234@Import(&#123;Registrar.class&#125;) //给容器中导入一个组件public @interface AutoConfigurationPackage &#123; //利用Registrar给容器中导入一系列组件 //将指定的一个包下的所有组件导进来？主程序所在的包下 （1.3.2）@Import({AutoConfigurationImportSelector.class}) ​ 1234561.利用this.getAutoConfigurationEntry(annotationMetadata);方法，给容器中批量导入一些组件2.调用List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);获取到所有需要导入到容器中的组件3.利用工厂加载Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader)得到所有组件4.从META-INF/spring.factories位置来加载一个文件。 默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件 spring-boot-autoconfigure-2.4.3RELEASE.jar里面也有META-INF/spring.factories 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134文件里写死了spring-boot一启动就要给容器中加载的所有配置类路径 spring-boot-autoconfigure-2.4.3RELEASE.jar/META-INF/spring.factories# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.neo4j.Neo4jAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\org.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\\org.springframework.boot.autoconfigure.r2dbc.R2dbcTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration 2.按需开启自动配置项 虽然我们130个场景的所有自动配置启动的时候默认全部加载。 按照条件装配规则（@Conditional），最终会按需加载。 3.修改默认配置SpringBoot默认会在底层配置好所有的组件。但是如果用户自己配置了以用户的优先。 123@Bean @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() &#123; 总结： SpringBoot先加载所有的自动配置类 xxxxAutoConfiguration 每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。 xxxxProperties里面拿 ，xxxxproperties和配置文件进行了绑定 生效的配置类会给容器中装配很多组件 只要容器中有这些组件，相当于这些功能有了 只要用户有自己配置的，就以用户的优先 定制化配置 用户直接自己@Bean替换底层的组件 用户去看这个组件是获取的配置文件什么值就去修改 xxxxAutoConfiguration —&gt;组件 —&gt;xxxxProperties里面拿值 —&gt;application.properties 4.最佳实践 引入场景依赖 https://docs.spring.io/spring-boot/docs/2.4.3/reference/html/using-spring-boot.html#using-boot-starter 查看自动配置了哪些 自己分析，引入场景对应的自动配置一般都生效了 配置文件中debug=true开启自动配置报告。Negative（不生效）\\Positive（生效） 是否需要修改 参照文档修改配置项 https://docs.spring.io/spring-boot/docs/2.4.3/reference/html/appendix-application-properties.html#common-application-properties 自己分析，xxxxproperties绑定了配置文件的哪些 自定义加入或者替换组件 @Bean、@Component。。。 自定义器 xxxxCustomizer …… 三、开发小技巧1.Lombok​ 简化JavaBean的开发,先导入依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 然后在Idea里下载Lombok插件就可以使用了 12345678@NoArgsConstructor //无参构造器@AllArgsConstructor //全参构造器@ToString //重写tostring方法@Data //get set方法public class Pet &#123; private String name;&#125;//Lombok还提供了@Slf4j日志注解 log.info(&quot;打印日志&quot;) 2.dev-tools 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; Ctrl+F9 四、配置文件springboot使用一个全局的配置文件，配置文件名是固定的，有两种格式​ 1.application.properties​ 2.application.yml配置文件的作用：修改spring boot自动配置的默认值；spring boot在底层都给我们配置好的； yaml语法1.基本语法K:(空格)V : 表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只有是左对齐的一列数据，都是一个层级的；属性和值也是大小写敏感的； 2.值的写法字面量：普通的值（数字，字符串，布尔）k: v : 字面直接来写； ​ 字符串默认不用加上单引号或者双引号 “”：双引号； 不会转义字符串里面的特殊字符；特殊字符会作为本身想要表达的意思 name：”zhangsan \\n lisi”：输出zhangsan 换行 lisi ‘’:单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 name：”zhangsan \\n lisi”：输出zhangsan \\n lisi 对象、Map（属性和值）（键值对）：k: v ：在下一行来写对象的属性和值的关系；注意缩进；对象还是k:v的方式 123friends: lastName: zhangsan age: 20 ​ 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List,Set)用-值表示数组中的一个元素 12345pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3.配置文件注入application.yml: 123456789101112person: name: 张三 age: 18 isboy: true birth: 2017/09/09 map: k1: v1 list: - l1 dog: name: 小狗 age: 2 JavaBean： @configurationProperties:将配置文件中的每一个属性值，映射到这个实体类中 prefix=”person” ： 将配置文件中person下面的所以属性进行一一映射 1234567891011@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String name; private Integer age; private Boolean isboy; private Date birth; private Map&lt;String,Object&gt; map; private List&lt;Object&gt; list; private Dog dog; 配置文件处理器，以后编写配置就有提示 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; application.properties中文乱码问题 打开设置 进入 file encoding 更改Properties Files 的编码为UTF-8,并且勾上Transparent native-to-ascii conversation @ConfigurationProperties和@value的区别 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个值定 松散语法 支持 不支持 SpEL 不支持 支持 JSR303数据检验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值 如果说，我们只是在某个业务逻辑中获取配置文件中的某项值，使用@Value 如果我们专门写了一个JavaBean来和配置文件进行映射，我们就直接使用ConfigurationProperties; 3.配置文件数据检验@Validated 4.@PropertySource/ImportResource@PropertySource:加载指定的配置文件； 1@PropertySource(value=&#123;&quot;classpath:person.properties&quot;&#125;) @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； 12@ImportResource(locations = &quot;classpath:beans.xml&quot;)导入spring配置文件使其生效 SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1.配置类======Spring配置文件 2.使用@Bean给容器中添加组件 123456789@Configurationpublic class helloConfig &#123; @Bean public HelloService helloService()&#123; System.out.println(&quot;添加组件&quot;); return new HelloService(); &#125;&#125; 5.配置文件占位符1.随机数 12$&#123;random.value&#125;,$&#123;random.int&#125;,$&#123;random.long&#125;$&#123;random.int(10)&#125;,$&#123;random.int[1024,65536]&#125; 2.占位符获取之前配置的值，如果没有是可以用：指定默认值 123456789#person.name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.isboy=falseperson.birth=2020/02/02person.map.k1=v1person.list=l1person.dog.name=$&#123;person.name:李四&#125;小狗person.dog.age=2 6.Profile1.多Profile文件 我们在主配置文件编写的时候，文件名可以是application-{Profile}.properties/yml 默认使用application.properties的配置 2.yml支持多文档块方式 123456789101112131415server: port: 8080spring: profiles: active: dev---server: port: 8081spring: profiles: dev---server: port: 8082spring: profiles: prod #指定属于哪个环境 3.激活指定profile 1spring.profiles.active=prod @profile @Profile也可以标在配置类上，整个类只有在指定的生产环境下才能生效 命令行激活（可以修改配置文件任意值,以命令行优先）： 1java -jar project1-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod --person.name=hello 可以直接在测试的时候，配置传入命令行参数–spring.profiles.active=prod 虚拟机参数： -Dspring.profiles.active=prod 7.配置文件加载位置 spring boot启动时会扫描以下位置的application.properties或者application.yml文件作为spring boot的默认配置文件 -file（项目文件）:/config/ -file:/ -classpath(resource):/config/ -classpath:/ 优先级由高到低，高优先级的会覆盖低优先级的配置； springboot会从这四个位置全部加载成主配置文件；互补配置 我们还可以通过spring.config.location来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认的这些配置文件共同起作用形成互补配置；（springboot2.4.3实测没有互补） 8.外部配置加载顺序springboot也可以从以下位置加载配置；优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置 1.命令行参数 java -jar project4-0.0.1-SNAPSHOT.jar –server.port=8086 –server.servlet.context-path=/abc 多个配置用空格分开 –配置项=值 2.来自java：comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 由jar包外向jar包内进行寻找； 优先加载带profile的 6.jar包外部的application-{profiles}.properties或application.yml（带spring.profile）配置文件 7.jar包内部的application-{profiles}.properties或application.yml（带spring.profile）配置文件 8.jar包外部的application.properties或application.yml（不带spring.profile）配置文件 9.jar包内部的application.properties或application.yml（不带spring.profile）配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； [参考官方文档]( 五、web开发（源码以后再看）1、SpringMVC自动配置概览Spring Boot provides auto-configuration for Spring MVC that works well with most applications.(大多场景我们都无需自定义配置) The auto-configuration adds the following features on top of Spring’s defaults: Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 内容协商视图解析器和BeanName视图解析器 Support for serving static resources, including support for WebJars (covered later in this document)). 静态资源（包括webjars） Automatic registration of Converter, GenericConverter, and Formatter beans. 自动注册 Converter，GenericConverter，Formatter Support for HttpMessageConverters (covered later in this document). 支持 HttpMessageConverters （后来我们配合内容协商理解原理） Automatic registration of MessageCodesResolver (covered later in this document). 自动注册 MessageCodesResolver （国际化用） Static index.html support. 静态index.html 页支持 Custom Favicon support (covered later in this document). 自定义 Favicon Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). 自动使用 ConfigurableWebBindingInitializer ，（DataBinder负责将请求数据绑定到JavaBean上） If you want to keep those Spring Boot MVC customizations and make more MVC customizations (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. 不用@EnableWebMvc注解。使用 @Configuration + WebMvcConfigurer 自定义规则 If you want to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, and still keep the Spring Boot MVC customizations, you can declare a bean of type WebMvcRegistrations and use it to provide custom instances of those components. 声明 WebMvcRegistrations 改变默认底层组件 If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc, or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration as described in the Javadoc of @EnableWebMvc. 使用 @EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管SpringMVC 2.简单功能分析2.1静态资源访问静态资源目录只要将静态资源放在类路径下： called /static (or /public or /resources or /META-INF/resources 访问：当前项目根路径/+静态资源名 原理：静态映射/**。 请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面。 静态资源访问前缀默认无前缀 1234spring: mvc: static-path-pattern: /res/** webjar自动映射 /webjars/** https://www.webjars.org/ 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 访问地址：http://localhost:8080/webjars/jquery/3.5.1/jquery.js 后面地址要按照依赖里面的包路径 2.2、欢迎页支持2.3、自定义 Favicon2.4、静态资源配置原理25集 3、请求参数处理1、rest使用与原理 @xxxMapping； Rest风格支持（使用*HTTP*请求方式动词来表示对资源的操作） 以前：**/getUser 获取用户 /deleteUser 删除用户 /editUser 修改用户 /saveUser 保存用户 现在： /user GET-**获取用户 DELETE-**删除用户 PUT-**修改用户 POST-**保存用户 核心Filter；HiddenHttpMethodFilter 用法： 表单method=post，隐藏域 _method=put 123456789101112131415161718192021222324252627282930313233&lt;h1&gt;测试rest风格&lt;/h1&gt;&gt;&lt;form action=&quot;/user&quot; method=&quot;get&quot; &gt; &lt;input type=&quot;submit&quot; value=&quot;GET&quot;&gt;&lt;/form&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot; &gt; &lt;input type=&quot;submit&quot; value=&quot;POST&quot;&gt;&lt;/form&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot; &gt; &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;PUT&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;PUT&quot;&gt;&lt;/form&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot; &gt; &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;DELETE&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;DELETE&quot;&gt;&lt;/form&gt; //controller: @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET) public Object get()&#123; return &quot;GET&quot;; &#125; @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST) public Object post()&#123; return &quot;POST&quot;; &#125; @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT) public Object put()&#123; return &quot;PUT&quot;; &#125; @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE) public Object delete()&#123; return &quot;DELETE&quot;; &#125; - SpringBoot中手动开启 12345spring: mvc: hiddenmethod: filter: enabled: true 扩展：如何把_method 这个名字换成我们自己喜欢的。 REST原理：26集 2.请求映射原理28集 2、普通参数与基本注解1.1、注解：@PathVariable(路径变量)、@RequestHeader(获取请求头)、@ModelAttribute()、@RequestParam(获取请求参数)、@MatrixVariable(矩阵变量)31集，@CookieValue(获取cookie值)、@RequestBody(获取请求体[post])、@RequestAttribute(获取request域属性) 1.2、Servlet API：WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId 1.3、复杂参数：Map、Model（map、model里面的数据会被放在request的请求域 request.setAttribute）、Errors/BindingResult、RedirectAttributes（ 重定向携带数据）、ServletResponse（response）、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder 3.thymeleaf4.拦截器123456789public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; HttpSession session = request.getSession(); if(session.getAttribute(&quot;user&quot;) != null)&#123; return true; &#125; return false; &#125; 123456@Configurationpublic class LoginConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/login.html&quot;,&quot;/loginUser&quot;); &#125; 5.文件上传6.异常处理7.Web原生组件注入（servlet，Filter，Listener）六、数据访问1.整合druid数据源1.1自定义方式1.2使用官方starter方式2.整合Mybatis2.1、配置模式 导入mybatis-starter 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt; &lt;/dependency&gt; 创建全局配置文件和mapper映射文件 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;/configuration&gt;#全局配置文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;#mapper映射文件 在yaml配置文件中配置mybatis规则 123mybatis: config-location: classpath:mybatis/mybatis-config.xml #mybatis全局配置文件位置 mapper-locations: classpath:mybatis/mapper/*.xml #mapper配置文件位置 编写mapper接口和service业务类 3、整合Mybatis-Plus 引入Mybatis-Plus依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;Latest Version&lt;/version&gt; &lt;/dependency&gt; 配置数据库相关的配置 123456#datasource的父级是springdatasource: url: jdbc:mysql://localhost:3306/book username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver 在 Spring Boot 启动类中添加 @MapperScan 注解，扫描 Mapper 文件夹： 1@MapperScan(&quot;com.project.project6.mapper&quot;) 编写实体类，mapper接口，以及业务逻辑层 实体类 1234567891011121314@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; @TableField(exist = false) //代表表中不存在的字段 private String username; @TableField(exist = false) private String password; private Long id; private String name; private Integer age; private String email;&#125; mapper接口 12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; //继承Mybatis-Plus提供的BaseMapper接口。 业务逻辑层 service12public interface UserService extends IService&lt;User&gt; &#123;&#125; //继承Mybatis-Plus提供的IService接口。 serviceImpl123@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService &#123;&#125; //继承Mybatis-Plus提供的ServiceImpl接口。 分页使用 导入分页插件 1234567891011121314@Configurationpublic class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125; @Bean public ConfigurationCustomizer configurationCustomizer() &#123; return configuration -&gt; configuration.setUseDeprecatedExecutor(false); &#125;&#125; 测试 12345@GetMapping(&quot;/user&quot;) public Object getUser(@RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;)Integer pn)&#123; Page&lt;User&gt; page = new Page&lt;User&gt;(pn,2); return userService.page(page); &#125; 4.整合Redis 导入依赖并编写配置文件 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; //redis依赖 &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; //jedis依赖 12345redis: host: 127.0.0.1 //redis地址 password: 123456 //密码 port: 6379 //端口号 client-type: jedis //工厂类型 注入StringRedisTemplate组件来操作redis 1234@Autowired StringRedisTemplate stringRedisTemplate;@Autowired RedisConnectionFactory redisConnectionFactory; //查看当前连接工厂 调用opsForValue方法来进行操作 1234567@Test void contextLoads() &#123; ValueOperations&lt;String, String&gt; operations = stringRedisTemplate.opsForValue(); operations.set(&quot;hello&quot;,&quot;world&quot;); operations.get(&quot;hello&quot;); System.out.println(redisConnectionFactory.getClass()); //使用jedis连接工厂 &#125; 2.使用redis实现统计功能 编写一个拦截器，请求一次就统计一次 123456789101112@Componentpublic class RedisConfig implements HandlerInterceptor &#123; @Autowired StringRedisTemplate stringRedisTemplate; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String uri = request.getRequestURI(); ValueOperations&lt;String, String&gt; operations = stringRedisTemplate.opsForValue(); operations.increment(uri); //默认每次访问uri就会+1 return true; &#125;&#125; 123456789101112@Configurationpublic class LoginConfig implements WebMvcConfigurer &#123; @Autowired RedisConfig redisConfig; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()) .addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/login.html&quot;,&quot;/loginUser&quot;); registry.addInterceptor(redisConfig).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/login.html&quot;,&quot;/loginUser&quot;); &#125;&#125; controller测试 1234567891011@Autowired StringRedisTemplate stringRedisTemplate; @GetMapping(&quot;main.html&quot;) public String totle(Model model)&#123; ValueOperations&lt;String, String&gt; operations = stringRedisTemplate.opsForValue(); String cat = operations.get(&quot;/cat&quot;); String city = operations.get(&quot;/city&quot;); model.addAttribute(&quot;cat&quot;,cat); model.addAttribute(&quot;city&quot;,city); return &quot;index.html&quot;; &#125; 七、单元测试1、JUnit5 的变化Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库 作为最新版本的JUnit框架，JUnit5与之前版本的Junit框架有很大的不同。由三个不同子项目的几个不同模块组成。 JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage JUnit Platform: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。 JUnit Jupiter: JUnit Jupiter提供了JUnit5的新的编程模型，是JUnit5新特性的核心。内部 包含了一个测试引擎，用于在Junit Platform上运行。 JUnit Vintage: 由于JUint已经发展多年，为了照顾老的项目，JUnit Vintage提供了兼容JUnit4.x,Junit3.x的测试引擎。 注意： SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖。如果需要兼容junit4需要自行引入（不能使用junit4的功能 @Test） JUnit 5’s Vintage Engine Removed from spring-boot-starter-test,如果需要继续兼容junit4需要自行引入vintage 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; **** 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 现在版本： 123456789@SpringBootTestclass Boot05WebAdminApplicationTests &#123; @Test void contextLoads() &#123; &#125;&#125; 以前： @SpringBootTest + @RunWith(SpringTest.class) SpringBoot整合Junit以后。 编写测试方法：@Test标注（注意需要使用junit5版本的注解） Junit类具有Spring的功能，@Autowired、比如 @Transactional 标注测试方法，测试完成后自动回滚 2、JUnit5常用注解 JUnit5的注解与JUnit4的注解有所变化 https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations @Test :表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试 @ParameterizedTest :表示方法是参数化测试，下方会有详细介绍 @RepeatedTest :表示方法可重复执行，下方会有详细介绍 @DisplayName :为测试类或者测试方法设置展示名称 @BeforeEach :表示在每个单元测试之前执行 @AfterEach :表示在每个单元测试之后执行 @BeforeAll :表示在所有单元测试之前执行 @AfterAll :表示在所有单元测试之后执行 @Tag :表示单元测试类别，类似于JUnit4中的@Categories @Disabled :表示测试类或测试方法不执行，类似于JUnit4中的@Ignore @Timeout :表示测试方法运行如果超过了指定时间将会返回错误 @ExtendWith :为测试类或测试方法提供扩展类引用 12345678910import org.junit.jupiter.api.Test; //注意这里使用的是jupiter的Test注解！！public class TestDemo &#123; @Test @DisplayName(&quot;第一次测试&quot;) public void firstTest() &#123; System.out.println(&quot;hello world&quot;); &#125; 3、断言（assertions） 断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法。JUnit 5 内置的断言可以分成如下几个类别： 检查业务逻辑返回的数据是否合理。 所有的测试运行结束以后，会有一个详细的测试报告； 1、简单断言 用来对单个值进行简单的验证。如： 方法 说明 assertEquals 判断两个对象或两个原始类型是否相等 assertNotEquals 判断两个对象或两个原始类型是否不相等 assertSame 判断两个对象引用是否指向同一个对象 assertNotSame 判断两个对象引用是否指向不同的对象 assertTrue 判断给定的布尔值是否为 true assertFalse 判断给定的布尔值是否为 false assertNull 判断给定的对象引用是否为 null assertNotNull 判断给定的对象引用是否不为 null 12345678910111213141516@Test@DisplayName(&quot;simple assertion&quot;)public void simple() &#123; assertEquals(3, 1 + 2, &quot;simple math&quot;); assertNotEquals(3, 1 + 1); assertNotSame(new Object(), new Object()); Object obj = new Object(); assertSame(obj, obj); assertFalse(1 &gt; 2); assertTrue(1 &lt; 2); assertNull(null); assertNotNull(new Object());&#125; 2、数组断言 通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等 12345@Test@DisplayName(&quot;array assertion&quot;)public void array() &#123; assertArrayEquals(new int[]&#123;1, 2&#125;, new int[] &#123;1, 2&#125;);&#125; 3、组合断言 assertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言 12345678@Test@DisplayName(&quot;assert all&quot;)public void all() &#123; assertAll(&quot;Math&quot;, () -&gt; assertEquals(2, 1 + 1), () -&gt; assertTrue(1 &gt; 0) );&#125; 4、异常断言 在JUnit4时期，想要测试方法的异常情况时，需要用@Rule注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式Assertions.assertThrows() ,配合函数式编程就可以进行使用。 12345678@Test@DisplayName(&quot;异常测试&quot;)public void exceptionTest() &#123; ArithmeticException exception = Assertions.assertThrows( //扔出断言异常 ArithmeticException.class, () -&gt; System.out.println(1 % 0));&#125; 5、超时断言 Junit5还提供了Assertions.assertTimeout() 为测试方法设置了超时时间 123456@Test@DisplayName(&quot;超时测试&quot;)public void timeoutTest() &#123; //如果测试方法时间超过1s将会异常 Assertions.assertTimeout(Duration.ofMillis(1000), () -&gt; Thread.sleep(500));&#125; 6、快速失败 通过 fail 方法直接使得测试失败 12345@Test@DisplayName(&quot;fail&quot;)public void shouldFail() &#123; fail(&quot;This should fail&quot;);&#125; 4、前置条件（assumptions）JUnit 5 中的前置条件（assumptions【假设】）类似于断言，不同之处在于不满足的断言会使得测试方法失败，而不满足的前置条件只会使得测试方法的执行终止。前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。 1234567891011121314151617181920@DisplayName(&quot;前置条件&quot;)public class AssumptionsTest &#123; private final String environment = &quot;DEV&quot;; @Test @DisplayName(&quot;simple&quot;) public void simpleAssume() &#123; assumeTrue(Objects.equals(this.environment, &quot;DEV&quot;)); assumeFalse(() -&gt; Objects.equals(this.environment, &quot;PROD&quot;)); &#125; @Test @DisplayName(&quot;assume then do&quot;) public void assumeThenDo() &#123; assumingThat( Objects.equals(this.environment, &quot;DEV&quot;), () -&gt; System.out.println(&quot;In DEV&quot;) ); &#125;&#125; assumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。 5、嵌套测试JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@DisplayName(&quot;A stack&quot;)class TestingAStackDemo &#123; Stack&lt;Object&gt; stack; @Test @DisplayName(&quot;is instantiated with new Stack()&quot;) void isInstantiatedWithNew() &#123; new Stack&lt;&gt;(); &#125; @Nested @DisplayName(&quot;when new&quot;) class WhenNew &#123; @BeforeEach void createNewStack() &#123; stack = new Stack&lt;&gt;(); &#125; @Test @DisplayName(&quot;is empty&quot;) void isEmpty() &#123; assertTrue(stack.isEmpty()); &#125; @Test @DisplayName(&quot;throws EmptyStackException when popped&quot;) void throwsExceptionWhenPopped() &#123; assertThrows(EmptyStackException.class, stack::pop); &#125; @Test @DisplayName(&quot;throws EmptyStackException when peeked&quot;) void throwsExceptionWhenPeeked() &#123; assertThrows(EmptyStackException.class, stack::peek); &#125; @Nested @DisplayName(&quot;after pushing an element&quot;) class AfterPushing &#123; String anElement = &quot;an element&quot;; @BeforeEach void pushAnElement() &#123; stack.push(anElement); &#125; @Test @DisplayName(&quot;it is no longer empty&quot;) void isNotEmpty() &#123; assertFalse(stack.isEmpty()); &#125; @Test @DisplayName(&quot;returns the element when popped and is empty&quot;) void returnElementWhenPopped() &#123; assertEquals(anElement, stack.pop()); assertTrue(stack.isEmpty()); &#125; @Test @DisplayName(&quot;returns the element when peeked but remains not empty&quot;) void returnElementWhenPeeked() &#123; assertEquals(anElement, stack.peek()); assertFalse(stack.isEmpty()); &#125; &#125; &#125;&#125; 6、参数化测试参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。 利用@ValueSource等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。 **** @ValueSource: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型 @NullSource: 表示为参数化测试提供一个null的入参 @EnumSource: 表示为参数化测试提供一个枚举入参 @CsvFileSource：表示读取指定CSV文件内容作为参数化测试入参 @MethodSource：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流) 当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现ArgumentsProvider接口，任何外部文件都可以作为它的入参。 1234567891011121314151617181920@ParameterizedTest@ValueSource(strings = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)@DisplayName(&quot;参数化测试1&quot;)public void parameterizedTest1(String string) &#123; System.out.println(string); Assertions.assertTrue(StringUtils.isNotBlank(string));&#125;@ParameterizedTest@MethodSource(&quot;method&quot;) //指定方法名@DisplayName(&quot;方法来源参数&quot;)public void testWithExplicitLocalMethodSource(String name) &#123; System.out.println(name); Assertions.assertNotNull(name);&#125;static Stream&lt;String&gt; method() &#123; return Stream.of(&quot;apple&quot;, &quot;banana&quot;);&#125; 7、迁移指南在进行迁移的时候需要注意如下的变化： 注解在 org.junit.jupiter.api 包中，断言在 org.junit.jupiter.api.Assertions 类中，前置条件在 org.junit.jupiter.api.Assumptions 类中。 把@Before 和@After 替换成@BeforeEach 和@AfterEach。 把@BeforeClass 和@AfterClass 替换成@BeforeAll 和@AfterAll。 把@Ignore 替换成@Disabled。 把@Category 替换成@Tag。 把@RunWith、@Rule 和@ClassRule 替换成@ExtendWith。 八、指标监控1、SpringBoot Actuator1、简介未来每一个微服务在云上部署以后，我们都需要对其进行监控、追踪、审计、控制等。SpringBoot就抽取了Actuator场景，使得我们每个微服务快速引用即可获得生产级别的应用监控、审计等功能。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 2、1.x与2.x的不同 3、如何使用 引入场景 访问 http://localhost:8080/actuator/** 暴露所有监控信息为HTTP 123456management: endpoints: enabled-by-default: true #暴露所有端点信息 web: exposure: include: &#x27;*&#x27; #以web方式暴露 测试 http://localhost:8080/actuator/beans http://localhost:8080/actuator/configprops http://localhost:8080/actuator/metrics http://localhost:8080/actuator/metrics/jvm.gc.pause http://localhost:8080/actuator/endpointName/detailPath。。。。。。 4、可视化https://github.com/codecentric/spring-boot-admin 编写一个服务器项目，专门用来监控客户端 然后导入依赖 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;/dependency&gt; #可视化工具依赖，需搭配web依赖使用 在主程序上编写@EnableAdminServer 123456789@EnableAdminServer@SpringBootApplicationpublic class ProjectadminserviceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProjectadminserviceApplication.class, args); &#125;&#125; 端口号不能与客户端一致 在客户端引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;/dependency&gt; 在编写配置文件和服务器项目对应 123456789spring boot: admin: client: url: http://localhost:8081 #对应服务器端项目的端口 instance: prefer-ip: true #使用IP注册进来，不然注册进去的会是电脑名字 application: name: project6 #表明当前项目名 实例化页面 一个六边形代表一个项目，12m表示运行了12分钟 2、Actuator Endpoint1、最常使用的端点 ID 描述 auditevents 暴露当前应用程序的审核事件信息。需要一个AuditEventRepository组件。 beans 显示应用程序中所有Spring Bean的完整列表。 caches 暴露可用的缓存。 conditions 显示自动配置的所有条件信息，包括匹配或不匹配的原因。 configprops 显示所有@ConfigurationProperties。 env 暴露Spring的属性ConfigurableEnvironment flyway 显示已应用的所有Flyway数据库迁移。 需要一个或多个Flyway组件。 health 显示应用程序运行状况信息。 httptrace 显示HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应）。需要一个HttpTraceRepository组件。 info 显示应用程序信息。 integrationgraph 显示Spring integrationgraph 。需要依赖spring-integration-core。 loggers 显示和修改应用程序中日志的配置。 liquibase 显示已应用的所有Liquibase数据库迁移。需要一个或多个Liquibase组件。 metrics 显示当前应用程序的“指标”信息。 mappings 显示所有@RequestMapping路径列表。 scheduledtasks 显示应用程序中的计划任务。 sessions 允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。 shutdown 使应用程序正常关闭。默认禁用。 startup 显示由ApplicationStartup收集的启动步骤数据。需要使用SpringApplication进行配置BufferingApplicationStartup。 threaddump 执行线程转储。 如果您的应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点： ID 描述 heapdump 返回hprof堆转储文件。 jolokia 通过HTTP暴露JMX bean（需要引入Jolokia，不适用于WebFlux）。需要引入依赖jolokia-core。 logfile 返回日志文件的内容（如果已设置logging.file.name或logging.file.path属性）。支持使用HTTPRange标头来检索部分日志文件的内容。 prometheus 以Prometheus服务器可以抓取的格式公开指标。需要依赖micrometer-registry-prometheus。 最常用的Endpoint Health：监控状况 Metrics：运行时指标 Loggers：日志记录 2、Health Endpoint健康检查端点，我们一般用于在云平台，平台会定时的检查应用的健康状况，我们就需要Health Endpoint可以为平台返回当前应用的一系列组件健康状况的集合。 重要的几点： health endpoint返回的结果，应该是一系列健康检查后的一个汇总报告 很多的健康检查默认已经自动配置好了，比如：数据库、redis等 可以很容易的添加自定义的健康检查机制 123endpoint: health: show-details: always //开启详细的健康检查报告 3、Metrics Endpoint提供详细的、层级的、空间指标信息，这些信息可以被pull（主动推送）或者push（被动获取）方式得到； 通过Metrics对接多种监控系统 简化核心Metrics开发 添加自定义Metrics或者扩展已有Metrics 4、管理Endpoints1、开启与禁用Endpoints 默认所有的Endpoint除过shutdown都是开启的。 需要开启或者禁用某个Endpoint。配置模式为 management.endpoint.****.enabled = true 1234management: endpoint: beans: enabled: true 或者禁用所有的Endpoint然后手动开启指定的Endpoint 12345678management: endpoints: enabled-by-default: false endpoint: beans: enabled: true health: enabled: true 2、暴露Endpoints支持的暴露方式 HTTP：默认只暴露health和info Endpoint JMX：默认暴露所有Endpoint 除过health和info，剩下的Endpoint都应该进行保护访问。如果引入SpringSecurity，则会默认配置安全访问规则 ID JMX Web auditevents Yes No beans Yes No caches Yes No conditions Yes No configprops Yes No env Yes No flyway Yes No health Yes Yes heapdump N/A No httptrace Yes No info Yes Yes integrationgraph Yes No jolokia N/A No logfile N/A No loggers Yes No liquibase Yes No metrics Yes No mappings Yes No prometheus N/A No scheduledtasks Yes No sessions Yes No shutdown Yes No startup Yes No threaddump Yes No 3.定制化Endpoints1.定制health信息1234567891011121314151617181920212223@Componentpublic class MyHealthIndicator extends AbstractHealthIndicator &#123; @Autowired StringRedisTemplate stringRedisTemplate; /** * 真实的检查方法 * @param builder * @throws Exception */ @Override protected void doHealthCheck(Health.Builder builder) throws Exception &#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); if(stringRedisTemplate!=null)&#123; builder.status(Status.UP); //健康 map.put(&quot;msg&quot;,&quot;redis导入成功&quot;); &#125;else &#123; builder.status(Status.DOWN); //不健康 map.put(&quot;error&quot;,&quot;redis导入失败&quot;); &#125; builder.withDetail(&quot;code&quot;,&quot;100&quot;); builder.withDetails(map); &#125;&#125; 2.定制info yaml配置文件方式 12345info: appName: Project6 hello: world mavenProjectName: @project.artifactId@ #使用@@可以获取maven的pom文件值 mavenVersoin: @project.version@ 配置类方式 12345678@Componentpublic class AppInfoInfoContributor implements InfoContributor &#123; @Override public void contribute(Info.Builder builder) &#123; builder.withDetail(&quot;redis实例&quot;,&quot;redis实例化成功&quot;) .withDetail(&quot;Redis工厂类型&quot;,&quot;jedis&quot;); &#125;&#125; 3.定制Metrics信息123456789101112131415161718@Servicepublic class CityServiceImpl implements CityService &#123; @Autowired CityMapper cityMapper; Counter counter; public CityServiceImpl(MeterRegistry meterRegistry)&#123; counter = meterRegistry.counter(&quot;CityServiceImpl.getCity.count&quot;); &#125; @Override public City getCity() &#123; counter.increment(); return cityMapper.getCity(); &#125;&#125; 4.定制Endpoint123456789101112131415@Component@Endpoint(id = &quot;myService&quot;)public class MyServiceEndPoint &#123; @Autowired CityService cityService; @ReadOperation public Object getCity()&#123; return cityService.getCity(); &#125; @WriteOperation public void stopCity()&#123; System.out.println(&quot;停止访问&quot;); &#125;&#125; 九、自定义Starter 创建一个空工程 在工厂中创建两个模块 上面是maven模块来编写场景启动器，给别人引用 /下面是springboot模块负责编写自动配置相关的东西。 在场景启动器中引入自动配置的依赖 12345678910&lt;groupId&gt;com.project&lt;/groupId&gt; &lt;artifactId&gt;project-hello-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.project&lt;/groupId&gt; &lt;artifactId&gt;project-hello-spring-boot-starter-autoconfigure&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 删除自动配置里面没用的东西 pom.xml文件里面只留下spring-boot-starter即可 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 删掉项目里没有的类和配置文件（蓝色背景的都删除） 编写一个自动配置方法 service包下的PostService类 12345678910111213/** * 默认不放在容器中 */public class PostService &#123; @Autowired PostProperties postProperties; public String introDuce()&#123; return postProperties.getName()+&quot;是一个&quot;+postProperties.getPosition(); &#125;&#125; bean包下的PostProperties类 12345@ConfigurationProperties(&quot;project.post&quot;)public class PostProperties &#123; private String name; private String position;//省略get，set方法 auto包下的PostServiceAutoConfiguration类 123456789101112@Configuration@ConditionalOnMissingBean(PostService.class) //条件装配，你没有这个组件就自动注入@EnableConfigurationProperties(PostProperties.class) //默认将PostProperties放在容器中public class PostServiceAutoConfiguration &#123; @Bean public PostService postService()&#123; PostService postService = new PostService(); return postService; &#125;&#125; 编写META-INF/spring.factories中EnableAutoConfiguration 的值，使得项目启动加载指定的自动配置类** 123# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\com.project.auto.PostServiceAutoConfiguration 将模块安装到maven目录中先安装自动装配模块 在新项目中引入自定义的Starter 12345&lt;dependency&gt; &lt;groupId&gt;com.project&lt;/groupId&gt; &lt;artifactId&gt;project-hello-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 引入成功就可以使用了 1234project: post: name: 张三 position: 经理 1234567@Autowired PostService postService;@GetMapping(&quot;/introDuce&quot;) public String getIntroDuce()&#123; String s = postService.introDuce(); return s; &#125; 效果 十、SpringBoot原理（以后再看）","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2020-07-05T07:53:55.000Z","updated":"2020-07-05T07:57:02.832Z","comments":true,"path":"2020/07/05/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2020/07/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"第一章内容 第二章内容 参考文献www.baidu.com","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-07-05T07:46:57.970Z","updated":"2020-07-05T07:46:57.970Z","comments":true,"path":"2020/07/05/hello-world/","link":"","permalink":"http://yoursite.com/2020/07/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}