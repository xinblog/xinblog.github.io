[{"title":"linux 学习记录","url":"/2021/03/15/Linux-md/","content":"Linux学习记录一、Linux基础篇1.Linux介绍\nLinux是一款操作系统，免费，开源，安全，高效，处理高并发非常强悍，现在很多的企业级项目都部署到Linux服务器上。\n\n2.Linux的目录结构​    Linux的文件系统是采用层级式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下在创建其他的目录。\n深刻理解Linux树状文件目录是非常重要的，在Linux世界中，一切皆文件\n\n\n目录结构的具体介绍\n\n\n\n\n\n\nLinux目录总结\nLinux的目录中有且只有一个根目录/\nLinux的各个目录存放的内容都是规划好的，不能乱放文件\nLinux是以文件的形式管理我们的设备，因此Linux系统，一切皆为文件\nLinux的各个文件目录下存放什么内容，必须要有一个认识\n学习后，脑海中应该有一颗Linux目录树\n\n\n\n3.Linux远程操作\n我用Windows10安装Ubuntu桌面子系统每次连接都要重启xrdp服务  \n\nsudo &#x2F;etc&#x2F;init.d&#x2F;xrdp restart \n\n4.ubuntu设置中文\n下载中文语音包\nsudo apt-get install language-pack-zh-han*\n\n设置中文\nexport LC_ALL=zh_CN.UTF-8\n\n输入locale 将显示出来的内容备份\nCC.UTF-8en_US.utf8POSIXzh_CN.utf8zh_HK.utf8zh_SG.utf8zh_TW.utf8\n\n\n\n二、Linux实操篇1.使用Xshell远程连接\n使用Xshell远程连接,然后发现他说无法连接\nConnecting to 192.168.100.104:22...Could not connect to &#39;192.168.100.104&#39; (port 22): Connection failed.\n\nping了一下网络是能ping通的\nping 192.168.100.104\n\n然后关闭防火墙说报错\n\n\n\n然后在终端查看ssh进程，输入ps -e|grep ssh，如果有安装openssh-client只会出现ssh -agent，不会出现sshd\n\n\n要想开放本机SSH服务以便其他系统登陆访问，就必须安装openssh-server；在终端中输入sudo apt-get install openssh-server，然后输入自己的root密码就可以了；\n\n\n\n\n然后启动ssh-server服务即可\n\n\n验证是否开启成功，出现sshd表示开启成功\n\n\n然后xshell连接又出现密码框为灰色的问题\n\n\n然后百度说服务器端设置问题，输入vi /etc/ssh/sshd_config修改sshd配置文件（要用root权限修改）将图中的属性改为yes(打开文件输入s进入编辑模式，按Esc退出编辑模式，在末尾输入：wq保存并退出)\n\n\n然后在重新启动sshd服务\nsudo /etc/init.d/ssh restart\n\n\n\n\n2.远程上传下载文件Xftp5\nxftp5是一款基于Windows平台的功能强大的SFTP、FTP文件传输软件。使用了Xftp以后，Windows用户能安全的在UNIX/Linux和WindowsPC之间传输文件。\n\n3.vi 和vim编辑器\nvi和vim的三种常用模式\n正常模式\n\n在正常模式下我们可以使用快捷键。以vim打开一个档案就直接进入一般模式了（这是默认的模式）。在这个模式中，你可以使用【上下左右】按键来移动光标，你可以使用【删除字符】和【删除整行】来处理档案内容，也可以使用【复制、粘贴】来处理你的文件数据\n\n\n编辑模式\n\n在模式下，可以输入内容\n按下i，s等字母后会进入编辑模式，一般来说按i即可\n\n\n命令行模式\n\n这个模式，可以使用相关命令，完成读取，存盘，替换，离开vim，显示行号等动作\n:q是退出，:wq是保存并退出，:q!是不保存并退出，:wq！是保存并强制退出\n\n\n\n\nvi 和 vim快捷键 的使用案例\n\n拷贝当前行  yy，拷贝当前行向下的n行  nyy，并粘贴(p)\n删除当前行  dd  删除当前行向下的n行 ndd\n在文档中查找某个单词  【命令行下 /关键字，回车查找，输入n查找下一个 N查找上一个】\n设置文件的行号 || 取消文件的行号 【命令行下   :set nu  ||   :set nonu】\n快捷到文档末行  G   首行  gg\n撤销  u  类似于Ctrl+Z\n导航到第N行   shift+g\n第一步：显示行号:set nu\n第二步：输入n\n第三步：输入Shift+g\n\n\n\n\n\n4.开机、重启、和用户登录注销\n关机&amp;重启命令\nshutdown\n\nshutdown -h now:表示立即关机\nshutdown -h 1：表示一分钟后关机\nshutdown -r now:立即重启\n\n\nhalt （直接使用，效果等价于关机）\n\nreboot(就是重启系统)\n\nsyn ：把内存的数据同步到磁盘（我们关机或重启时，先执行，把内存写入磁盘，防止数据丢失）\n\n\n\n用户登录与注销\n\n登录时尽量少用root账号登录，root是最高权限，避免失误，可以利用普通用户登录，登陆后再用”su -用户名”命令来切换成系统管理员身份\n在提示符下输入logout即可注销用户\n\n\n\n5.用户管理1.说明\nLinux系统就是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先像系统管理员申请一个账号，然后以这个账号的身份进入系统。\nLinux的用户需要至少要属于一个组。\n\n2.添加用户\n添加用户\nuseradd  –添加用户不用输入密码  注：在Ubuntu下不会创建用户目录，需要用useradd -m\nadduser  –添加用户需要输入密码 在Ubuntu下也会创建用户目录\nuseradd -d 目录  新用户：–给新建的用户添加目录 注：在Ubuntu下也不会创建文件夹\nuseradd  -g  用户组  用户名 ：–添加用户时指定用户组\n\n\npasswd  用户名  ：给用户设置密码\n\n3.删除用户\nuserdel  用户名  只删除用户\nuserdel  -r  用户名  注：会同用户目录一起删除\n\n4.查询用户信息\nid  用户名：–查询用户\n\n5.切换用户\nsu -  用户名：–切换用户  \nexit  ：–返回到上一个用户\n注意：从权限高的用户切换到权限低的用户，不需要输入密码，反之需要\n\n6.用户组  –类似于角色，系统可以对又共性的多个用户统一管理\ngroupadd  组名 ：–添加组\ngroupdel  组名：–删除组\nusermod  -g  用户组  用户名：–修改用户的组\n\n7.用户和组的相关文件\n/etc/passwd文件\n用户的配置文件，记录用户的各种信息\n每行的含义：用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录shell\n\n\n\n\n/etc/shadow文件\n口令的配置文件\n每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志\n\n\n\n\n/etc/group文件\n组配置文件，记录所有的组信息\n每行含义：组名：口令：组标识号：组内用户列表\n\n\n\n\n\n8.实用指令（Ubuntu系统不一样）\n运行级别说明，常用运行级别是3和5，要修改默认的运行级别可改文件/etc/inittab的id：5：initdefault这一行中的数字\n\n\n\ninit[012356] :–切换到指定运行级别\n\n面试题：找回root密码\n\n\n\n\n\n\n\n\n9.帮助指令\n当我们对某个指令不熟悉时，我们可以使用Linux提供的帮助指令来了解这个指令的使用方法。\nman  命令或配置文件  ：– 获得帮助信息\nhelp  命令 ： –获得shell内置命令的帮助信息\n\n10.文件目录类的指令\npwd  :–显示当前目录的绝对路径\n\nls  ：–显示目录  ls -l ：–以列表的方式显示信息  ls -al：–显示所有的文件和目录\n\ncd的几种用法\n\ncd 绝对路径 ：–去到当前路径\ncd&amp;cd~ ：–回到家目录\ncd - 返回上一个工作目录\ncd .. 返回上一级目录\n\n\nmkdir指令用于创建目录\n\nmkdir  要创建的目录（/home/aa） ：–创建一个目录\nmkdir  -p  要创建的目录（/home/aa/bb）：–创建多级目录\n\n\nrmdir 不能删除非空目录\n\nrmdir 要删除的目录：–删除一个空目录\nrm -rf 要删除的目录 ：–可以删除非空目录\n\n\ntouch 文件名称 ：–创建空文件（可创建多个，用空格隔开）\n\ncp指令用法\n\ncp 要拷贝的文件  粘贴的目录  ：–拷贝单个文件夹\ncp  -r  要拷贝的文件  粘贴的目录 ：–可以拷贝整个文件夹\n\\cp  强制覆盖\n\n\nrm删除指令用法\n\nrm  要删除的文件  ：–删除单个文件\nrm -r  要删除的文件：–可以删除整个文件夹\nrm -f  要删除的文件：–强制删除不提示  不加-r也只能删文件\n\n\nmv移动文件指令用法\n\nmv  旧文件名  新文件名  ：–将文件重命名\nmv  文件名  要移动的目录  ：–将文件移动到指定的目录下\n\n\ncat指令用法（以只读的方式打开文件）\n\ncat  要查看的文件 : –查看文件\ncat -n  要查看的文件：–查看文件并显示行号\ncat  -n  要查看的文件 |more  ：–查看文件并分页 按空格翻页\n\n\nmore指令（以全屏幕的方式按页显示文本文件的内容）\n\n\n\n\nless指令（跟more效果一样，比more功能强大，不是一次加载全部内容，而是根据显示需要加载内容，对于显示大文件具有较高的效率）\n\n\n\n\n&gt;（输出重定向）  和  &gt;&gt;（追加）指令\n\nls -l &gt; 文件  ：–将前面的内容写入到后面的文件中（覆盖写）\nls -l &gt;&gt; 文件  ：–将前面的内容追加到后面的文件中\ncat 文件1  &gt;  文件2  ：–将文件1的内容覆盖到文件2中\necho  内容  &gt;&gt;  文件  将内容追加到文件中\n\n\necho  输出内容 ：输出内容到控制台\n\nhead指令  head用于显示文件开头部分的内容，默认显示前10行\n\nhead  文件  ：–查看头10行内容\nhead -5 文件 ： –查看前五行内容\n\n\ntail指令的用法\n\ntail  文件  ：–查看文件后10行\ntail -5 文件  ：–查看文件后5行\ntail  -f  文件  ：–实时监控文件 有更新就会看到\n\n\nln指令（相当于Windows的快捷方式）\n\nln  -s  原文件或目录  软链接名  ： –给原文件创建一个软链接相当于快捷方式\nrm -rf  软链接名  ：–删除软链接\n注意 ：我们用软链接去到root目录后，用pwd查看，发现还是在软链接所在的目录\n\n\nhistory指令用法 （查看历史执行过的指令）\n\nhistory  ：–显示所有的历史指令\nhistory  10 ：–显示最近的10个指令\n！n  ：–执行编号为n的指令（注：是直接执行，不是查看）\n\n\n\n11.时间日期类的指令\ndate时间指令用法\n\ndate  ：–显示当前时间\ndate  +%Y  ：–显示当前年份\ndate  +%m  ：–显示当前月份\ndate  +%d  ：–显示当前是哪一天\ndate  “+%Y-%m-%d  %H:%M:%S”  :–显示年月日时分秒\ndate  -s  字符串时间  ：–设置系统时间\n\n\ncal日历指令\n\ncal  ：–显示本月日历\ncal  年份  ：–显示指定年份的日历\n\n\n\n12.搜索查找类的指令\nfind指令用法\n\nfind  搜索范围（不加默认在当前文件夹下）  -name  文件名  ：–查找指定文件名的文件\nfind  搜索范围  -user  用户名  ：–查找指定用户名的所有文件\nfind   搜索范围  -size  （+/-/等于不写）文件大小（兆：M  KB：k）：–  查找指定文件大小的文件\n\n\nlocate指令用法\n\n介绍：locate数据库实现快速定位给定的文件，查询速度较快\n由于locate指令基于数据库进行查询，所有第一次查询前，必须使用updatedb指令创建locate数据库\nlocate  文件名   ：–快速查找指定的文件\nbug记录：当我执行updatedb指令时，弹出下图问题，说未找到命令’updatedb’，但可以与以下命令一起安装：安装第二个个指令就能用了\n\n\n\ngrep指令和管道符号|\n\n介绍：grep过滤查找，管道符，”|“：表示将前一个命令的处理结果输出传递给后面的命令处理\ncat  文件名  |  grep  -n  查找的内容   :–打开指定文件名的文件由管道符|交给后面的过滤指令过滤出指定内容并显示行号，不加-n不显示，区分大小写\ncat  文件名  |  grep  -ni  查找的内容   :–打开指定文件名的文件由管道符|交给后面的过滤指令过滤出指定内容并显示行号，不加-n不显示，不区分大小写\n\n\n\n\n12.压缩和解压缩指令\ngzip/gunzip指令  注：使用gzip压缩文件后，不会保留原来的文件\n\ngzip  文件  ：–压缩文件\ngunzip  文件.gz  : –解压缩文件\n\n\nzip/unzip指令 \n\nzip  -r（不加只能压缩单个文件） xxx.zip  要压缩的内容  ：–压缩文件和目录\nunzip  -d（不加默认解压到当前目录） 解压的目录   xxx.zip  ：–解压缩文件\n出现下图提示就是没安装zip安装一下就好了\n\n\n\ntar打包指令  打包后的文件是.tar.gz的文件\n\ntar  -zcvf  xxx.tar.gz  需要打包的文件  ：–打包文件，可以是目录也可以是多个文件\ntar -zxvf  需要解压的文件：–解压文件到当前目录\ntar  -zxvf  需要解压的文件  -C  解压后的目录 ：–解压文件到指定的目录\n\n\n\n13.组管理和权限管理（P35）"},{"title":"OpenFeign学习记录","url":"/2021/03/16/OpenFeign-md/","content":"Feign声明式服务调用1.什么是feign\nFeign是SpringCloud Netflix 组件中的一个轻量级RESTful的HTTP服务客户端，实现了负载均衡和Rest调用的开源框架，封装了Ribbon和RestTemplate，实现了WebService的面向接口编程，进一步降低了项目的耦合度。\nFeign内置了Ribbon，用来做客户端负载均衡调用服务注册中心的服务。\nFeign本身并不支持SpringMVC的注解，他有一套自己的注解，为了更方便的使用，Spring Cloud孵化了OpenFeign。\nFeign是一种声明式、模板化的HTTP客户端（仅在Consumer中使用）\nFeign支持的注解和用法请参考官方文档\nFeign的使用方式是：使用Feign的注解定义接口，调用这个接口，就可以调用注册中心的服务\n\n2.Feign解决了什么问题\nFeign旨在使编写JAVA HTTP 客户端变得更容易，Feign简化了Rest Template代码，实现了Ribbon负载均衡，是代码变得更加简洁，也少了客户端调用的代码，使用Feign实现负载均衡是首选方案。只需要你创建一个接口，然后在上面添加注解即可。\nFeign是声明式服务调用组件，其核心就是：像调用本地方法一样调用远程方法，无感知远程HTTP请求。\n它解决了让开发者调用远程接口就跟调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求，无需关注与远程的交互细节，更无需关注分布式环境开发。\n它像Dubbo一样 ，Consumer直接调用Provider接口方法，而不需要通过常规的Http Client狗仔请求再解析返回数据。\n\n3.Feign  vs  Open Feign\nOpenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequestMapping、@Pathvariable等等。\nOpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用服务。\n\n4.Feign入门案例Feign的使用主要分为一下几个步骤：\n\n服务消费者添加Feign依赖；\n创建业务层接口，添加@FeignClient注解声明要调用的服务；\n业务层抽象方法使用SpringMVC注解来配置服务地址及参数\n启动类添加@EnableFeignClient注解激活Feign组件\n\n5.Feign实例项目\n先创建一个空项目\n\n然后分别创建两个eureka注册中心\n\neureka-server\n\n添加eureka依赖\n&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;\t\t\t&lt;version&gt;3.0.1&lt;/version&gt;\t\t&lt;/dependency&gt;\n\n编写配置文件\nspring:  application:    name: eureka-server  #应用名称server:  port: 8761eureka:  instance:    hostname: eureka01  #主机名    prefer-ip-address: true    instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;  #ip:port  client:    #设置服务注册中心地址，指向另一个注册中心    service-url:    #注册中心对外暴露的注册地址      defaultZone: http://localhost:8762/eureka/\n\n\n\neureka-server02\n\n同上，配置文件修改一下端口和注册地址\nspring:  application:    name: eureka-server  #应用名称server:  port: 8762eureka:  instance:    hostname: eureka02  #主机名    prefer-ip-address: true    instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;  #ip:port  client:    #设置服务注册中心地址，指向另一个注册中心    service-url:    #注册中心对外暴露的注册地址      defaultZone: http://localhost:8761/eureka/\n\n\n\n\n\n在创建两个服务端并注册到注册中心去，待会供我们的消费者使用\n\nservice-provider\n\n添加依赖\n&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;   &lt;artifactId&gt;lombok&lt;/artifactId&gt;   &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;   &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;   &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt;\n\n编写配置文件\n   spring:     application:       name: service-provider   server:     port: 7070   eureka:     instance:       prefer-ip-address: true       instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;     client:       service-url:         defaultZone:  http://localhost:8761/eureka/,http://localhost:8762/eureka/  #将其分别注册进两个注册中心中\n\n编写bean\npackage com.feign.serviceprovider.bean;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;@Data@NoArgsConstructor@AllArgsConstructorpublic class Product implements Serializable &#123;    private Integer id;    private String productName;    private  Integer productNum;    private  Double productPrice;&#125;\n\n编写service\n\n接口\npackage com.feign.serviceprovider.service;import com.feign.serviceprovider.bean.Product;import java.util.List;public interface ProductService &#123;    List&lt;Product&gt; getPro();&#125;\n\nimpl\npackage com.feign.serviceprovider.service.impl;import com.feign.serviceprovider.bean.Product;import com.feign.serviceprovider.service.ProductService;import org.springframework.stereotype.Service;import java.util.Arrays;import java.util.List;@Servicepublic class ProductServiceImpl implements ProductService &#123;    @Override    public List&lt;Product&gt; getPro() &#123;        return Arrays.asList(new Product(1,&quot;华为手机-7070&quot;,2,5000.00),                new Product(2,&quot;苹果手机&quot;,3,6900.00),                new Product(3,&quot;一加手机&quot;,2,4999.99)        );    &#125;&#125;\n\n\n\n编写控制器\npackage com.feign.serviceprovider.controller;import com.feign.serviceprovider.service.ProductService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class ProductController &#123;    @Autowired    ProductService productService;@GetMapping(&quot;/getPro&quot;)    public Object getPro()&#123;        return productService.getPro();    &#125;&#125;\n\n\n\nservice-provider02\n\n同上除了配置文件端口和实现类输出的信息\n\n\n\n\n最后创建我们的消费者远程调用服务端\n\nservice-consumer\n\n添加依赖\n&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;   &lt;artifactId&gt;lombok&lt;/artifactId&gt;   &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;   &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;   &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;   &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;   &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;   &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt;\n\n编写配置文件\nspring:  application:    name: service-providerserver:  port: 9090eureka:  client:    service-url:      defaultZone: http://localhost:8761/eureka/,http://localhost:8762/eureka/    register-with-eureka: false  #是否将自己注册到注册中心，默认为true    registry-fetch-interval-seconds: 10  #表示Eureka Client间隔多久去服务器拉取注册信息，默认为30秒\n\n编写bean\n\nOrder\npackage com.feign.serviceconsumer.bean;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.util.List;@Data@AllArgsConstructor@NoArgsConstructorpublic class Order implements Serializable &#123;    private Integer id;    private String orderNo;    private  String orderAddress;    private  Double totalPrice;    private List&lt;Product&gt; productList;&#125;\n\nProduct\nimport lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;@Data@NoArgsConstructor@AllArgsConstructorpublic class Product implements Serializable &#123;    private Integer id;    private String productName;    private  Integer productNum;    private  Double productPrice;&#125;\n\n\n\nservice层\n\nProduct\n\n接口\npackage com.feign.serviceconsumer.service;import com.feign.serviceconsumer.bean.Product;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import java.util.List;@FeignClient(&quot;SERVICE-PROVIDER&quot;)  //绑定在注册中心名为SERVICE-PROVIDER的服务端public interface ProductService &#123;    @GetMapping(&quot;/getPro&quot;)    List&lt;Product&gt; getPro();&#125;\n\n\n\nOrder\n\n接口\npackage com.feign.serviceconsumer.service;import com.feign.serviceconsumer.bean.Order;public interface OrderService &#123;    Order selectOrderById(Integer id);&#125;\n\nimpl\npackage com.feign.serviceconsumer.service.impl;import com.feign.serviceconsumer.bean.Order;import com.feign.serviceconsumer.service.OrderService;import com.feign.serviceconsumer.service.ProductService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class OrderServiceImpl implements OrderService &#123;    @Autowired    ProductService productService;    @Override    public Order selectOrderById(Integer id) &#123;        return new Order(id,&quot;order-001&quot;,&quot;中国&quot;,2222.00,productService.getPro());    &#125;&#125;\n\n\n\n\n\ncontroller层\npackage com.feign.serviceconsumer.controller;import com.feign.serviceconsumer.bean.Order;import com.feign.serviceconsumer.service.OrderService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class OrderController &#123;    @Autowired    private OrderService orderService;    @GetMapping(&quot;/getOrder/&#123;id&#125;&quot;)    public Order getOrder(@PathVariable(&quot;id&quot;) Integer id)&#123;        return orderService.selectOrderById(id);    &#125;&#125;\n\nspringboot启动类\npackage com.feign.serviceconsumer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableFeignClients  //告诉框架扫描所有通过注解@FeignClient定义的feign客户端public class ServiceConsumerApplication &#123;   public static void main(String[] args) &#123;      SpringApplication.run(ServiceConsumerApplication.class, args);   &#125;&#125;\n\n\n\n效果图：分别为第一次访问和第二次访问，feign自带负载均衡配置项，会依次访问两个服务端\n\n\n\n\n\n  \n6.feign负载均衡的配置\nfeign负载均衡默认是轮询的，目前feign3.0.1好像配置没有，里面没有内置ribbonjar包\nSERVICE-PROVIDER:  ribbon:    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule\n\n\n\n\n\n\ncom.netflix.loadbalancer.RandomRule #配置规则 随机，几个提供者间随机访问\ncom.netflix.loadbalancer.RoundRobinRule #配置规则 轮询，轮流访问\ncom.netflix.loadbalancer.RetryRule #配置规则 重试，在一段时间内通过RoundRobinRule选择服务实例，一段时间内没有选择出服务则线程终止\ncom.netflix.loadbalancer.WeightedResponseTimeRule #配置规则 响应时间权重，根据平均响应时间来计算权重\ncom.netflix.loadbalancer.BestAvailableRule #配置规则 最空闲连接策略\n\n7.feign传参\nGET  使用@PathVariable注解或@RequestParam注解接收请求参数\n\n实例\n\n在服务提供者service-provider的接口添加一个根据id查询的方法\npackage com.feign.serviceprovider.service;import com.feign.serviceprovider.bean.Product;import java.util.List;public interface ProductService &#123;    List&lt;Product&gt; getPro();    Product getProById(Integer id);&#125;\n\n在impl实现这个接口\n@Overridepublic Product getProById(Integer id) &#123;    return new Product(id,&quot;冰箱&quot;,2,3000.00);&#125;\n\n在控制器层映射这个方法\n@GetMapping(&quot;/getProById/&#123;id&#125;&quot;)public Object getProById(@PathVariable(&quot;id&quot;) Integer id)&#123;    return productService.getProById(id);&#125;\n\n在消费者端的接口类调用这个方法\nimport java.util.List;@FeignClient(&quot;SERVICE-PROVIDER&quot;)public interface ProductService &#123;    @GetMapping(&quot;/getPro&quot;)    List&lt;Product&gt; getPro();    @GetMapping(&quot;/getProById/&#123;id&#125;&quot;)    Product getProById(@PathVariable(&quot;id&quot;) Integer id);&#125;\n\n修改Order实现类，返回调用服务提供者的根据id查询方法\n     @Override     public Order selectOrderById(Integer id) &#123;         return new Order(id,&quot;order-001&quot;,&quot;中国&quot;,2222.00, Arrays.asList(productService.getProById(5)));     &#125;\n\n成功调用服务提供者的根据id查询方法，效果图\n\n\n\n\n\n\n\n\npost请求  使用@RequestBody注解接受请求参数\n\n实例\n\n在服务提供者service-provider的接口添加两个方法\nProduct getProByIdPost(Integer id);Map&lt;Object,Object&gt; createPro(Product product);\n\n在impl实现这个接口\n@Overridepublic Product getProByIdPost(Integer id) &#123;    return new Product(id,&quot;洗衣机&quot;,5,3999.00);&#125;@Overridepublic Map&lt;Object, Object&gt; createPro(Product product) &#123;    System.out.println(product);    Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;();    if(product == null)&#123;        map.put(&quot;code&quot;,400);        map.put(&quot;msg&quot;,&quot;添加失败&quot;);        return map;    &#125;    map.put(&quot;code&quot;,200);    map.put(&quot;msg&quot;,&quot;添加成功&quot;);    return map;&#125;\n\n在控制器层映射这个方法\n      @PostMapping(&quot;/getProByIdPost&quot;)      public Object getProByIdPost(@RequestBody Integer id)&#123;      return productService.getProByIdPost(id);      &#125;      @PostMapping(&quot;save&quot;)//注意这里要加上@RequestBody注解，不然实现类那里获取不到product的值      public Map&lt;Object,Object&gt; save(@RequestBody Product product)&#123;          return productService.createPro(product);      &#125;\n\n在消费者端的接口类调用这个方法\n@FeignClient(&quot;SERVICE-PROVIDER&quot;)public interface ProductService &#123;    @GetMapping(&quot;/getPro&quot;)    List&lt;Product&gt; getPro();    @GetMapping(&quot;/getProById/&#123;id&#125;&quot;)    Product getProById(@PathVariable(&quot;id&quot;) Integer id);    @PostMapping(&quot;/getProByIdPost&quot;)    Product getProByIdPost(Integer id);    @PostMapping(&quot;save&quot;)    Map&lt;Object,Object&gt; createPro(Product product);&#125;\n\n控制器层映射这两个方法\n@PostMapping(value = &quot;/getProPost&quot;,produces=&#123;&quot;application/json;charset=UTF-8&quot;&#125;)public Product getProPost(Integer id)&#123;    return productService.getProByIdPost(id);&#125;@PostMapping(&quot;/save&quot;)public Map&lt;Object,Object&gt; save(Product product)&#123;    System.out.println(product);    return  productService.createPro(product);&#125;\n\n成功调用服务提供者的方法，效果图：\n\n\n\n\n\n\n\n\n8.Feign性能优化\nGzip压缩\n\n介绍：gzip是一种数据格式，采用deflate算法压缩数据；gzip是一种流行的文件压缩算法，应用十分广泛，尤其是在Linux平台。\n\ngzip能力：当gzip压缩一个纯文本文件时，效果是非常明显的，大约可以减少70%以上的文件大小。\n\ngzip作用：网络数据经过压缩后实际上降低了网络传输的字节数，最明显的好处就是可以加快网页加载的速度。\n\n实例：百度用的就是gzip压缩\n\n\nAccept-Encoding向服务端表示客户端支持的压缩格式，如果不发送该消息头，服务端默认是不会压缩的\n\n服务端在收到请求后，如果发现请求头中含有Accept-Encoding字段，并且支持该类型压缩，就会对响应报文压缩之后返回给客户端，并且携带Content-Encoding：gzip消息头，表示响应报文是根据该格式进行压缩的。\n\n客户端接收到请求后，先判断是否有Content-Encoding消息头，如果有，按照格式解压报文。否则按正常报文处理\n\n\n全局配置  –目前无效，原因不详  –添加这个mime-types: “application/xhtml+xml”就好了\n  server:    port: 9090    compression:      enabled: true   #是否开启压缩      #mime-types：配置压缩支持的类型。默认支持&quot;text/html&quot;, &quot;text/xml&quot;, &quot;text/plain&quot;, &quot;text/css&quot;, &quot;text/javascript&quot;,&quot;application/javascript&quot;, &quot;application/json&quot;, &quot;application/xml&quot;  #    mime-types:\n\n局部配置\n\n百度一下\n\n\n\n\nHTTP连接池\n\n将Feign的Http客户端工具修改为HttpClient\n\n导入依赖\n&lt;dependency&gt;    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;    &lt;version&gt;11.1&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n使用了HttpClient客户端之后，我们还可以通过Get请求传递对象参数。\n\n服务提供者新增方法\n\n接口\nProduct savePro(Product product);\n\nimpl\n@Overridepublic Product savePro(Product product) &#123;    System.out.println(product);    return product;&#125;\n\n控制器\n@GetMapping(&quot;savePro&quot;)public Product savePro(@RequestBody  Product product)&#123;return product;&#125;\n\n\n\n消费者远程调用\n\n接口\n@GetMapping(&quot;/savePro&quot;)Product savePro(Product product);\n\n控制器\n@GetMapping(&quot;/savePro&quot;)public Product savePro(Product product)&#123;    return product;&#125;\n\n\n\n效果图：\n\n\n\n\n\n\n状态查看  –过时\n\n\n\n请求超时   –目前Feign失效，默认1秒超时都不报错\n\n全局\nribbon:  ConnectTimeout: 2000  ReadTimeout: 2000\n\n局部\n\n\n\n\n\n"},{"title":"Spring Security学习记录（二）进阶篇","url":"/2021/03/29/Security2-md/","content":"Spring Security学习记录（二）进阶篇1.Oauth2认证\n简介第三方认证技术方案最主要是解决认证协议的通用标准问题，因为要实现跨系统认证，各系统之间一定要遵循一定的接口协议。\nOAUTH协议为用户资源提供了一个安全的，开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、Javascript、Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如Open API，很多大公司如FGoogle，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。\nOauth协议目前发展到2.0版本，1.0版本过于复杂，2.0版本已得到广泛应用。\n\nOauth2认证流程\n\n常用术语\n\n客户凭证（client Credentials）：客户端的clientld和密码用于认证客户\n令牌（tokens）：授权服务器在接收到客户请求后，颁发的访问令牌\n作用域(scopes)：客户请求访问令牌时，由资源拥有者额外指定的细分权限（permission）\n\n\n令牌类型\n\n授权码：仅用于授权码授权类型，用于交换获取访问令牌和刷新令牌\n访问令牌：用于代表一个用户或服务直接去访问受保护的资源\n刷新令牌：用于去授权服务器获取一个刷新访问令牌\nBearerToken：不管谁拿到Token都可以访问资源，类似现金\nProof  of  Possession（PoP）  Token：可以检验client是否对Token有明确的拥有权\n\n\n特点\n\n优点\n更安全，客户端不接触用户密码，服务器端更容易集中保护\n广泛传播并被持续采用\n短寿命和封装的Token\n资源服务器和授权服务器解耦\n集中式授权，简化客户端\nHTTP/JSON友好，易于请求和传递token\n考虑多种客户端架构场景\n客户可以具有不同的信任级别\n\n\n缺点\n协议框架太宽泛，造成各种实现的兼容性和互操作行差\n不是一个认证协议，本身并不能告诉你任何用户信息\n\n\n\n\n\n2.Spring Security Oauth2\n授权服务器\n\n\nAuthorize Endpoint：授权端点，进行授权\nToken  Endpoint：令牌端点，经过授权拿到对应的Token\nIntrospection  Endpoint：校验端点，检验Token的合法性\nRevocation Endpoint：撤销端点，撤销授权\n\n\nSpring Security Oauth2架构\n\n\n流程：\n用户访问，此时没有Token。Oauth2Rest Template会报错，这个报错信息会被Oauth2ClientContextFilter捕获并重新定向到认证服务器\n认证服务器通过Authorization Endpoint进行授权，并通过AuthorizationServerTokenServices生成授权码并返回给客户端\n客户端拿到授权码去认证服务器通过Token Endpoint调用AuthorizationServerTokenServices生成Token并返回给客户端\n客户端拿到Token去资源服务器访问资源，一般会通过Oauth2AuthenticationManager调用ResourceServerTokenServices进行校验。校验通过可以获取资源。\n\n\n\n\n\n3.Springsecurity Oauth2实例3.1授权码模式\n引入相关依赖\n&lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    \t//定义spring-cloud的版本        &lt;spring-cloud.version&gt;Greenwich.SR2&lt;/spring-cloud.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        //spring-cloud整合oauth2        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;        &lt;/dependency&gt;    \t//spring-cloud整合security        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    //引入spring-cloud    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;    \t\t\t//类型                &lt;type&gt;pom&lt;/type&gt;    \t\t\t//引入的时候生效                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;\n\n定义User实体并实现security底层的UserDetails接口\npublic class User implements UserDetails &#123;    private String username;    private String password;    private List&lt;GrantedAuthority&gt; authorities;   public User(String username, String password, List&lt;GrantedAuthority&gt; authorities) &#123;        this.username = username;        this.password = password;        this.authorities = authorities;    &#125;    @Override    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;        return authorities;    &#125;    @Override    public String getPassword() &#123;        return password;    &#125;    @Override    public String getUsername() &#123;        return username;    &#125;    @Override    public boolean isAccountNonExpired() &#123;        return true;    &#125;    @Override    public boolean isAccountNonLocked() &#123;        return true;    &#125;    @Override    public boolean isCredentialsNonExpired() &#123;        return true;    &#125;    @Override    public boolean isEnabled() &#123;        return true;    &#125;&#125;\n\n编写UserService来处理用户认证\n@Servicepublic class UserService implements UserDetailsService &#123;    @Autowired    private PasswordEncoder passwordEncoder;    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;        //密码是定死的，无论输入什么用户，密码对上直接认证成功，没从数据库查       String password = passwordEncoder.encode(&quot;123456&quot;);\t\t//将用户返回，给定admin权限        return new User(username,password, AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin&quot;));    &#125;&#125;\n\n编写SecurityConfig配置类用来处理放行和拦截等配置\n@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.authorizeRequests()            //放行  /oauth/**：放行授权服务器的所有操作                .antMatchers(&quot;/oauth/**&quot;,&quot;/login/**&quot;,&quot;/logout/**&quot;)                .permitAll()            //除了放行的请求都需要认证                .anyRequest().authenticated()                .and()            //放行所有的表单请求                .formLogin().permitAll()                .and()            //关闭csrf防护                .csrf().disable();    &#125;    @Bean    public PasswordEncoder passwordEncoder() &#123;        return new BCryptPasswordEncoder();    &#125;&#125;\n\n配置授权服务器\n@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123;    @Autowired    private PasswordEncoder passwordEncoder;    @Override    public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;        //为了方便直接将客户端的信息储存到内存里了        //实际开发中需要客户端来请求授权服务器        clients.inMemory()                //客户端ID                .withClient(&quot;client&quot;)                //密钥                .secret(passwordEncoder.encode(&quot;112233&quot;))                //重定向地址                .redirectUris(&quot;http://www.baidu.com&quot;)                //授权范围                .scopes(&quot;all&quot;)                /**                 * 授权类型                 * authorization_code : 授权码模式                 */                .authorizedGrantTypes(&quot;authorization_code&quot;);    &#125;&#125;\n\n配置资源服务器\n@Configuration@EnableResourceServerpublic class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123;    @Override    public void configure(HttpSecurity http) throws Exception &#123;                http.authorizeRequests()                        .anyRequest().authenticated()                        .and()                        .requestMatchers()                        .antMatchers(&quot;/user/**&quot;);    &#125;\n\n编写controller控制器来返回资源\n@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123;    //资源控制器返回的资源，想获取资源需要有对应的令牌    @RequestMapping(&quot;/getCurrentUser&quot;)    public Object getCurrentUser(Authentication authentication)&#123;        return authentication.getPrincipal();    &#125;&#125;\n\n测试\n\n获取授权码\nhttp:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;authorize?response_type&#x3D;code&amp;client_id&#x3D;client&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;www.baidu.com&amp;scope&#x3D;all\n\n输入上面的url来到了security自带的登录页面\n\n\n登录成功后来到授权页面  Deny：不允许，Approve：允许\n\n\n授权后来到我们设定的重定向页面，后面是授权码\n\n\n根据授权码获取令牌（POST请求）\n\n\n去到图下位置，用户名和密码是之前配置的授权服务器的客户端id和密钥\n\n\n\n在去到Body里面选中x-www.form-urlencoded\n\n\ngrant_type:授权类型，填写authorization_code，表示授权码模式\ncode：授权码，就是刚刚获取的授权码，注意：授权码只能使用一次就无效了，需要重新申请\nclient_id：客户端标识\nredirect_uri：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致\nscope：授权范围\n\n\n发送请求之后得到令牌\n\n\naccess_token ：令牌\ntoken_type:  令牌类型\nscope：令牌范围\n\n\n\n\n获取令牌之后就可以去访问资源了\n\n访问的资源地址就是我们资源服务器的资源地址\n\n\n拿到刚刚得到的token放在下图位置\n\n\n访问到的资源信息\n\n\n我们把令牌改一下，然后就会报错，说我们的令牌是一个非法令牌，令牌不对是获取不了资源的\n\n\n\n\n\n\n\n3.2.密码模式\n密码模式比授权码模式简单很多，我们在授权码模式的基础上稍作调整就好了\n\n在SecurityConfig配置类新注册一个AuthenticationManager\n@Bean   public AuthenticationManager authenticationManager() throws Exception &#123;       return super.authenticationManager();   &#125;\n\n\n\n\n\n\n授权服务器里面新增一个实现方法\n/**                * 授权类型                * authorization_code : 授权码模式                * password : 密码模式                */               .authorizedGrantTypes(&quot;authorization_code&quot;,&quot;password&quot;);\n\n测试\n\n还是在下图位置输入我们的客户端id和密钥\n\n\n然后在body中输入授权类型、授权范围、用户名和密码\n\n\ngrant_type:授权类型，填写password，表示密码模式\n\nscope：授权范围\n\nusername ： 自己定义的用户名\n\npassword ： 密码\n\n\n\n发送请求之后获得令牌\n\n\n使用刚刚得到的令牌去获取资源，步骤跟授权码模式一样\n\n\n\n\n\n3.3将token存储到redis中\n引入redis相关依赖\n&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;        &lt;/dependency&gt;\n\n编写redis相关的配置\nspring.redis.port=6379spring.redis.host=127.0.0.1spring.redis.password=123456\n\n\n\n\n\n\n编写RedisConfig配置类\n@Configurationpublic class RedisConfig &#123;    @Autowired    private RedisConnectionFactory redisConnectionFactory;    @Bean    public TokenStore redisTokenStore()&#123;        return new RedisTokenStore(redisConnectionFactory);    &#125;&#125;\n\n在授权服务器中将Token令牌保存到Redis中\n   @Autowired//用Qualifier指定，不然找不到   @Qualifier(&quot;redisTokenStore&quot;)   private TokenStore tokenStore;     @Override   public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123;       endpoints.authenticationManager(authenticationManager)               .userDetailsService(userService)           //将Token令牌保存到redis中               .tokenStore(tokenStore);   &#125;\n\n测试，还是使用密码模式发送请求，请求后可以看到redis将Token令牌存起来了\n\n\n\n\n4.JWT\n常见的认证机制（详情百度）\n\nHTTP Basic Auth\nCookie Auth\nOAuth\nToken Auth\n\n\n什么是JWT\n\nJSON Web Token（JWT）是一个开放的行业标准（RFC 7519），他定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。\n官网：https://jwt.io/\n标准：https://tools.ietf.org/html/rfc7519\n\n\nJWT令牌的优点：\n\njwt基于json，非常方便解析。\n可以在令牌中自定义丰富的内容，易扩展。\n通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高\n资源服务使用JWT可不依赖认证服务即可完成授权。\n\n\n缺点：\n\nJWT令牌较长，占存储空间比较大。\n\nJWT组成\n\n一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名\n\n头部（Header）\n\n头部用于描述关于该JWT的最基本的信息，例如其类型（即JWT）以及签名所使用的算法（如HMAC SHA256或RSA）等，这也可以被表示成一个JSON对象。\n&#123;    &quot;alg&quot;: &quot;HS256&quot;,    &quot;typ&quot;: &quot;JWT&quot;&#125;\n\n\ntyp:是类型\nalg：签名的算法，这里使用的是HS256算法\n\n\n\n\n负载（Payload）\n\n第二部分是负载，就是存放有效信息的地方。这些有效信息包含三个部分\n\n标准中注册的声明（建议但不强制使用）\n\niss：jwt的签发者\nsub：jwt所面向的用户\naud：接受jwt的一方\nexp：jwt的过期时间，这个过期时间必须要大于签发时间\nnbf：定义在什么时间之前，该jwt都是不可用的\niat：jwt的签发时间\njti：jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击\n\n\n公共的声明\n\n\n\n\n\n公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可以解密。\n\n私有的声明\n\n私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息\n\n这个指的就是自定义的claim。比如下面那个举例中的name都属于自定的claim。这些claim跟JWT标准规定的claim区别在于：JWT规定的claim，JWT的接收方在拿到JWT之后，都知道怎么对这些标准的claim进行验证（还不知道是否能够验证）而private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行。\n&#123;    &quot;sub&quot;: &quot;1234567890&quot;    &quot;name&quot;: &quot;John Doe&quot;    &quot;iat&quot;: 1516239022&#125;\n其中sub是标准的声明，name是自定义的声明（公共或私有的）\n\n\n\n\n\n\n签证、签名（signature）\n\njwt的第三部分是一个签证信息，这个签证信息有三部分组成\n\nheader（base64后的）\npayload（base64后的）\n\n\nsecret（盐，一定要保密）\n\n注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所有，他就是你服务器端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret，那就意味着客户端是可以自我签发jwt了。\n\n\n\n\n5.JJWT\n什么是JJWT\n\nJJWT是一个提供到端的JWT创建和验证的Java库，永远免费和开源（Apache License，版本2.0）JJWT很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。\n\n快速入门\n\n导入依赖\n&lt;dependency&gt;            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;            &lt;version&gt;0.9.0&lt;/version&gt;        &lt;/dependency&gt;\n\n编写测试类\n@SpringBootTestpublic class JjwtDemoApplicationTests &#123;    @Test   public void contextLoads() &#123;        JwtBuilder jwtBuilder = Jwts.builder()                //唯一ID&#123;“id”：“888”&#125;                .setId(&quot;888&quot;)                //接受的用户&#123;“sub”：“Rose”&#125;                .setSubject(&quot;Rose&quot;)                //签发时间&#123;“iat”：“时间”&#125;                .setIssuedAt(new Date())                //签名算法，及密钥                .signWith(SignatureAlgorithm.HS256,&quot;abcd&quot;);        //签发token        String token = jwtBuilder.compact();        System.out.println(token);    &#125;&#125;\n\n测试结果\n\n\n在官网解析令牌\n\n\n\n\n\n\n- 也可以自己编写代码解析\n\n  System.out.println(&quot;=======================&quot;);       String[] split = token.split(&quot;\\\\.&quot;);       System.out.println(Base64Codec.BASE64.decodeToString(split[0]));       System.out.println(Base64Codec.BASE64.decodeToString(split[1]));      //这个会乱码，为了安全考虑       System.out.println(Base64Codec.BASE64.decodeToString(split[2]));\n\n- 解析效果\n\n![image-20210326172418262](image-20210326172418262.png)\n解析token\n@Test    public void testParseToken()&#123;        String token = &quot;eyJhbGciOiJIUzI1NiJ9.&quot; +                &quot;eyJqdGkiOiI4ODgiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNjE2NzUwNTk1fQ.&quot; +                &quot;rWfl8Fxzz0Lgh0qr-nchqiRpv89jRA_SXmuWLsxL-zk&quot;;        //解析token，获取Claims，jwt中荷载申明的对象        Claims claims = (Claims) Jwts.parser()                .setSigningKey(&quot;abcd&quot;)                .parse(token)                .getBody();        System.out.println(&quot;id=&quot;+claims.getId());        System.out.println(&quot;sub=&quot;+claims.getSubject());        System.out.println(&quot;iat=&quot;+claims.getIssuedAt());    &#125;\n\n效果：\n\n\n\n\ntoken过期校验\n@Test    public void contextLoadsExp() &#123;        long data = System.currentTimeMillis();        long exp = data+60*1000;        JwtBuilder jwtBuilder = Jwts.builder()                //唯一ID&#123;“id”：“888”&#125;                .setId(&quot;666&quot;)                //接受的用户&#123;“sub”：“Rose”&#125;                .setSubject(&quot;Rose&quot;)                //签发时间&#123;“iat”：“时间”&#125;                .setIssuedAt(new Date())                //设置失效时间                .setExpiration(new Date(exp))                //签名算法，及密钥                .signWith(SignatureAlgorithm.HS256,&quot;abcd&quot;);        //签发token        String token = jwtBuilder.compact();        System.out.println(token);        System.out.println(&quot;=======================&quot;);        String[] split = token.split(&quot;\\\\.&quot;);        System.out.println(Base64Codec.BASE64.decodeToString(split[0]));        System.out.println(Base64Codec.BASE64.decodeToString(split[1]));        //这个会乱码，为了安全考虑        System.out.println(Base64Codec.BASE64.decodeToString(split[2]));    &#125;    @Test    public void testParseTokenExp()&#123;        String token = &quot;eyJhbGciOiJIUzI1NiJ9.&quot; +                &quot;eyJqdGkiOiI2NjYiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNjE2OTgwODU1LCJleHAiOjE2MTY5ODA5MTV9.&quot; +                &quot;n9j9sft8JhaZc_qLBroiQHP5-TZQwzu409nIRMEdtAQ&quot;;        Claims claims = (Claims) Jwts.parser()                .setSigningKey(&quot;abcd&quot;)                .parse(token)                .getBody();        System.out.println(&quot;id=&quot;+claims.getId());        System.out.println(&quot;sub=&quot;+claims.getSubject());        System.out.println(&quot;iat=&quot;+claims.getIssuedAt());    &#125;\n\n\n\n\n\n\n当我们测试发现多了一个失效时间\n\n\n然后过一分钟解析token的时候，报错说token已经失效（前面一个时间是失效时间，第二个时间是我们解析他的时间）\n\n\n\n\n自定义Claims\n @Test    public void contextLoadsEnhancer() &#123;        long data = System.currentTimeMillis();        long exp = data+60*1000;        JwtBuilder jwtBuilder = Jwts.builder()                //唯一ID&#123;“id”：“888”&#125;                .setId(&quot;666&quot;)                //接受的用户&#123;“sub”：“Rose”&#125;                .setSubject(&quot;Rose&quot;)                //签发时间&#123;“iat”：“时间”&#125;                .setIssuedAt(new Date())                //设置失效时间//                .setExpiration(new Date(exp))                //自定义claim                .claim(&quot;name&quot;,&quot;张三&quot;)                .claim(&quot;logo&quot;,&quot;xxx.jpg&quot;)                //以map的方式自定义Claim//                .addClaims(Map);                //签名算法，及密钥                .signWith(SignatureAlgorithm.HS256,&quot;abcd&quot;);        //签发token        String token = jwtBuilder.compact();        System.out.println(token);        System.out.println(&quot;=======================&quot;);        String[] split = token.split(&quot;\\\\.&quot;);        System.out.println(Base64Codec.BASE64.decodeToString(split[0]));        System.out.println(Base64Codec.BASE64.decodeToString(split[1]));        //这个会乱码，为了安全考虑        System.out.println(Base64Codec.BASE64.decodeToString(split[2]));    &#125;    @Test    public void testParseTokenEnhancer()&#123;        String token = &quot;eyJhbGciOiJIUzI1NiJ9.&quot; +                &quot;eyJqdGkiOiI2NjYiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNjE2OTgwODU1LCJleHAiOjE2MTY5ODA5MTV9.&quot; +                &quot;n9j9sft8JhaZc_qLBroiQHP5-TZQwzu409nIRMEdtAQ&quot;;        Claims claims = (Claims) Jwts.parser()                .setSigningKey(&quot;abcd&quot;)                .parse(token)                .getBody();        System.out.println(&quot;id=&quot;+claims.getId());        System.out.println(&quot;sub=&quot;+claims.getSubject());        System.out.println(&quot;iat=&quot;+claims.getIssuedAt());        System.out.println(&quot;name=&quot;+claims.get(&quot;name&quot;));        System.out.println(&quot;logo=&quot;+claims.get(&quot;logo&quot;));    &#125;\n\n\n自定义claim测试\n\n\n\n自定义claim解析\n\n\n\n\n6.SpringSecurityOauth2集成JWT\n基于SpringSecurityOauth2实例的基础上新增一个JwtTokenStoreConfig配置类\n@Configurationpublic class JwtTokenStoreConfig &#123;    @Bean    public TokenStore jwtTokenStore()&#123;        return new JwtTokenStore(jwtAccessTokenConverter());    &#125;    @Bean    public JwtAccessTokenConverter jwtAccessTokenConverter()&#123;        JwtAccessTokenConverter jwtAccessTokenConverter = new JwtAccessTokenConverter();        //设置jwt密钥        jwtAccessTokenConverter.setSigningKey(&quot;test-key&quot;);        return jwtAccessTokenConverter;    &#125;&#125;\n\n在授权服务器将其转化成JwtToken\n@Autowired  @Qualifier(&quot;jwtTokenStore&quot;)  TokenStore tokenStore;  @Autowired  JwtAccessTokenConverter jwtAccessTokenConverter;    @Override  public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123;      endpoints.authenticationManager(authenticationManager)              .userDetailsService(userService)              //accessToken 转成JWTToken              .tokenStore(tokenStore)              .accessTokenConverter(jwtAccessTokenConverter);  &#125;\n\n测试结果\n\n这串Token相比之前的token长了很多\n\n\n\n\n\n\n6.1.扩展jwt中的存储内容\n编写一个JwtTokenEnhancerConfig编写自定义的存储内容\n@Configurationpublic class JwtTokenEnhancerConfig implements TokenEnhancer &#123;    @Override    public OAuth2AccessToken enhance(OAuth2AccessToken oAuth2AccessToken, OAuth2Authentication oAuth2Authentication) &#123;        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();        //添加自定义的存储内容        map.put(&quot;hello&quot;,&quot;wolrd&quot;);        ((DefaultOAuth2AccessToken)oAuth2AccessToken).setAdditionalInformation(map);        return oAuth2AccessToken;    &#125;\n\n在授权服务器中将自定义的存储内容添加到JwtToken中\n@AutowiredJwtAccessTokenConverter jwtAccessTokenConverter;@AutowiredJwtTokenEnhancerConfig jwtTokenEnhancerConfig;  @Overridepublic void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123;    //设置jwt增强内容    TokenEnhancerChain chain = new TokenEnhancerChain();    List&lt;TokenEnhancer&gt; delegates = new ArrayList&lt;&gt;();    delegates.add(jwtTokenEnhancerConfig);    delegates.add(jwtAccessTokenConverter);    chain.setTokenEnhancers(delegates);    endpoints.authenticationManager(authenticationManager)            .userDetailsService(userService)            //accessToken 转成JWTToken            .tokenStore(tokenStore)            .accessTokenConverter(jwtAccessTokenConverter)            .tokenEnhancer(chain)    ;&#125;\n\n测试结果\n\n\n\n6.2.解析Jwt令牌\n直接在controller里面解析\n@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @RequestMapping(&quot;/getCurrentUser&quot;)    public Object getCurrentUser(Authentication authentication,                                 HttpServletRequest request)&#123;        //获取请求头为Authorization的值        String header = request.getHeader(&quot;Authorization&quot;);        //截取令牌        String token = header.substring(header.lastIndexOf(&quot;bearer&quot;)+7);       return Jwts.parser()                .setSigningKey(&quot;test-key&quot;.getBytes(StandardCharsets.UTF_8))                .parseClaimsJws(token)                .getBody();    &#125;\n\n测试结果\n\n先获取JwtToken\n\n\n在根据令牌获取解析的JwtToken数据\n\n注意这个不要填写之前需要，现在不用了\n\n\n\n然后把刚刚拿到的JwtToken放入请求的头部信息中\n\n\n解析后的数据，可以看到我们解析的数据和官网是一样的\n)\n\n\n\n\n\n\n6.3.设置JwtToken过期时间和刷新令牌\n在授权服务器中设置JwtToken失效时间\n//授权范围           .scopes(&quot;all&quot;)           //设置失效时间           .accessTokenValiditySeconds(60)          \n\n\n一分钟后提示令牌失效，失效原因：令牌已过期\n\n\n\n\n设置刷新令牌\n\n由于令牌失效又要从头走一遍获取令牌的流程比较复杂，我们可以使用刷新令牌\n\n在授权服务器中设置刷新令牌\n/**                 * 授权类型                 * authorization_code : 授权码模式                 * password : 密码模式                 * refresh_token : 刷新令牌                 */                .authorizedGrantTypes(&quot;authorization_code&quot;,&quot;password&quot;,&quot;refresh_token&quot;);\n\n设置刷新令牌的有效时间\n//刷新令牌失效时间                .refreshTokenValiditySeconds(66666)\n\n我们可以看到访问时多了一个刷新令牌\n\n\n一分钟过后令牌过期\n\n\n使用刷新令牌去获取新的令牌\n\n\n使用刷新令牌后重新得到的令牌又有一分钟的有效时间\n\n\n\n\n\n7.SpringSecurityOauth2集成SSO（单点登录）\n创建一个客户端sso-demo\n\n导入依赖\n&lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;spring-cloud.version&gt;Greenwich.SR2&lt;/spring-cloud.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;            &lt;version&gt;0.9.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;\n\n\n\n\n\n\n编写配置文件\n#不能跟服务端一样server.port=8081#因为我们可能会有很多个客户端，防止Cookie冲突，冲突会导致验证不通过server.servlet.session.cookie.name=OAUTH2CLIENT01#授权服务器地址oauth2-server-rul: http://localhost:8080#与授权服务器对应的地址security.oauth2.client.client-id=clientsecurity.oauth2.client.client-secret=112233security.oauth2.client.user-authorization-uri=$&#123;oauth2-server-rul&#125;/oauth/authorizesecurity.oauth2.client.access-token-uri=$&#123;oauth2-server-rul&#125;/oauth/tokensecurity.oauth2.resource.jwt.key-uri=$&#123;oauth2-server-rul&#125;/oauth/token_key\n\n在启动类添加开启sso的注解\n@SpringBootApplication//开启单点登录@EnableOAuth2Ssopublic class SsoDemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SsoDemoApplication.class, args);    &#125;&#125;\n\n编写controller测试\n@RestController@RequestMapping(&quot;/user&quot;)public class SsoController &#123;    @RequestMapping(&quot;/getCurrentUser&quot;)    public Object getCurrentUser(Authentication authentication)&#123;        return authentication;    &#125;&#125;\n\n服务端还是跟之前一样，只要添加以下代码\n\n在授权服务器里重写一个方法\n@Override  public void configure(AuthorizationServerSecurityConfigurer security) throws Exception &#123;     //获取密钥必须要身份验证，单点登录必须要配置      security.tokenKeyAccess(&quot;isAuthenticated()&quot;);  &#125;\n\n更改授权后的重定向地址\n .redirectUris(&quot;http://localhost:8081/login&quot;) //自动授权.autoApprove(true)\n\n\n\n测试效果\n\n当我们访问http://localhost:8081/user/getCurrentUser就会跳转到服务端的登录地址\n\n\n当我们登录后会跳转到授权页面，开启自动授权的话就直接授权，跳过此页面\n\n\n授权后我们来到客户端的（http://localhost:8081/user/getCurrentUser）getCurrentUser方法里\n\n\n\n\n\n"},{"title":"SpringBoot 知识汇总","url":"/2021/03/07/Springboot2-md/","content":"一.容器功能1.底层注解@Configuration详解@Configuration：告诉springboot这是一个配置类 == 配置文件 ， 配置类本身也是组件\n@Bean：给容器中添加组件。以方法名作为组件id，返回类型是组件类型，返回的值就是组件在容器中的实列 ==\nproxyBeanMethods：代理bean的方法\n实战作用\n配置类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断\n配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式\n\n/** * 1.proxyBeanMethods:代理bean的方法 * Full：(proxyBeanMethods = turn) 全模式 * Lite：(proxyBeanMethods = false) 轻量级模式 * 组件依赖 */@Configuration(proxyBeanMethods = true)public class Myconfig &#123;    @Bean    public Users users()&#123;        Users user = new Users(&quot;张三&quot;,20);        //users组件依赖了pet组件       user.setPet(pet());        return user;    &#125;    @Bean    public Pet pet() &#123;        return new Pet(&quot;旺财&quot;);    &#125;&#125;\n\n\n\n@Autowired    ApplicationContext ioc; //获取ioc容器    @Test    void contextLoads() &#123;        //查看容器中的组件        String[] names = ioc.getBeanDefinitionNames();        for(String name : names)&#123;            System.out.println(name);        &#125;        //从容器中获取组件        Pet tom01 = ioc.getBean(&quot;pet&quot;,Pet.class);        Pet tom02 = ioc.getBean(&quot;pet&quot;,Pet.class);        System.out.println(&quot;组件：&quot;+(tom01 == tom02));        //com.project5.project5.config.Myconfig$$EnhancerBySpringCGLIB$$193ccc23@440eaa07        Myconfig myconfig = ioc.getBean(Myconfig.class);        System.out.println(&quot;myconfig&quot;+myconfig);        //如果@Configuration(proxyBeanMethods = true) 代理对象调用方法。Spring Boot总会检查这个组件是否存在容器中        //保持组件单实例        Users user = myconfig.users();        Users user1 = myconfig.users();        System.out.println(user == user1);        Users user01 = ioc.getBean(&quot;users&quot;,Users.class);        Pet tom = ioc.getBean(&quot;pet&quot;,Pet.class);        System.out.println(&quot;用户的宠物&quot;+(user01.getPet() == tom));    &#125;\n\n2.@Import注解@Import(&#123;Users.class, DBHelper.class&#125;)\n\n3.@Conditional@Conditional：条件装配，满足Conditional指定的条件，则进行组件注入\n4.@ImportResource@ImportResource(“classpath:beans.xml”)导入spring的配置文件，使其生效\n5.配置绑定（1）@Component  +  @ConfigurationProperties@Component  //将组件加入到容器中，只有在容器中的组件，才能得到springBoot的强大支持@ConfigurationProperties(prefix = &quot;mycat&quot;)  //将配置文件中前置为mycat的配置加载到组件中public class Cat &#123;    private  String name;    private Integer money;\n\n（2）@ConfigurationProperties  +  @EnableConfigurationProperties@EnableConfigurationProperties(Cat.class)  //开启Cat配置绑定功能，把Cat这个组件自动注册到容器中public class Myconfig &#123;\n\n二.自动配置原理1.引导加载自动配置类(1)SpringBootApplication由下面几个注解组成@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(    excludeFilters = &#123;@Filter(    type = FilterType.CUSTOM,    classes = &#123;TypeExcludeFilter.class&#125;), @Filter(    type = FilterType.CUSTOM,    classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)\n\n​    (1.1).@SpringBootConfiguration\n​    @Configuration : 代表当前是一个配置类\n（1.2）@ComponentScan\n​    指定扫描哪些，spring注解；\n（1.3）@EnableAutoConfiguration@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123;\n\n​    (1.3.1) @AutoConfigurationPackage\n自动配置包？指定了默认的包规则\n@Import(&#123;Registrar.class&#125;) //给容器中导入一个组件public @interface AutoConfigurationPackage &#123;    //利用Registrar给容器中导入一系列组件    //将指定的一个包下的所有组件导进来？主程序所在的包下\n\n（1.3.2）@Import({AutoConfigurationImportSelector.class})\n​       \n1.利用this.getAutoConfigurationEntry(annotationMetadata);方法，给容器中批量导入一些组件2.调用List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);获取到所有需要导入到容器中的组件3.利用工厂加载Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader)得到所有组件4.从META-INF/spring.factories位置来加载一个文件。    默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件    spring-boot-autoconfigure-2.4.3RELEASE.jar里面也有META-INF/spring.factories\n\n文件里写死了spring-boot一启动就要给容器中加载的所有配置类路径 spring-boot-autoconfigure-2.4.3RELEASE.jar/META-INF/spring.factories# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.neo4j.Neo4jAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\org.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\\org.springframework.boot.autoconfigure.r2dbc.R2dbcTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration\n\n\n\n\n2.按需开启自动配置项\n虽然我们130个场景的所有自动配置启动的时候默认全部加载。\n\n按照条件装配规则（@Conditional），最终会按需加载。\n3.修改默认配置SpringBoot默认会在底层配置好所有的组件。但是如果用户自己配置了以用户的优先。\n\n\n@Bean   @ConditionalOnMissingBean   public CharacterEncodingFilter characterEncodingFilter() &#123;\n\n总结：\n\nSpringBoot先加载所有的自动配置类  xxxxAutoConfiguration\n\n每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。  xxxxProperties里面拿  ，xxxxproperties和配置文件进行了绑定\n\n生效的配置类会给容器中装配很多组件\n\n只要容器中有这些组件，相当于这些功能有了\n\n只要用户有自己配置的，就以用户的优先\n\n定制化配置\n\n用户直接自己@Bean替换底层的组件\n用户去看这个组件是获取的配置文件什么值就去修改\n\nxxxxAutoConfiguration  —&gt;组件  —&gt;xxxxProperties里面拿值  —&gt;application.properties\n\n\n4.最佳实践\n引入场景依赖\n\nhttps://docs.spring.io/spring-boot/docs/2.4.3/reference/html/using-spring-boot.html#using-boot-starter\n\n\n查看自动配置了哪些\n\n自己分析，引入场景对应的自动配置一般都生效了\n配置文件中debug=true开启自动配置报告。Negative（不生效）\\Positive（生效）\n\n\n是否需要修改\n\n参照文档修改配置项\n\nhttps://docs.spring.io/spring-boot/docs/2.4.3/reference/html/appendix-application-properties.html#common-application-properties\n自己分析，xxxxproperties绑定了配置文件的哪些\n\n\n自定义加入或者替换组件\n\n@Bean、@Component。。。\n\n\n自定义器  xxxxCustomizer\n\n……\n\n\n\n\n三、开发小技巧1.Lombok​    简化JavaBean的开发,先导入依赖：\n&lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;/dependency&gt;\n\n然后在Idea里下载Lombok插件就可以使用了\n@NoArgsConstructor  //无参构造器@AllArgsConstructor //全参构造器@ToString  //重写tostring方法@Data  //get set方法public class Pet &#123;    private  String name;&#125;//Lombok还提供了@Slf4j日志注解 log.info(&quot;打印日志&quot;)\n\n2.dev-tools\n&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;/dependency&gt;\n\nCtrl+F9\n四、配置文件springboot使用一个全局的配置文件，配置文件名是固定的，有两种格式​        1.application.properties​        2.application.yml配置文件的作用：修改spring boot自动配置的默认值；spring boot在底层都给我们配置好的；\nyaml语法1.基本语法K:(空格)V : 表示一对键值对（空格必须有）；\n以空格的缩进来控制层级关系；只有是左对齐的一列数据，都是一个层级的；属性和值也是大小写敏感的；\n2.值的写法字面量：普通的值（数字，字符串，布尔）k: v : 字面直接来写；\n​    字符串默认不用加上单引号或者双引号\n“”：双引号； 不会转义字符串里面的特殊字符；特殊字符会作为本身想要表达的意思\nname：”zhangsan \\n lisi”：输出zhangsan 换行 lisi\n‘’:单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据\nname：”zhangsan \\n lisi”：输出zhangsan \\n lisi\n对象、Map（属性和值）（键值对）：k: v ：在下一行来写对象的属性和值的关系；注意缩进；对象还是k:v的方式\nfriends:\t\tlastName: zhangsan\t\tage: 20\n\n​    行内写法：\nfriends: &#123;lastName: zhangsan,age: 18&#125;\n\n数组（List,Set)用-值表示数组中的一个元素\npets: - cat - dog - pig \n\n行内写法 \npets: [cat,dog,pig]\n\n3.配置文件注入application.yml:\nperson:  name: 张三  age: 18  isboy: true  birth: 2017/09/09  map:    k1: v1  list:    - l1  dog:    name: 小狗    age: 2\n\nJavaBean：\n@configurationProperties:将配置文件中的每一个属性值，映射到这个实体类中\nprefix=”person” ： 将配置文件中person下面的所以属性进行一一映射\n@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123;    private  String name;    private  Integer age;    private Boolean isboy;     private Date birth;     private Map&lt;String,Object&gt; map;     private List&lt;Object&gt; list;    private  Dog dog;\n\n配置文件处理器，以后编写配置就有提示\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\n\napplication.properties中文乱码问题\n打开设置 进入 file encoding 更改Properties Files 的编码为UTF-8,并且勾上Transparent native-to-ascii conversation\n@ConfigurationProperties和@value的区别\n\n\n\n@ConfigurationProperties\n@Value\n\n\n\n功能\n批量注入配置文件中的属性\n一个个值定\n\n\n松散语法\n支持\n不支持\n\n\nSpEL\n不支持\n支持\n\n\nJSR303数据检验\n支持\n不支持\n\n\n复杂类型封装\n支持\n不支持\n\n\n配置文件yml还是properties他们都能获取到值\n如果说，我们只是在某个业务逻辑中获取配置文件中的某项值，使用@Value\n如果我们专门写了一个JavaBean来和配置文件进行映射，我们就直接使用ConfigurationProperties;\n3.配置文件数据检验@Validated\n4.@PropertySource/ImportResource@PropertySource:加载指定的配置文件；\n@PropertySource(value=&#123;&quot;classpath:person.properties&quot;&#125;)\n\n @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效；\n@ImportResource(locations = &quot;classpath:beans.xml&quot;)导入spring配置文件使其生效\n\n\n\nSpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式\n1.配置类======Spring配置文件\n2.使用@Bean给容器中添加组件\n@Configurationpublic class helloConfig &#123;    @Bean    public HelloService helloService()&#123;        System.out.println(&quot;添加组件&quot;);        return new HelloService();    &#125;&#125;\n\n5.配置文件占位符1.随机数\n$&#123;random.value&#125;,$&#123;random.int&#125;,$&#123;random.long&#125;$&#123;random.int(10)&#125;,$&#123;random.int[1024,65536]&#125;\n\n2.占位符获取之前配置的值，如果没有是可以用：指定默认值\n#person.name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.isboy=falseperson.birth=2020/02/02person.map.k1=v1person.list=l1person.dog.name=$&#123;person.name:李四&#125;小狗person.dog.age=2\n\n6.Profile1.多Profile文件\n我们在主配置文件编写的时候，文件名可以是application-{Profile}.properties/yml\n默认使用application.properties的配置\n2.yml支持多文档块方式\nserver:  port: 8080spring:  profiles:    active: dev---server:  port: 8081spring:  profiles: dev---server:  port: 8082spring:  profiles: prod #指定属于哪个环境\n\n3.激活指定profile\nspring.profiles.active=prod\n\n\n@profile\n\n\n\n\n@Profile也可以标在配置类上，整个类只有在指定的生产环境下才能生效\n\n命令行激活（可以修改配置文件任意值,以命令行优先）：\njava -jar project1-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod --person.name=hello\n\n可以直接在测试的时候，配置传入命令行参数–spring.profiles.active=prod\n虚拟机参数：\n-Dspring.profiles.active=prod\n7.配置文件加载位置\n spring boot启动时会扫描以下位置的application.properties或者application.yml文件作为spring boot的默认配置文件\n-file（项目文件）:/config/\n-file:/\n-classpath(resource):/config/\n-classpath:/\n优先级由高到低，高优先级的会覆盖低优先级的配置；\nspringboot会从这四个位置全部加载成主配置文件；互补配置\n我们还可以通过spring.config.location来改变默认的配置文件位置\n项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认的这些配置文件共同起作用形成互补配置；（springboot2.4.3实测没有互补）\n8.外部配置加载顺序springboot也可以从以下位置加载配置；优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置\n1.命令行参数\njava -jar project4-0.0.1-SNAPSHOT.jar –server.port=8086 –server.servlet.context-path=/abc\n多个配置用空格分开 –配置项=值\n2.来自java：comp/env的JNDI属性\n3.Java系统属性（System.getProperties()）\n4.操作系统环境变量\n5.RandomValuePropertySource配置的random.*属性值\n由jar包外向jar包内进行寻找；\n优先加载带profile的\n6.jar包外部的application-{profiles}.properties或application.yml（带spring.profile）配置文件\n7.jar包内部的application-{profiles}.properties或application.yml（带spring.profile）配置文件\n8.jar包外部的application.properties或application.yml（不带spring.profile）配置文件\n9.jar包内部的application.properties或application.yml（不带spring.profile）配置文件\n10.@Configuration注解类上的@PropertySource\n11.通过SpringApplication.setDefaultProperties指定的默认属性\n所有支持的配置加载来源；\n[参考官方文档](\n五、web开发（源码以后再看）1、SpringMVC自动配置概览Spring Boot provides auto-configuration for Spring MVC that works well with most applications.(大多场景我们都无需自定义配置)\nThe auto-configuration adds the following features on top of Spring’s defaults:\n\nInclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.\n\n\n内容协商视图解析器和BeanName视图解析器\n\n\nSupport for serving static resources, including support for WebJars (covered later in this document)).\n\n\n静态资源（包括webjars）\n\n\nAutomatic registration of Converter, GenericConverter, and Formatter beans.\n\n\n自动注册 Converter，GenericConverter，Formatter\n\n\nSupport for HttpMessageConverters (covered later in this document).\n\n\n支持 HttpMessageConverters （后来我们配合内容协商理解原理）\n\n\nAutomatic registration of MessageCodesResolver (covered later in this document).\n\n\n自动注册 MessageCodesResolver （国际化用）\n\n\nStatic index.html support.\n\n\n静态index.html 页支持\n\n\nCustom Favicon support (covered later in this document).\n\n\n自定义 Favicon  \n\n\nAutomatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).\n\n\n自动使用 ConfigurableWebBindingInitializer ，（DataBinder负责将请求数据绑定到JavaBean上）\n\n\n\n\nIf you want to keep those Spring Boot MVC customizations and make more MVC customizations (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc.\n不用@EnableWebMvc注解。使用 @Configuration + WebMvcConfigurer 自定义规则\n\n\nIf you want to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, and still keep the Spring Boot MVC customizations, you can declare a bean of type WebMvcRegistrations and use it to provide custom instances of those components.\n声明 WebMvcRegistrations 改变默认底层组件\n\n\nIf you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc, or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration as described in the Javadoc of @EnableWebMvc.\n使用 @EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管SpringMVC \n\n2.简单功能分析2.1静态资源访问静态资源目录只要将静态资源放在类路径下： called /static (or /public or /resources or /META-INF/resources\n访问：当前项目根路径/+静态资源名\n原理：静态映射/**。\n请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面。\n静态资源访问前缀默认无前缀\nspring:  mvc:    static-path-pattern: /res/**\n\nwebjar自动映射 /webjars/**\nhttps://www.webjars.org/\n&lt;dependency&gt;    &lt;groupId&gt;org.webjars&lt;/groupId&gt;    &lt;artifactId&gt;jquery&lt;/artifactId&gt;    &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;\n\n访问地址：http://localhost:8080/webjars/jquery/3.5.1/jquery.js  后面地址要按照依赖里面的包路径\n2.2、欢迎页支持2.3、自定义 Favicon2.4、静态资源配置原理25集\n3、请求参数处理1、rest使用与原理\n@xxxMapping；\n\nRest风格支持（使用*HTTP*请求方式动词来表示对资源的操作）\n\n\n以前：**/getUser  获取用户   /deleteUser 删除用户   /editUser  修改用户    /saveUser 保存用户\n现在： /user   GET-**获取用户   DELETE-**删除用户   PUT-**修改用户    POST-**保存用户\n核心Filter；HiddenHttpMethodFilter\n\n\n\n\n用法： 表单method=post，隐藏域 _method=put\n&lt;h1&gt;测试rest风格&lt;/h1&gt;&gt;&lt;form action=&quot;/user&quot; method=&quot;get&quot; &gt;    &lt;input type=&quot;submit&quot; value=&quot;GET&quot;&gt;&lt;/form&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot; &gt;    &lt;input type=&quot;submit&quot; value=&quot;POST&quot;&gt;&lt;/form&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot; &gt;    &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;PUT&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;PUT&quot;&gt;&lt;/form&gt;&lt;form action=&quot;/user&quot; method=&quot;post&quot; &gt;    &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;DELETE&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;DELETE&quot;&gt;&lt;/form&gt;       //controller:  @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)    public Object get()&#123;        return &quot;GET&quot;;    &#125;    @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)    public Object post()&#123;        return &quot;POST&quot;;    &#125;    @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)    public Object put()&#123;        return &quot;PUT&quot;;    &#125;    @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)    public Object delete()&#123;        return &quot;DELETE&quot;;    &#125;\n\n\n\n\n\n\n\n\n\n- SpringBoot中手动开启\n\n  spring:  mvc:    hiddenmethod:      filter:        enabled: true\n\n扩展：如何把_method 这个名字换成我们自己喜欢的。\n\n\n\nREST原理：26集\n2.请求映射原理28集\n2、普通参数与基本注解1.1、注解：@PathVariable(路径变量)、@RequestHeader(获取请求头)、@ModelAttribute()、@RequestParam(获取请求参数)、@MatrixVariable(矩阵变量)31集，@CookieValue(获取cookie值)、@RequestBody(获取请求体[post])、@RequestAttribute(获取request域属性)\n1.2、Servlet API：WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId\n1.3、复杂参数：Map、Model（map、model里面的数据会被放在request的请求域  request.setAttribute）、Errors/BindingResult、RedirectAttributes（ 重定向携带数据）、ServletResponse（response）、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder\n3.thymeleaf4.拦截器public class LoginInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        HttpSession session = request.getSession();        if(session.getAttribute(&quot;user&quot;) != null)&#123;            return true;        &#125;        return false;    &#125;\n\n@Configurationpublic class LoginConfig implements WebMvcConfigurer &#123;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(new LoginInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/login.html&quot;,&quot;/loginUser&quot;);    &#125;\n\n5.文件上传6.异常处理7.Web原生组件注入（servlet，Filter，Listener）六、数据访问1.整合druid数据源1.1自定义方式1.2使用官方starter方式2.整合Mybatis2.1、配置模式\n导入mybatis-starter\n\n&lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.1.3&lt;/version&gt;        &lt;/dependency&gt;\n\n\n创建全局配置文件和mapper映射文件\n\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;/configuration&gt;#全局配置文件\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt;    &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt;    select * from Blog where id = #&#123;id&#125;  &lt;/select&gt;&lt;/mapper&gt;#mapper映射文件\n\n\n在yaml配置文件中配置mybatis规则\nmybatis:  config-location: classpath:mybatis/mybatis-config.xml #mybatis全局配置文件位置  mapper-locations: classpath:mybatis/mapper/*.xml #mapper配置文件位置\n\n编写mapper接口和service业务类\n\n\n3、整合Mybatis-Plus\n引入Mybatis-Plus依赖\n&lt;dependency&gt;        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;        &lt;version&gt;Latest Version&lt;/version&gt;    &lt;/dependency&gt;\n\n\n\n\n\n\n配置数据库相关的配置\n#datasource的父级是springdatasource:    url: jdbc:mysql://localhost:3306/book    username: root    password: 123456    driver-class-name: com.mysql.cj.jdbc.Driver\n\n在 Spring Boot 启动类中添加 @MapperScan 注解，扫描 Mapper 文件夹：\n@MapperScan(&quot;com.project.project6.mapper&quot;)\n\n编写实体类，mapper接口，以及业务逻辑层\n\n实体类\n\n@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123;    @TableField(exist = false) //代表表中不存在的字段    private String username;    @TableField(exist = false)    private  String password;    private Long id;    private String name;    private Integer age;    private String email;&#125;\n\n\nmapper接口\npublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125;  //继承Mybatis-Plus提供的BaseMapper接口。\n\n\n\n\n\n\n\n\n业务逻辑层\nservicepublic interface UserService extends IService&lt;User&gt; &#123;&#125;  //继承Mybatis-Plus提供的IService接口。\n\nserviceImpl@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService &#123;&#125;  //继承Mybatis-Plus提供的ServiceImpl接口。\n\n\n\n\n分页使用\n\n导入分页插件\n\n@Configurationpublic class MybatisPlusConfig &#123;    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));        return interceptor;    &#125;    @Bean    public ConfigurationCustomizer configurationCustomizer() &#123;        return configuration -&gt; configuration.setUseDeprecatedExecutor(false);    &#125;&#125;\n\n\n\n\n\n\n测试\n@GetMapping(&quot;/user&quot;)    public  Object getUser(@RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;)Integer pn)&#123;        Page&lt;User&gt; page = new Page&lt;User&gt;(pn,2);      return userService.page(page);    &#125;\n\n\n\n\n4.整合Redis\n导入依赖并编写配置文件\n&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;        &lt;/dependency&gt;  //redis依赖        &lt;dependency&gt;            &lt;groupId&gt;redis.clients&lt;/groupId&gt;            &lt;artifactId&gt;jedis&lt;/artifactId&gt;        &lt;/dependency&gt; //jedis依赖\n\nredis:    host: 127.0.0.1  //redis地址    password: 123456  //密码    port: 6379  //端口号    client-type: jedis  //工厂类型\n\n\n\n\n\n\n注入StringRedisTemplate组件来操作redis\n@Autowired    StringRedisTemplate stringRedisTemplate;@Autowired    RedisConnectionFactory redisConnectionFactory;  //查看当前连接工厂\n\n调用opsForValue方法来进行操作\n\n\n@Test   void contextLoads() &#123;       ValueOperations&lt;String, String&gt; operations = stringRedisTemplate.opsForValue();       operations.set(&quot;hello&quot;,&quot;world&quot;);       operations.get(&quot;hello&quot;);       System.out.println(redisConnectionFactory.getClass()); //使用jedis连接工厂   &#125;\n\n2.使用redis实现统计功能\n编写一个拦截器，请求一次就统计一次\n\n@Componentpublic class RedisConfig implements HandlerInterceptor &#123;    @Autowired    StringRedisTemplate stringRedisTemplate;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        String uri = request.getRequestURI();        ValueOperations&lt;String, String&gt; operations = stringRedisTemplate.opsForValue();        operations.increment(uri); //默认每次访问uri就会+1        return true;    &#125;&#125;\n\n@Configurationpublic class LoginConfig implements WebMvcConfigurer &#123;    @Autowired    RedisConfig redisConfig;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(new LoginInterceptor())                .addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/login.html&quot;,&quot;/loginUser&quot;);        registry.addInterceptor(redisConfig).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/login.html&quot;,&quot;/loginUser&quot;);    &#125;&#125;\n\n\ncontroller测试\n@Autowired   StringRedisTemplate stringRedisTemplate;   @GetMapping(&quot;main.html&quot;)   public String totle(Model model)&#123;       ValueOperations&lt;String, String&gt; operations = stringRedisTemplate.opsForValue();      String cat =  operations.get(&quot;/cat&quot;);       String city = operations.get(&quot;/city&quot;);       model.addAttribute(&quot;cat&quot;,cat);       model.addAttribute(&quot;city&quot;,city);       return &quot;index.html&quot;;   &#125;\n\n七、单元测试1、JUnit5 的变化Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库\n作为最新版本的JUnit框架，JUnit5与之前版本的Junit框架有很大的不同。由三个不同子项目的几个不同模块组成。\n\nJUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage\n\nJUnit Platform: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。\nJUnit Jupiter: JUnit Jupiter提供了JUnit5的新的编程模型，是JUnit5新特性的核心。内部 包含了一个测试引擎，用于在Junit Platform上运行。\nJUnit Vintage: 由于JUint已经发展多年，为了照顾老的项目，JUnit Vintage提供了兼容JUnit4.x,Junit3.x的测试引擎。\n\n注意：\nSpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖。如果需要兼容junit4需要自行引入（不能使用junit4的功能 @Test）\nJUnit 5’s Vintage Engine Removed from spring-boot-starter-test,如果需要继续兼容junit4需要自行引入vintage\n&lt;dependency&gt;    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;            &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;\n\n****\n\n\n  \n  &lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;  &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;\n\n  现在版本：\n  @SpringBootTestclass Boot05WebAdminApplicationTests &#123;    @Test    void contextLoads() &#123;    &#125;&#125;\n\n\n\n\n\n  以前：\n  @SpringBootTest + @RunWith(SpringTest.class)\n  SpringBoot整合Junit以后。\n\n编写测试方法：@Test标注（注意需要使用junit5版本的注解）\nJunit类具有Spring的功能，@Autowired、比如 @Transactional 标注测试方法，测试完成后自动回滚\n\n2、JUnit5常用注解  JUnit5的注解与JUnit4的注解有所变化\n  https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations\n\n@Test :表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试\n\n@ParameterizedTest :表示方法是参数化测试，下方会有详细介绍\n\n@RepeatedTest :表示方法可重复执行，下方会有详细介绍\n\n@DisplayName :为测试类或者测试方法设置展示名称\n\n@BeforeEach :表示在每个单元测试之前执行\n\n@AfterEach :表示在每个单元测试之后执行\n\n@BeforeAll :表示在所有单元测试之前执行\n\n@AfterAll :表示在所有单元测试之后执行\n\n@Tag :表示单元测试类别，类似于JUnit4中的@Categories\n\n@Disabled :表示测试类或测试方法不执行，类似于JUnit4中的@Ignore\n\n@Timeout :表示测试方法运行如果超过了指定时间将会返回错误\n\n@ExtendWith :为测试类或测试方法提供扩展类引用\nimport org.junit.jupiter.api.Test; //注意这里使用的是jupiter的Test注解！！public class TestDemo &#123;  @Test  @DisplayName(&quot;第一次测试&quot;)  public void firstTest() &#123;      System.out.println(&quot;hello world&quot;);  &#125;\n\n\n\n\n\n3、断言（assertions）  断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法。JUnit 5 内置的断言可以分成如下几个类别：\n  检查业务逻辑返回的数据是否合理。\n  所有的测试运行结束以后，会有一个详细的测试报告；\n1、简单断言  用来对单个值进行简单的验证。如：\n\n\n\n方法\n说明\n\n\n\nassertEquals\n判断两个对象或两个原始类型是否相等\n\n\nassertNotEquals\n判断两个对象或两个原始类型是否不相等\n\n\nassertSame\n判断两个对象引用是否指向同一个对象\n\n\nassertNotSame\n判断两个对象引用是否指向不同的对象\n\n\nassertTrue\n判断给定的布尔值是否为 true\n\n\nassertFalse\n判断给定的布尔值是否为 false\n\n\nassertNull\n判断给定的对象引用是否为 null\n\n\nassertNotNull\n判断给定的对象引用是否不为 null\n\n\n  @Test@DisplayName(&quot;simple assertion&quot;)public void simple() &#123;     assertEquals(3, 1 + 2, &quot;simple math&quot;);     assertNotEquals(3, 1 + 1);     assertNotSame(new Object(), new Object());     Object obj = new Object();     assertSame(obj, obj);     assertFalse(1 &gt; 2);     assertTrue(1 &lt; 2);     assertNull(null);     assertNotNull(new Object());&#125;\n\n\n\n2、数组断言  通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等\n  @Test@DisplayName(&quot;array assertion&quot;)public void array() &#123; assertArrayEquals(new int[]&#123;1, 2&#125;, new int[] &#123;1, 2&#125;);&#125;\n\n\n\n3、组合断言  assertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言\n  @Test@DisplayName(&quot;assert all&quot;)public void all() &#123; assertAll(&quot;Math&quot;,    () -&gt; assertEquals(2, 1 + 1),    () -&gt; assertTrue(1 &gt; 0) );&#125;\n\n\n\n4、异常断言  在JUnit4时期，想要测试方法的异常情况时，需要用@Rule注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式Assertions.assertThrows() ,配合函数式编程就可以进行使用。\n  @Test@DisplayName(&quot;异常测试&quot;)public void exceptionTest() &#123;    ArithmeticException exception = Assertions.assertThrows(           //扔出断言异常            ArithmeticException.class, () -&gt; System.out.println(1 % 0));&#125;\n\n\n\n5、超时断言  Junit5还提供了Assertions.assertTimeout() 为测试方法设置了超时时间\n  @Test@DisplayName(&quot;超时测试&quot;)public void timeoutTest() &#123;    //如果测试方法时间超过1s将会异常    Assertions.assertTimeout(Duration.ofMillis(1000), () -&gt; Thread.sleep(500));&#125;\n\n\n\n6、快速失败  通过 fail 方法直接使得测试失败\n  @Test@DisplayName(&quot;fail&quot;)public void shouldFail() &#123; fail(&quot;This should fail&quot;);&#125;\n\n4、前置条件（assumptions）JUnit 5 中的前置条件（assumptions【假设】）类似于断言，不同之处在于不满足的断言会使得测试方法失败，而不满足的前置条件只会使得测试方法的执行终止。前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。\n@DisplayName(&quot;前置条件&quot;)public class AssumptionsTest &#123; private final String environment = &quot;DEV&quot;;  @Test @DisplayName(&quot;simple&quot;) public void simpleAssume() &#123;    assumeTrue(Objects.equals(this.environment, &quot;DEV&quot;));    assumeFalse(() -&gt; Objects.equals(this.environment, &quot;PROD&quot;)); &#125;  @Test @DisplayName(&quot;assume then do&quot;) public void assumeThenDo() &#123;    assumingThat(       Objects.equals(this.environment, &quot;DEV&quot;),       () -&gt; System.out.println(&quot;In DEV&quot;)    ); &#125;&#125;\n\nassumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。\n5、嵌套测试JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制。\n@DisplayName(&quot;A stack&quot;)class TestingAStackDemo &#123;    Stack&lt;Object&gt; stack;    @Test    @DisplayName(&quot;is instantiated with new Stack()&quot;)    void isInstantiatedWithNew() &#123;        new Stack&lt;&gt;();    &#125;    @Nested    @DisplayName(&quot;when new&quot;)    class WhenNew &#123;        @BeforeEach        void createNewStack() &#123;            stack = new Stack&lt;&gt;();        &#125;        @Test        @DisplayName(&quot;is empty&quot;)        void isEmpty() &#123;            assertTrue(stack.isEmpty());        &#125;        @Test        @DisplayName(&quot;throws EmptyStackException when popped&quot;)        void throwsExceptionWhenPopped() &#123;            assertThrows(EmptyStackException.class, stack::pop);        &#125;        @Test        @DisplayName(&quot;throws EmptyStackException when peeked&quot;)        void throwsExceptionWhenPeeked() &#123;            assertThrows(EmptyStackException.class, stack::peek);        &#125;        @Nested        @DisplayName(&quot;after pushing an element&quot;)        class AfterPushing &#123;            String anElement = &quot;an element&quot;;            @BeforeEach            void pushAnElement() &#123;                stack.push(anElement);            &#125;            @Test            @DisplayName(&quot;it is no longer empty&quot;)            void isNotEmpty() &#123;                assertFalse(stack.isEmpty());            &#125;            @Test            @DisplayName(&quot;returns the element when popped and is empty&quot;)            void returnElementWhenPopped() &#123;                assertEquals(anElement, stack.pop());                assertTrue(stack.isEmpty());            &#125;            @Test            @DisplayName(&quot;returns the element when peeked but remains not empty&quot;)            void returnElementWhenPeeked() &#123;                assertEquals(anElement, stack.peek());                assertFalse(stack.isEmpty());            &#125;        &#125;    &#125;&#125;\n\n\n\n6、参数化测试参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。\n利用@ValueSource等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。\n****\n@ValueSource: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型\n@NullSource: 表示为参数化测试提供一个null的入参\n@EnumSource: 表示为参数化测试提供一个枚举入参\n@CsvFileSource：表示读取指定CSV文件内容作为参数化测试入参\n@MethodSource：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)\n\n当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现ArgumentsProvider接口，任何外部文件都可以作为它的入参。\n\n@ParameterizedTest@ValueSource(strings = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)@DisplayName(&quot;参数化测试1&quot;)public void parameterizedTest1(String string) &#123;    System.out.println(string);    Assertions.assertTrue(StringUtils.isNotBlank(string));&#125;@ParameterizedTest@MethodSource(&quot;method&quot;)    //指定方法名@DisplayName(&quot;方法来源参数&quot;)public void testWithExplicitLocalMethodSource(String name) &#123;    System.out.println(name);    Assertions.assertNotNull(name);&#125;static Stream&lt;String&gt; method() &#123;    return Stream.of(&quot;apple&quot;, &quot;banana&quot;);&#125;\n\n\n\n7、迁移指南在进行迁移的时候需要注意如下的变化：\n\n注解在 org.junit.jupiter.api 包中，断言在 org.junit.jupiter.api.Assertions 类中，前置条件在 org.junit.jupiter.api.Assumptions 类中。\n把@Before 和@After 替换成@BeforeEach 和@AfterEach。\n把@BeforeClass 和@AfterClass 替换成@BeforeAll 和@AfterAll。\n把@Ignore 替换成@Disabled。\n把@Category 替换成@Tag。\n把@RunWith、@Rule 和@ClassRule 替换成@ExtendWith。\n\n八、指标监控1、SpringBoot Actuator1、简介未来每一个微服务在云上部署以后，我们都需要对其进行监控、追踪、审计、控制等。SpringBoot就抽取了Actuator场景，使得我们每个微服务快速引用即可获得生产级别的应用监控、审计等功能。\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n2、1.x与2.x的不同\n3、如何使用\n引入场景\n访问 http://localhost:8080/actuator/**\n暴露所有监控信息为HTTP\n\nmanagement:  endpoints:    enabled-by-default: true #暴露所有端点信息    web:      exposure:        include: &#x27;*&#x27;  #以web方式暴露\n\n\n测试\n\nhttp://localhost:8080/actuator/beans\nhttp://localhost:8080/actuator/configprops\nhttp://localhost:8080/actuator/metrics\nhttp://localhost:8080/actuator/metrics/jvm.gc.pause\nhttp://localhost:8080/actuator/endpointName/detailPath。。。。。。\n4、可视化https://github.com/codecentric/spring-boot-admin\n\n编写一个服务器项目，专门用来监控客户端\n\n然后导入依赖\n&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;de.codecentric&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;            &lt;version&gt;2.3.1&lt;/version&gt;        &lt;/dependency&gt;  #可视化工具依赖，需搭配web依赖使用\n\n在主程序上编写@EnableAdminServer\n@EnableAdminServer@SpringBootApplicationpublic class ProjectadminserviceApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ProjectadminserviceApplication.class, args);    &#125;&#125;\n\n端口号不能与客户端一致\n\n在客户端引入依赖\n&lt;dependency&gt;            &lt;groupId&gt;de.codecentric&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;            &lt;version&gt;2.3.1&lt;/version&gt;        &lt;/dependency&gt;\n\n在编写配置文件和服务器项目对应\nspring  boot:    admin:      client:        url: http://localhost:8081 #对应服务器端项目的端口        instance:          prefer-ip: true #使用IP注册进来，不然注册进去的会是电脑名字  application:    name: project6 #表明当前项目名\n\n实例化页面\n\n\n一个六边形代表一个项目，12m表示运行了12分钟\n\n\n\n2、Actuator Endpoint1、最常使用的端点\n\n\nID\n描述\n\n\n\nauditevents\n暴露当前应用程序的审核事件信息。需要一个AuditEventRepository组件。\n\n\nbeans\n显示应用程序中所有Spring Bean的完整列表。\n\n\ncaches\n暴露可用的缓存。\n\n\nconditions\n显示自动配置的所有条件信息，包括匹配或不匹配的原因。\n\n\nconfigprops\n显示所有@ConfigurationProperties。\n\n\nenv\n暴露Spring的属性ConfigurableEnvironment\n\n\nflyway\n显示已应用的所有Flyway数据库迁移。 需要一个或多个Flyway组件。\n\n\nhealth\n显示应用程序运行状况信息。\n\n\nhttptrace\n显示HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应）。需要一个HttpTraceRepository组件。\n\n\ninfo\n显示应用程序信息。\n\n\nintegrationgraph\n显示Spring integrationgraph 。需要依赖spring-integration-core。\n\n\nloggers\n显示和修改应用程序中日志的配置。\n\n\nliquibase\n显示已应用的所有Liquibase数据库迁移。需要一个或多个Liquibase组件。\n\n\nmetrics\n显示当前应用程序的“指标”信息。\n\n\nmappings\n显示所有@RequestMapping路径列表。\n\n\nscheduledtasks\n显示应用程序中的计划任务。\n\n\nsessions\n允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。\n\n\nshutdown\n使应用程序正常关闭。默认禁用。\n\n\nstartup\n显示由ApplicationStartup收集的启动步骤数据。需要使用SpringApplication进行配置BufferingApplicationStartup。\n\n\nthreaddump\n执行线程转储。\n\n\n如果您的应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点：\n\n\n\nID\n描述\n\n\n\nheapdump\n返回hprof堆转储文件。\n\n\njolokia\n通过HTTP暴露JMX bean（需要引入Jolokia，不适用于WebFlux）。需要引入依赖jolokia-core。\n\n\nlogfile\n返回日志文件的内容（如果已设置logging.file.name或logging.file.path属性）。支持使用HTTPRange标头来检索部分日志文件的内容。\n\n\nprometheus\n以Prometheus服务器可以抓取的格式公开指标。需要依赖micrometer-registry-prometheus。\n\n\n最常用的Endpoint\n\nHealth：监控状况\nMetrics：运行时指标\nLoggers：日志记录\n\n2、Health Endpoint健康检查端点，我们一般用于在云平台，平台会定时的检查应用的健康状况，我们就需要Health Endpoint可以为平台返回当前应用的一系列组件健康状况的集合。\n重要的几点：\n\nhealth endpoint返回的结果，应该是一系列健康检查后的一个汇总报告\n\n很多的健康检查默认已经自动配置好了，比如：数据库、redis等\n\n可以很容易的添加自定义的健康检查机制\nendpoint:    health:      show-details: always //开启详细的健康检查报告\n\n\n\n\n\n\n3、Metrics Endpoint提供详细的、层级的、空间指标信息，这些信息可以被pull（主动推送）或者push（被动获取）方式得到；\n\n通过Metrics对接多种监控系统\n简化核心Metrics开发\n添加自定义Metrics或者扩展已有Metrics\n\n\n4、管理Endpoints1、开启与禁用Endpoints\n默认所有的Endpoint除过shutdown都是开启的。\n需要开启或者禁用某个Endpoint。配置模式为  management.endpoint.****.enabled = true\n\nmanagement:  endpoint:    beans:      enabled: true\n\n\n或者禁用所有的Endpoint然后手动开启指定的Endpoint\n\nmanagement:  endpoints:    enabled-by-default: false  endpoint:    beans:      enabled: true    health:      enabled: true\n\n\n\n\n\n2、暴露Endpoints支持的暴露方式\n\nHTTP：默认只暴露health和info Endpoint\nJMX：默认暴露所有Endpoint\n除过health和info，剩下的Endpoint都应该进行保护访问。如果引入SpringSecurity，则会默认配置安全访问规则\n\n\n\n\nID\nJMX\nWeb\n\n\n\nauditevents\nYes\nNo\n\n\nbeans\nYes\nNo\n\n\ncaches\nYes\nNo\n\n\nconditions\nYes\nNo\n\n\nconfigprops\nYes\nNo\n\n\nenv\nYes\nNo\n\n\nflyway\nYes\nNo\n\n\nhealth\nYes\nYes\n\n\nheapdump\nN/A\nNo\n\n\nhttptrace\nYes\nNo\n\n\ninfo\nYes\nYes\n\n\nintegrationgraph\nYes\nNo\n\n\njolokia\nN/A\nNo\n\n\nlogfile\nN/A\nNo\n\n\nloggers\nYes\nNo\n\n\nliquibase\nYes\nNo\n\n\nmetrics\nYes\nNo\n\n\nmappings\nYes\nNo\n\n\nprometheus\nN/A\nNo\n\n\nscheduledtasks\nYes\nNo\n\n\nsessions\nYes\nNo\n\n\nshutdown\nYes\nNo\n\n\nstartup\nYes\nNo\n\n\nthreaddump\nYes\nNo\n\n\n3.定制化Endpoints1.定制health信息@Componentpublic class MyHealthIndicator extends AbstractHealthIndicator &#123;    @Autowired    StringRedisTemplate stringRedisTemplate;    /**     * 真实的检查方法     * @param builder     * @throws Exception     */    @Override    protected void doHealthCheck(Health.Builder builder) throws Exception &#123;        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();        if(stringRedisTemplate!=null)&#123;            builder.status(Status.UP); //健康            map.put(&quot;msg&quot;,&quot;redis导入成功&quot;);        &#125;else &#123;            builder.status(Status.DOWN); //不健康            map.put(&quot;error&quot;,&quot;redis导入失败&quot;);        &#125;        builder.withDetail(&quot;code&quot;,&quot;100&quot;);        builder.withDetails(map);    &#125;&#125;\n\n\n2.定制info\nyaml配置文件方式\ninfo:  appName: Project6  hello: world  mavenProjectName: @project.artifactId@ #使用@@可以获取maven的pom文件值  mavenVersoin: @project.version@\n\n\n\n\n\n  \n\n配置类方式\n@Componentpublic class AppInfoInfoContributor implements InfoContributor &#123;    @Override    public void contribute(Info.Builder builder) &#123;        builder.withDetail(&quot;redis实例&quot;,&quot;redis实例化成功&quot;)                .withDetail(&quot;Redis工厂类型&quot;,&quot;jedis&quot;);    &#125;&#125;\n\n\n\n\n\n\n3.定制Metrics信息@Servicepublic class CityServiceImpl implements CityService &#123;    @Autowired    CityMapper cityMapper;    Counter counter;    public CityServiceImpl(MeterRegistry meterRegistry)&#123;        counter  = meterRegistry.counter(&quot;CityServiceImpl.getCity.count&quot;);    &#125;    @Override    public City getCity() &#123;        counter.increment();        return cityMapper.getCity();    &#125;&#125;\n\n\n\n4.定制Endpoint@Component@Endpoint(id = &quot;myService&quot;)public class MyServiceEndPoint &#123;    @Autowired    CityService cityService;    @ReadOperation    public Object getCity()&#123;        return cityService.getCity();    &#125;    @WriteOperation    public void stopCity()&#123;        System.out.println(&quot;停止访问&quot;);    &#125;&#125;\n\n\n\n\n九、自定义Starter\n创建一个空工程\n\n\n\n在工厂中创建两个模块\n\n上面是maven模块来编写场景启动器，给别人引用 /下面是springboot模块负责编写自动配置相关的东西。\n\n\n\n在场景启动器中引入自动配置的依赖\n&lt;groupId&gt;com.project&lt;/groupId&gt;    &lt;artifactId&gt;project-hello-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.project&lt;/groupId&gt;            &lt;artifactId&gt;project-hello-spring-boot-starter-autoconfigure&lt;/artifactId&gt;            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;\n\n删除自动配置里面没用的东西\n\npom.xml文件里面只留下spring-boot-starter即可\n\n\n\n&lt;dependencies&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t&lt;/dependencies&gt;\n\n\n删掉项目里没有的类和配置文件（蓝色背景的都删除）\n\n\n\n\n编写一个自动配置方法\n\nservice包下的PostService类\n/** * 默认不放在容器中 */public class PostService &#123;    @Autowired    PostProperties postProperties;    public String introDuce()&#123;        return postProperties.getName()+&quot;是一个&quot;+postProperties.getPosition();    &#125;&#125;\n\n\n\n\n\n\n\n\nbean包下的PostProperties类\n@ConfigurationProperties(&quot;project.post&quot;)public class PostProperties &#123;    private  String name;    private  String position;//省略get，set方法\n\n\n\n\n\n\nauto包下的PostServiceAutoConfiguration类\n@Configuration@ConditionalOnMissingBean(PostService.class) //条件装配，你没有这个组件就自动注入@EnableConfigurationProperties(PostProperties.class) //默认将PostProperties放在容器中public class PostServiceAutoConfiguration &#123;    @Bean    public PostService postService()&#123;        PostService postService = new PostService();        return postService;    &#125;&#125;\n\n\n\n\n编写META-INF/spring.factories中EnableAutoConfiguration 的值，使得项目启动加载指定的自动配置类**\n\n# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\com.project.auto.PostServiceAutoConfiguration\n\n将模块安装到maven目录中先安装自动装配模块\n\n\n\n\n在新项目中引入自定义的Starter\n&lt;dependency&gt;            &lt;groupId&gt;com.project&lt;/groupId&gt;            &lt;artifactId&gt;project-hello-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;\n\n引入成功就可以使用了\nproject:  post:    name: 张三    position: 经理\n\n@Autowired    PostService postService;@GetMapping(&quot;/introDuce&quot;)    public  String getIntroDuce()&#123;        String s = postService.introDuce();        return s;    &#125;\n\n\n\n效果\n\n\n\n十、SpringBoot原理（以后再看）"},{"title":"apollo 学习记录","url":"/2021/03/15/apollo-md/","content":"Apollo分布式配置中心1.Apollo快速开始\n下载Quick Start安装包\n\n创建ApolloPortalDB和apolloConfigDB数据库\n\n配置数据库连接信息\nechoset url=&quot;localhost:3306&quot;set username=&quot;root&quot;set password=&quot;123456&quot;start &quot;configService&quot; java -Xms256m -Xmx256m -Dapollo_profile=github -Dspring.datasource.url=jdbc:mysql://%url%/ApolloConfigDB?characterEncoding=utf8 -Dspring.datasource.username=%username% -Dspring.datasource.password=%password% -Dlogging.file=.\\logs\\apollo-configservice.log -jar .\\apollo-configservice-1.3.0.jarstart &quot;adminService&quot; java -Xms256m -Xmx256m -Dapollo_profile=github -Dspring.datasource.url=jdbc:mysql://%url%/ApolloConfigDB?characterEncoding=utf8 -Dspring.datasource.username=%username% -Dspring.datasource.password=%password% -Dlogging.file=.\\logs\\apollo-adminservice.log -jar .\\apollo-adminservice-1.3.0.jarstart &quot;ApolloPortal&quot; java -Xms256m -Xmx256m -Dapollo_profile=github,auth -Ddev_meta=http://localhost:8080/ -Dserver.port=8070 -Dspring.datasource.url=jdbc:mysql://%url%/ApolloPortalDB?characterEncoding=utf8 -Dspring.datasource.username=%username% -Dspring.datasource.password=%password% -Dlogging.file=.\\logs\\apollo-portal.log -jar .\\apollo-portal-1.3.0.jar\n\n启动Apollo配置中心，端口不能被占用\n\n执行runApollo.bat脚本\n\n\n\n创建一个Apollo项目\n\n\n\n创建需要的配置\n\n\n\n创建完成后用Idea测试，创建一个spring boot项目\n\n引入依赖\n&lt;dependency&gt;            &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt;            &lt;artifactId&gt;apollo-client&lt;/artifactId&gt;            &lt;version&gt;1.8.0&lt;/version&gt;        &lt;/dependency&gt;\n\n指定配置项目的id 环境 和地址\n-Dapp.id&#x3D;apollo-quick -Denv&#x3D;DEV -Ddev_meta&#x3D;http:&#x2F;&#x2F;localhost:8080\n\n\n\n\n\n\n测试类进行测试\n@Slf4j@SpringBootTestclass Project7ApplicationTests &#123;    @Test    void contextLoads() &#123;        Config appConfig = ConfigService.getAppConfig();  //获取配置对象       //Apollo是热发布的，实时更新，使用方法测试        while (true)&#123;            try &#123;                Thread.sleep(1000);                //获取配置信息，第一个参数：配置的key，第二个参数：默认值                String sms = appConfig.getProperty(&quot;sms&quot;, null);                log.info(&quot;sms: &quot;+sms);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;\n\n2.Apollo核心概念1.application(应用)​    就是实际使用配置的应用，Apollo客户端在运行时需要知道当前应用是谁从而可以去获取对应的配置  关键字：appId\n2.environment（环境）配置对应的环境，Apollo客户端在运行时需要知道当前应用处于哪个环境，从而可以去获取应用的配置  关键字：env\n3.cluster（集群）一个应用下不同实例的分组，比如典型的可以按照数据中心分。把上海机房的应用实例分为一个集群，把北京机房的应用实例分为另一个集群。  关键字：cluster\n4.namespace(命名空间)一个应用下不同配置的分组，可以简单的把namespace类比为文件，不同类型的配置放在不同的文件中，如数据库配置文件，RPC配置文件，应用自身的配置文件等。 关键字：namespace\n他们的关系图：\n\n\n3.Apollo项目管理1.基础设置\n添加部门\n\nApollo主页  –&gt;   管理员工具  –&gt;   系统参数\n\n\n\n查询配置信息：organizations然后在返回的json数据中添加\n\n\n\n\n添加用户\n\nApollo主页  –&gt;   管理员工具  –&gt;   用户管理\n\n删除项目\n\nApollo主页  –&gt;   管理员工具  –&gt;  删除应用，集群\n\n\n\n2.添加Namespace\n\n\n快捷导入配置\n复制配置放入文本中\n\n\n获取namespace的配置\n@Slf4j@SpringBootTestclass Project7ApplicationTests &#123;    @Test    void contextLoads() &#123;//        Config appConfig = ConfigService.getAppConfig();  获取默认namespace下的配置信息        //获取指定namespace下的配置信息        Config appConfig =  ConfigService.getConfig(&quot;apollo-redis&quot;);        while (true)&#123;            try &#123;                Thread.sleep(1000);                String sms = appConfig.getProperty(&quot;spring.redis.host&quot;, null);                log.info(&quot;spring.redis.host: &quot;+sms);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;\n\n4.springboot集成Apollo1.使用@value注解获取\n获取默认namespace的值\n\n\n导入依赖\n&lt;dependency&gt;            &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt;            &lt;artifactId&gt;apollo-client&lt;/artifactId&gt;            &lt;version&gt;1.8.0&lt;/version&gt;        &lt;/dependency&gt;\n\n编写Apollo相关的配置\napp.id=apollo-quickapollo.meta=http://localhost:8080\n\n使用controller进行测试\n@EnableApolloConfig //@RestControllerpublic class apolloController &#123;    @Value(&quot;$&#123;mysql&#125;&quot;) //获取key为mysql的配置    private String name;    @GetMapping(&quot;/mysql&quot;)    public Object getapollo()&#123;        return &quot;mysql&quot;+name;    &#125;&#125;\n\n\n\n\n\n获取指定namespace的值@RestController@EnableApolloConfig(&quot;redis&quot;)  //指定namespace名称public class redisController &#123;    @Value(&quot;$&#123;spring.redis.host&#125;&quot;)    private String redisHost;    @Value(&quot;$&#123;spring.redis.client-type&#125;&quot;)    private String redisType;    @GetMapping(&quot;/redis&quot;)    public Object getRedis()&#123;        return &quot;redis连接地址： &quot;+redisHost+&quot;redis类型： &quot;+redisType;    &#125;&#125;\n\n\n\n2.使用bean注入的方式获取\nbean\n\n@Component@ConfigurationProperties(&quot;spring.redis&quot;) //添加之后自动识别此前缀下的配置@Datapublic class ApolloConfig &#123;    private String host;  //加上前缀对应配置中心的key    private String client_type;&#125;\n\n\ncontroller\n@RestController@EnableApolloConfig(&quot;redis&quot;)public class BeanController &#123;    @Autowired    ApolloConfig apolloConfig;    @GetMapping(&quot;/redisBean&quot;)    public Object getRedisBean()&#123;        return apolloConfig;    &#125;&#125;\n\nbean注入不会自动刷新，使用@RefreshScope注解&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt;            &lt;version&gt;3.0.1&lt;/version&gt;        &lt;/dependency&gt;\n\n\n自动刷新配置类@Componentpublic class RefreshConfig &#123;    @Autowired    ApolloConfig apolloConfig;    @Autowired    RefreshScope refreshScope;        @ApolloConfigChangeListener(&#123;&quot;redis&quot;&#125;)    public  void  onChange(ConfigChangeEvent configChangeEvent)&#123;        boolean configChange = false;        for(String cKey : configChangeEvent.changedKeys())&#123;            if (cKey.startsWith(&quot;spring.redis&quot;))&#123;                configChange = true;                break;            &#125;        &#125;        if (!configChange)&#123;            return;        &#125;        refreshScope.refresh(&quot;apolloConfig&quot;);    &#125;&#125;\n\nbean@Component@ConfigurationProperties(&quot;spring.redis&quot;)@Data@RefreshScopepublic class ApolloConfig &#123;    private String host;    private String client_type;&#125;\n\n目前会报错 还没找到原因，记录一下Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.http.converter.HttpMessageConversionException: Type definition error: [simple type, class org.springframework.context.expression.StandardBeanExpressionResolver]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class org.springframework.context.expression.StandardBeanExpressionResolver and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: com.project.project7.config.ApolloConfig$$EnhancerBySpringCGLIB$$7b737735[&quot;targetSource&quot;]-&gt;org.springframework.aop.target.SimpleBeanTargetSource[&quot;beanFactory&quot;]-&gt;org.springframework.beans.factory.support.DefaultListableBeanFactory[&quot;beanExpressionResolver&quot;])] with root cause\n\n\n\n\n\n3.灰度发布\n获取方式也是用@value，跟一一样\n\n5.Apollo的高可用"},{"title":"Hello World","url":"/2020/07/05/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Spring Security学习记录基础版(一)","url":"/2021/03/23/security-md/","content":"Spring Security学习记录基础版(一)1.概要\nSpring Security的核心功能\n用户认证：就是系统认为用户是否登录\n用户授权：就是系统判断用户是否有权限去做某些事情\n\n\n\n2.Hello Security\n创建一个SpringBoot工程\n\n引入相关依赖\n&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;\n\n\n\n\n\n\n编写controller测试\n@RestController@RequestMapping(&quot;quick&quot;)public class QuickController &#123;    @GetMapping(&quot;/hello&quot;)    public Object hello()&#123;        return &quot;hello security&quot;;    &#125;&#125;\n\n\n\n\n\n\n测试结果：security启动默认会有一个登录页，security默认得用户名是：user 密码每次执行会在控制台打印，登录成功后显示测试结果\n\n\n\n\n\n3.SpringSecurity基本原理\nSpringSecurity本质是一个过滤器链，由很多过滤器组成\n\nFilterSecurityInterceptor：是一个方法级的权限过滤器，基本位于过滤链的最底部\n\nExceptionTranslationFilter：是个异常过滤器，用来处理在认证授权过程中的异常\n\nUsernamePasswordAuthenticationFilter：对／login的POST请求做拦截，校验表单中用户名，密码\n\nSpringSecurity两个重要的接口\n\nUserDetailsService接口:查询数据库用户名和密码的过程\n创建类继承UsernamePasswordAuthenticationFilter,重写三个方法\n创建类实现UserDetailService,编写查询数据过程,返回User对象,这个User对象是Security提供的对象\n\n\nPasswordEncoder接口:数据加密接口,用于返回User对象里面密码加密\n\n\n\n4.security设置用户和密码\n通过配置文件设置(了解)\nspring:  security:    user:      name: admin      password: 123456      roles: root\n\n\n\n\n\n\n通过配置类设置(了解)\n@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Autowired    PasswordEncoder passwordEncoder;    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        //将密码加密        String password = passwordEncoder.encode(&quot;123456&quot;);        auth.inMemoryAuthentication().withUser(&quot;test&quot;)            .password(password).roles(&quot;test&quot;);    &#125;    //不加这一步会报@PreAuthorizeConsider defining a bean of type \t\t&#x27;org.springframework.security.crypto.password.PasswordEncoder&#x27; in your configuration.    @Bean    public PasswordEncoder passwordEncoder() &#123;        return new BCryptPasswordEncoder();    &#125;&#125;\n\n自定义实现类设置\n\n第一步  创建配置类,设置使用哪个userDetailsService实现类\n@Configurationpublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Autowired    private UserDetailsService userDetailsService;    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());    &#125;    @Bean    public PasswordEncoder passwordEncoder() &#123;        return new BCryptPasswordEncoder();    &#125;&#125;\n\n\n\n\n\n\n\n\n第二步   编写实现类,返回User对象,User对象有用户名密码和操作权限\n@Servicepublic class MyUserDetailsService implements UserDetailsService &#123;    @Override    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123;        List&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role&quot;);        return new User(&quot;test&quot;,new BCryptPasswordEncoder().encode(&quot;123&quot;),auths);    &#125;&#125;\n\n\n\n5.查询数据库完成用户认证\n引入相关依赖\n&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;            &lt;version&gt;3.4.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.23&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;\n\n\n\n\n\n\n创建数据库\nCREATE DATABASE testUSE testCREATE TABLE users(\tid INT(10) PRIMARY KEY AUTO_INCREMENT,\tuname VARCHAR(30) NOT NULL,\tupassword VARCHAR(80) NOT NULL)INSERT INTO users VALUES (DEFAULT,&#x27;admin&#x27;,&#x27;123456&#x27;);INSERT INTO users VALUES (DEFAULT,&#x27;test&#x27;,&#x27;123&#x27;);INSERT INTO users VALUES (DEFAULT,&#x27;root&#x27;,&#x27;123456&#x27;)\n\n\n\n\n\n\n配置数据库相关信息\nspring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8    username: root    password: 123456\n\n\n\n\n\n\n创建users表对应实体类\n@Data@AllArgsConstructor@NoArgsConstructorpublic class Users &#123;    private long id;    private  String uname;    private  String upassword;&#125;\n\n\n\n\n\n\n整合mybatisPlus,创建接口,继承mp的接口\npublic interface UserMapper extends BaseMapper&lt;Users&gt; &#123;&#125;\n\n\n\n\n\n\n在MyUserDetailsService调用mapper里面的方法查询数据库进行用户认证\n@Servicepublic class MyUserDetailsService implements UserDetailsService &#123;    @Autowired    UserMapper userMapper;    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;        //mybatisplus提供的条件构造器        QueryWrapper&lt;Users&gt; wrapper = new QueryWrapper();        //下面这句话等同于where uname=?        wrapper.eq(&quot;uname&quot;,username);        //因为用户名不能重复，使用selectOne得到某一条数据        Users user = userMapper.selectOne(wrapper);        if(user == null)&#123;            throw new UsernameNotFoundException(&quot;用户不存在&quot;);        &#125;        List&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role&quot;);       //查询数据库得到的user对象的用户名和密码返回给security提供的User对象里面        return new User(user.getUname(),new BCryptPasswordEncoder().encode(user.getUpassword()),auths);    &#125;&#125;\n\n\n\n\n\n\n在启动类上添加@MapperScan注解\n@SpringBootApplication@MapperScan(&quot;com.project.securityquickstart.mapper&quot;)public class SecurityQuickStartApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SecurityQuickStartApplication.class, args);    &#125;&#125;\n\n\n\n\n\n\n启动测试\n@RestController@RequestMapping(&quot;quick&quot;)public class QuickController &#123;    @GetMapping(&quot;/hello&quot;)    public Object hello()&#123;        return &quot;hello security&quot;;    &#125;&#125;\n\n测试成功,三个账号都可以进行登录,但是启动时出现如下警告:  This primary key of “id” is primitive !不建议如此请使用包装类 in Class: “com.project.securityquickstart.bean.Users”\n\n\n6.自定义登录页\n配置类编写相关的配置\n@Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.formLogin()    //自定义自己的登录页面                .loginPage(&quot;/login.html&quot;)   //登录页面设置                .loginProcessingUrl(&quot;/quick/login&quot;)  //登录页访问路径                .defaultSuccessUrl(&quot;/quick/index&quot;).permitAll()   //登录成功后跳转的地址                .and().authorizeRequests()                //配置不用认证就能访问的页面                .antMatchers(&quot;/&quot;,&quot;/quick/login&quot;,&quot;/quick/hello&quot;).permitAll()                .anyRequest().authenticated()                .and().csrf().disable();   //关闭csrf防护    &#125;\n\n\n\n\n\n\n创建登录的页面\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;security自定义登录页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;        &lt;form action=&quot;/quick/login&quot; method=&quot;post&quot;&gt;            &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;            &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;            &lt;input type=&quot;submit&quot; value=&quot;Login&quot;/&gt;        &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n\n\n\n编写controller测试\n@RestController@RequestMapping(&quot;quick&quot;)public class QuickController &#123;    @GetMapping(&quot;/hello&quot;)    public Object hello()&#123;        return &quot;hello security&quot;;    &#125;    @GetMapping(&quot;/index&quot;)    public Object login()&#123;        return &quot;hello index&quot;;    &#125;&#125;\n\n效果图\n\n当我输入http://localhost:8080/quick/index的时候会自动跳转登录页\n\n\n登录成功后会跳转到配置类里配置的/quick/index的controller\n\n\n\n\n\n7.基于权限进行访问控制\n如果当前的主体具有指定权限,则返回true,否则返回false \n\n没有访问权限   403\n\nhasAuthority和hasAnyAuthority方法的使用实例\n\n在配置类编写基于权限进行访问控制的相关配置\n @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.formLogin()    //自定义自己的登录页面                .loginPage(&quot;/login.html&quot;)   //登录页面设置                .loginProcessingUrl(&quot;/quick/login&quot;)  //登录页访问路径                .defaultSuccessUrl(&quot;/quick/index&quot;).permitAll()   //登录成功后跳转的地址                .and().authorizeRequests()                //配置访问权限为admins的才能访问/quick/index,只能配置单个//                .antMatchers(&quot;/quick/index&quot;).hasAuthority(&quot;admins&quot;)                //配置访问权限为admins和role的都能访问/quick/index，可配置多个                .antMatchers(&quot;/quick/index&quot;).hasAnyAuthority(&quot;admins,role&quot;)                //配置不用认证就能访问的页面                .antMatchers(&quot;/&quot;,&quot;/quick/login&quot;,&quot;/quick/hello&quot;).permitAll()                .anyRequest().authenticated()                .and().csrf().disable();   //关闭csrf防护    &#125;\n\n\n\n\n\n\n\n\n在MyUserDetailsService里配置用户的访问权限\nList&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role&quot;);\n\n\n\n\n\n8.基于角色进行访问控制\n如果当前主题具有指定角色,则返回true\n\nhasRole和hasAnyRole使用实例\n\n在配置类编写基于角色进行访问控制的相关配置\n                //配置角色为root的才能访问/quick/index，只能配置单个角色//                .antMatchers(&quot;/quick/index&quot;).hasRole(&quot;root&quot;)                //配置角色为root和admin中的一个的就能访问/quick/index，可配置多个角色                .antMatchers(&quot;quick/index&quot;).hasAnyRole(&quot;root,admin&quot;)\n\n在MyUserDetailsService里配置用户的角色\nList&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role,ROLE_root,ROLE_admin&quot;);\n\n注意:security底层的hasRole和hasAnyRole方法会给你加上”ROLE_”的前缀,在配置用户角色的时候要记得加上\n\n\n\n\n\n9.自定义403页面\n在配置类中编写\nhttp.exceptionHandling().accessDeniedPage(&quot;/unauth.html&quot;);\n\n编写unauth.html页面,效果图:\n\n\n\n10.注解的使用10.1@Secured  –用户具有某个角色，可以访问方法\n在启动类或配置类开启注解\n@EnableGlobalMethodSecurity(securedEnabled = true)public class SecurityQuickStartApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SecurityQuickStartApplication.class, args);    &#125;&#125;\n\n\n\n\n\n\n在controller添加@Secured能够访问的角色\n\n@GetMapping(&quot;/getUpd&quot;)  @Secured(&quot;ROLE_root&quot;)  public Object upd()&#123;      return &quot;hello,update&quot;;  &#125;\n\n\n在MyUserDetailsService查看有没有配置能访问的角色并测试\nList&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role,admins,ROLE_root&quot;);\n\n\n\n10.2@PreAuthorize   –在进入方法之前进行权限和角色验证\n在启动类或配置类开启注解\n@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)\n\n在在controller添加@PreAuthorize能够访问的角色和权限\n @GetMapping(&quot;/getUpd&quot;)@PreAuthorize(&quot;hasAuthority(&#x27;role&#x27;)&quot;)  public Object upd()&#123;      return &quot;hello,update&quot;;  &#125;\n\n在MyUserDetailsService查看有没有配置能访问的角色并测试\n\n这个注解里面可以写hasRole、hasAnyRole、hasAuthority和hasAnyAuthority\n\n\n10.3@PostAuthorize  –在方法执行之后进行权限和角色验证\n在启动类或配置类开启注解  –同上\n\n在controller添加@PreAuthorize能够访问的角色和权限\n    @GetMapping(&quot;/getUpd&quot;)//    @Secured(&quot;ROLE_root&quot;)//   @PreAuthorize(&quot;hasAuthority(&#x27;role&#x27;)&quot;)    @PostAuthorize(&quot;hasAuthority(&#x27;role&#x27;)&quot;)    public Object upd()&#123;        System.out.println(&quot;update执行中&quot;);        return &quot;hello,update&quot;;    &#125;&#125;\n\n在MyUserDetailsService查看有没有配置能访问的角色并测试，测试发现虽然没权限访问，但是里面的方法还是打印了\n\n\n\n\n\n这个注解里面可以写hasRole、hasAnyRole、hasAuthority和hasAnyAuthority\n\n10.4@PostFilter  –方法返回的数据进行过滤\n在controller注解中添加@PostFilter  需要过滤的数据,可以搭配上面的注解一起使用\n@GetMapping(&quot;/getAll&quot;)   @PreAuthorize(&quot;hasAuthority(&#x27;role&#x27;)&quot;)   @PostFilter(&quot;filterObject.uname == &#x27;admin1&#x27;&quot;)   public List&lt;Users&gt; getAll()&#123;       List&lt;Users&gt; list = new ArrayList&lt;Users&gt;();       list.add(new Users(0,&quot;admin1&quot;,&quot;123&quot;));       list.add(new Users(0,&quot;admin2&quot;,&quot;123&quot;));       return list;   &#125;\n\n\n\n\n\n\n测试结果，只返回指定过滤的值\n\n\n\n10.5@PreFilter  –方法传入的数据进行过滤\n暂时还不知道怎么用，出现如下错误\n\nServlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.IllegalArgumentException: Filter target must be a collection, array, map or stream type, but was Users(uname&#x3D;admin1, upassword&#x3D;123456)] with root cause\n\n11.用户注销\n在登录页添加一个退出的超链接\n&lt;a href=&quot;/logout&quot;&gt;注销&lt;/a&gt;\n\n\n\n\n\n\n在配置类中添加退出映射地址\nhttp.logout().logoutUrl(&quot;/logout&quot;).logoutSuccessUrl(&quot;/quick/exit&quot;).permitAll();\n\n\n\n\n\n\n测试类测试\n@GetMapping(&quot;/exit&quot;)   public Object exit()&#123;       return &quot;注销成功。。。。&quot;;   &#125;\n\n测试结果注销是能注销，但是在访问其他方法不需要登录验证了\n\n\n12.自动登录\n创建保存用户token的数据库\nCREATE TABLE persistent_logins(\tusername VARCHAR(64) NOT NULL,\tseries VARCHAR(64) NOT NULL,\ttoken VARCHAR(64) NOT NULL,\tlast_used TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\tPRIMARY KEY(series))ENGINE = INNODB DEFAULT CHARSET=utf8;\n\n配置类，注入数据源，配置操作数据库对象\n@Autowired    private DataSource dataSource;    @Bean    public PersistentTokenRepository persistentTokenRepository()&#123;        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();        jdbcTokenRepository.setDataSource(dataSource);        return jdbcTokenRepository;    &#125;\n\n\n\n\n\n\n配置类中配置自动登录\n.and().rememberMe().tokenRepository(persistentTokenRepository()) //配置自动登录的有效时间              .tokenValiditySeconds(120)    .userDetailsService(userDetailsService)\n\n\n\n\n\n\n在登录页面添加复选框\n/*name必须叫remember-me，因为security内部封装了只识别这个名字的方法*/&lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; title=&quot;自动登录&quot;&gt; 自动登录\n\n\n\n13.csrf防护\n默认开启的，了解就行\n\n"},{"title":"我的第一篇博客文章","url":"/2020/07/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","content":"第一章内容\n\n第二章内容\n\n参考文献www.baidu.com\n"}]